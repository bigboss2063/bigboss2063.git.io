<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MIT 6.s081 Lab11: networking</title>
      <link href="/post/15f71c04.html"/>
      <url>/post/15f71c04.html</url>
      
        <content type="html"><![CDATA[<p>本次 lab 要给 xv6 实现网卡（Qemu 模拟 E1000 网卡）驱动。任务说明书里给了一大段说明以及 E1000 的操作手册。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="xv6-发送和接收网络包的流程"><a href="#xv6-发送和接收网络包的流程" class="headerlink" title="xv6 发送和接收网络包的流程"></a>xv6 发送和接收网络包的流程</h3><p>发送数据包：</p><ol><li>用户程序调用 connect 系统调用创建 socket 并获取 socket 的文件描述符；</li><li>调用 write 系统调用往 socket 的文件描述符中写入数据；</li><li>进入内核，调用 filewrite 函数，由于要写入的文件类型是 FD_SOCK，所以调用 sockwrite 函数，创建一个 mbuf 并将数据从用户空间拷贝过来；</li><li>调用 net_tx_udp 函数进行 udp 头部封装；</li><li>进一步调用 net_tx_ip 函数进行 ip 头部封装；</li><li>调用 net_tx_eth 函数，并将 m 通过e1000_transmit 函数传递给网卡驱动；</li><li>由 e1000_transmit 函数将 mbuf 放到发送队列的尾部，等待网卡设备发送。</li></ol><p>接受数据包：</p><ol><li>网卡接收到新的数据包，产生中断，内核调用中断处理函数 e1000_intr；</li><li>调用 e1000_recv 函数，开始读取缓冲队列中的消息；</li><li>读到一条消息后，通过net_rx 函数向上层传递；</li><li>根据消息的类型，判断是调用 net_rx_ip 函数还是 net_rx_arp 函数；</li><li>如果是 ip 消息，还需要进一步调用net_rx_udp 函数进行拆解；</li><li>调用 sockrecvudp 函数，在其中找到对应的 socket，再通过 mbufq_pushtail 函数将消息放到队列中，待 sockread 函数读取；</li></ol><p>以上就是 xv6 收发网络包的大体流程，具体可以自己阅读源码。</p><h3 id="描述符和缓冲队列"><a href="#描述符和缓冲队列" class="headerlink" title="描述符和缓冲队列"></a>描述符和缓冲队列</h3><p>驱动中有两种缓冲队列，发送和接收的队列，分别有两种描述符对应这两种队列。描述中中记录了对应缓存的存储地址、数据长度，还有一些标志位来让网卡和网卡驱动进行一些判断：</p><ul><li>E1000_TXD_STAT_DD 标志位就是让网卡驱动在发送数据时判断当前拿到的描述符对应的缓存是否已经发送了；</li><li>E1000_RXD_STAT_DD 标志位就是在接受数据的时候判断是否是没有接收过的数据；</li><li>E1000_TXD_CMD_RS 表示 Report Status，当这个字段被设置时，表示在数据包发送完成后，e1000 网卡会自动填充传输描述符中的报告状态区域，可以用来检查数据包是否发送成功。</li><li>E1000_TXD_CMD_EOP 表示 End Of Packet，当这个字段被设置时，表示数据包已经到达了传输描述符中的缓冲区的末尾。当该字段被设置时，意味着这是一个完整的数据包，可以开始传输了。</li></ul><p>上面的这几个 status 或 cmd 位是我们需要用到的。</p><h3 id="环形缓冲队列的头尾"><a href="#环形缓冲队列的头尾" class="headerlink" title="环形缓冲队列的头尾"></a>环形缓冲队列的头尾</h3><p>regs 数组中存储着 e1000 的寄存器的值，完成 lab 来说，需要使用到 regs[E1000_TDT]，即下一个需要传输的环形缓冲队列的索引，还有 regs[E1000_RDT]，即当前已经读到并且读过的环形缓冲队列索引。根据 Hints 来增加索引即可。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>首先实现 e1000_transmit。根据刚刚的调用流程分析，可能会有多个进程同时调用该函数，所以为了防止发生竞态，需要对函数上锁。接下来的步骤就是按照 Hints 来就行：</p><ol><li>上锁；</li><li>获取 regs[E1000_TDT] 位置的描述符；</li><li>判断描述符 status 的 E1000_TXD_STAT_DD 是否被设置，没被设置说明之前数据还没发送，这个描述符对应的位置不能放入一个新的数据，返回 -1；</li><li>否则如果这个描述符对应的位置有数据则释放（调用 mbuffree）；</li><li>重新设置描述符的 addr、length、cmd；</li><li>更新 regs[E1000_TDT] 为 （regs[E1000_TDT]+1）% TX_RING_SIZE；</li><li>将参数 m 放入缓冲区中；</li><li>释放锁，返回 0；</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">e1000_transmit</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// the mbuf contains an ethernet frame; program it into</span></span><br><span class="line">  <span class="comment">// the TX descriptor ring so that the e1000 sends it. Stash</span></span><br><span class="line">  <span class="comment">// a pointer so that it can be freed after sending.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;e1000_lock);</span><br><span class="line"></span><br><span class="line">  uint32 txrid = regs[E1000_TDT];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span> *<span class="title">txdesc</span> =</span> &amp;tx_ring[txrid];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((txdesc-&gt;status &amp; E1000_TXD_STAT_DD) == <span class="number">0</span>) &#123;</span><br><span class="line">    release(&amp;e1000_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(txdesc-&gt;addr != <span class="number">0</span>) &#123;</span><br><span class="line">    mbuffree((<span class="keyword">struct</span> mbuf *) tx_mbufs[txrid]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  txdesc-&gt;addr = (uint64) m-&gt;head;</span><br><span class="line">  txdesc-&gt;length = m-&gt;len;</span><br><span class="line">  txdesc-&gt;cmd |= E1000_TXD_CMD_RS;</span><br><span class="line">  txdesc-&gt;cmd |= E1000_TXD_CMD_EOP;</span><br><span class="line"></span><br><span class="line">  regs[E1000_TDT] = (txrid + <span class="number">1</span>) % TX_RING_SIZE;</span><br><span class="line"></span><br><span class="line">  tx_mbufs[txrid] = m;</span><br><span class="line"></span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是 e1000_recv，注意它是不可以上锁的。第一是只有在处理中断的时候会调用该函数，不会发生竞态，第二是如果接收到的数据包是 ARP 数据包，那么在解包的时候就会调用 net_tx_arp 函数回复自己的 mac，会调用 e1000_transmit 再次获取锁，发生 panic。</p><p>根据 Hints：</p><ol><li>获取下一个要读的描述符；</li><li>判断描述符的 E1000_RXD_STAT_DD 位是否被设置，没被设置就返回。注意这里要用一个循环来读取，直到不满足条件：</li></ol><p>Your e1000_recv() code must scan the RX ring and deliver each new packet’s mbuf to the network stack (in net.c) by calling net_rx().</p><ol start="3"><li>将描述符指向的数据通过 net_rx 传递给上层；</li><li>创建一个新的 mbuf 放入该位置中；</li><li>更新 regs[E1000_RDT] 为当前位置；</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">e1000_recv</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Check for packets that have arrived from the e1000</span></span><br><span class="line">  <span class="comment">// Create and deliver an mbuf for each packet (using net_rx()).</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  uint32 rxrid = (regs[E1000_RDT] + <span class="number">1</span>) % RX_RING_SIZE;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rx_desc</span> *<span class="title">rxdesc</span> =</span> &amp;rx_ring[rxrid];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (rxdesc-&gt;status &amp; E1000_RXD_STAT_DD) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m</span> =</span> rx_mbufs[rxrid];</span><br><span class="line"></span><br><span class="line">    m-&gt;len = rxdesc-&gt;length;</span><br><span class="line">    net_rx(m);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">nm</span> =</span> mbufalloc(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    rxdesc-&gt;addr = (uint64) nm-&gt;head;</span><br><span class="line">    rxdesc-&gt;status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rx_mbufs[rxrid] = nm;</span><br><span class="line"></span><br><span class="line">    regs[E1000_RDT] = rxrid;</span><br><span class="line"></span><br><span class="line">    rxrid = (regs[E1000_RDT] + <span class="number">1</span>) % RX_RING_SIZE;</span><br><span class="line"></span><br><span class="line">    rxdesc = &amp;rx_ring[rxrid];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b539074750aa422aa18595066f9f3c56~tplv-k3u1fbpfcp-zoom-1.image"></p><p>这次不用跑 usertests，很快就跑完了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次实验给的材料太多了，还挺难看完的。建议选着看就行了，因为我感觉实际上只看 Hints 也能做个八九不离十。这次 lab 相对简单，有很多可以做的事情都在 Optional Challenges 中，感觉有时间可以做一做。</p><h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2><p>MIT 6.S081 Fall 2020 的 lab 算是全部做完了，如释重负，不过 Optional Challenges 是一个没做。后续计划再整体好好过一遍代码整理对应的知识。其实我感觉收益还是蛮大的，只要动手了，即使实现的版本是性能不高并且简单的，对相应知识的理解也能更加深刻，更别说后续再做 Optional Challenges。</p><p>并且我感觉这门课的 lab 比起 6.824 来说更加与课程内容强相关，上课没懂的地方看看代码或许就懂了，上手也会更加简单。</p><p>还剩了几堂 Lecture 没看完，希望五月份之前能搞定吧。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab10: mmap</title>
      <link href="/post/a1137fe6.html"/>
      <url>/post/a1137fe6.html</url>
      
        <content type="html"><![CDATA[<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>这次 lab 是要给 xv6 添加 mmap 和 munmap 系统调用。</p><p>mmap 的好处在于可以将一个文件直接映射到进程的地址空间中，从而避免了不必要的数据复制，提高了文件操作的效率。与使用 read 和 write 系统调用不同，mmap 操作不需要将文件数据从内核缓冲区复制到用户缓冲区，也不需要将用户缓冲区中的数据复制回内核缓冲区。相反，它通过映射文件的方式，将文件数据直接映射到了进程的地址空间中，因而可以提高文件操作的效率。</p><p>同时 mmap 也避免了由于使用 read 和 write 系统调用而造成的在用户空间和内核空间的上下文切换，节省了系统调用的开销。</p><h3 id="系统调用声明"><a href="#系统调用声明" class="headerlink" title="系统调用声明"></a>系统调用声明</h3><p>mmap 系统调用的函数声明为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, uint64 len, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, uint64 offset)</span>;</span><br></pre></td></tr></table></figure><ul><li>addr 为文件在用户地址空间的起始地址，一般传入 0，由内核设置；</li><li>len 为要映射的字节数量；</li><li>prot 为权限字段，指明该文件是可读（PROT_READ）、可写（PROT_WRITE）或可执行（PROT_EXEC）的；</li><li>flags 为标记位，标记映射的模式，MAP_SHARED 模式标识在 munmap 的时候需要把改动写回磁盘，MAP_PRIVATE 模式则不需要；</li><li>fd 是文件的描述符；</li><li>offset 为文件起始位置到开始映射的位置的偏移量。</li></ul><p>munmap 系统调用的函数声明为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, uint64 len)</span>;</span><br></pre></td></tr></table></figure><ul><li>addr 为从哪里开始解除映射；</li><li>len 为解除映射的字节数。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>添加 mmap 和 munmap 系统调用的过程这里就省略了。直接来看实现。</p><p>首先，为了能够让用户进程知道关于文件映射的信息，需要在 proc 结构体记录下。新增 vma 结构体，来存储文件映射的相关信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma</span> &#123;</span></span><br><span class="line">  <span class="type">int</span>    valid; <span class="comment">// 该 vma 是否有效</span></span><br><span class="line">  uint64 addr;  <span class="comment">// 文件在进程地址空间中的起始地址</span></span><br><span class="line">  uint64 len;   <span class="comment">// 文件映射了多少字节</span></span><br><span class="line">  <span class="type">int</span>    prot;  <span class="comment">// 文件权限</span></span><br><span class="line">  <span class="type">int</span>    flags; <span class="comment">// 映射模式标识</span></span><br><span class="line">  <span class="type">int</span>    fd;    <span class="comment">// 文件标识符</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span> <span class="comment">// 指向对应的文件结构体</span></span><br><span class="line">  uint64 offset; <span class="comment">// 文件映射的偏移</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>并且在 proc 结构体中添加一个 vma 数组，根据 hint，大小为 16 即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma</span> <span class="title">vmatable</span>[<span class="title">NVMA</span>];</span> <span class="comment">// NVMA 为定义在 kernel/param.h 中的宏</span></span><br></pre></td></tr></table></figure><p>接着在 kernel&#x2F;sysfile.c 中实现 sys_mmap 函数。大致流程如下：</p><ol><li>接收 mmap 系统调用传递的参数；</li><li>判断参数是否可以满足映射条件：</li></ol><!----><ol><li><ol><li>只读文件在 MAP_PRIVATE 模式下，是可写的；</li><li>只读文件在 MAP_SHARED 模式下，是不可写的。</li></ol></li></ol><!----><ol start="3"><li>从进程中记录的 vma 中找出一个空闲的 vma，并在进程的 heap 中找出一段可用的内存，将这段内存的起始地址作为系统调用的返回值。注意在这里是不进行内存分配的，只是标记，跟 lazy alloction 是一样的，这样可以让映射比内存空间更大的文件成为可能。为了和进程正在使用的地址空间区分开，选择从 heap 的高位置开始向下扩展来映射文件，即从 TRAPFRAME 开始。</li><li>设置 vma 的值；</li><li>filedup 对应文件；</li></ol><p>mmap should increase the file’s reference count so that the structure doesn’t disappear when the file is closed.</p><p>close 系统调用关闭是的一个打开的文件描述符，只是减少该文件的打开引用数，在这里增加一次引用后，就算调用了 close 也不会影响到对已经映射的内存。</p><ol start="6"><li>返回映射的起始地址；</li></ol><p>实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_mmap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  uint64 len, offset;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> prot, flags, fd;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">1</span>, &amp;len) &lt; <span class="number">0</span> || argint(<span class="number">2</span>, &amp;prot) &lt; <span class="number">0</span> || argint(<span class="number">3</span>, &amp;flags) &lt; <span class="number">0</span> || argint(<span class="number">4</span>, &amp;fd) &lt; <span class="number">0</span> || argaddr(<span class="number">5</span>, &amp;offset) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> =</span> p-&gt;ofile[fd];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ((file-&gt;readable &amp;&amp; !file-&gt;writable) &amp;&amp; (prot &amp; PROT_WRITE) &amp;&amp; (flags &amp; MAP_SHARED)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">vma</span> =</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">  uint64 addr = TRAPFRAME;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!p-&gt;vmatable[i].valid &amp;&amp; !found) &#123;</span><br><span class="line">      found = <span class="number">1</span>;</span><br><span class="line">      vma = &amp;p-&gt;vmatable[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;vmatable[i].valid &amp;&amp; p-&gt;vmatable[i].addr &lt; addr) &#123;</span><br><span class="line">      addr = p-&gt;vmatable[i].addr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  addr = addr - len;</span><br><span class="line"></span><br><span class="line">  vma-&gt;valid = <span class="number">1</span>;</span><br><span class="line">  vma-&gt;fd = fd;</span><br><span class="line">  vma-&gt;file = file;</span><br><span class="line">  vma-&gt;len = len;</span><br><span class="line">  vma-&gt;offset = offset;</span><br><span class="line">  vma-&gt;prot = prot;</span><br><span class="line">  vma-&gt;flags = flags;</span><br><span class="line">  vma-&gt;addr = addr;</span><br><span class="line"></span><br><span class="line">  filedup(vma-&gt;file);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成这一步后，在用户程序中调用 mmap 就会返回一个正确的映射后的起始地址了，但是当进行访问的时候，由于并没有分配内存，就会触发 page fault，所以跟 lazy alloction 一样，在 kernel&#x2F;trap.c#usertrap 中处理 page fault。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) &#123;</span><br><span class="line">  uint64 va = r_stval();</span><br><span class="line">  <span class="keyword">if</span> (mmaphandler(va) == <span class="number">-1</span>) &#123;</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>kernel&#x2F;vm.c#mmaphandler 函数接收一个虚拟内存地址（发生 page fault 的地址），来处理 pagefault。</p><p>在 mmaphandler 中，我们需要做以下事情：</p><ol><li>找出 va 是映射在哪个页中，也就是需要找出对应的 vma；</li><li>给 vma 正式分配内存；</li><li>根据 vma 中记录的 prot 来设置 PTE 的 flags；</li><li>将物理地址和虚拟地址进行映射；</li><li>使用 readi 将文件读到刚分配的内存中。在进行操作的时候要开启事务，并且对 inode 上锁。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mmaphandler</span><span class="params">(uint64 va)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">vma</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NVMA; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">v</span> =</span> &amp;p-&gt;vmatable[i];</span><br><span class="line">    <span class="keyword">if</span> (v-&gt;valid) &#123;</span><br><span class="line">      <span class="keyword">if</span> (va &gt;= v-&gt;addr &amp;&amp; va &lt; (v-&gt;addr + v-&gt;len * PGSIZE)) &#123;</span><br><span class="line">        vma = v;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vma == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  uint64 ka = (uint64)kalloc();</span><br><span class="line">  <span class="keyword">if</span> (ka == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>((<span class="type">void</span> *) ka, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  va = PGROUNDDOWN(va);</span><br><span class="line">  <span class="type">pte_t</span> * pte;</span><br><span class="line">  <span class="comment">// avoid remap panic.</span></span><br><span class="line">  <span class="keyword">if</span> ((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) != <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_V) != <span class="number">0</span>) &#123;</span><br><span class="line">    kfree((<span class="type">void</span> *) ka);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> flags = PTE_FLAGS(*pte);</span><br><span class="line">  <span class="keyword">if</span> (vma-&gt;prot &amp; PROT_READ) &#123;</span><br><span class="line">    flags |= PTE_R;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vma-&gt;prot &amp; PROT_WRITE) &#123;</span><br><span class="line">    flags |= PTE_W;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vma-&gt;prot &amp; PROT_EXEC) &#123;</span><br><span class="line">    flags |= PTE_X;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(mappages(p-&gt;pagetable, va, PGSIZE, ka, flags | PTE_U) != <span class="number">0</span>) &#123;</span><br><span class="line">    kfree((<span class="type">void</span> *) ka);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ip = vma-&gt;file-&gt;ip;</span><br><span class="line">  begin_op();</span><br><span class="line">  ilock(ip);</span><br><span class="line">  <span class="keyword">if</span> (readi(ip, <span class="number">0</span>, ka, PGROUNDDOWN(vma-&gt;offset + (va - vma-&gt;addr)), PGSIZE) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlock(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就可以访问我们映射到内存中的文件了。</p><p>接下来要实现 munmap 系统调用（kernel&#x2F;sysfile.c#sys_munmap），注意根据文档，munmap 可以是一部分，但是不会是在中间。</p><p>An munmap call might cover only a portion of an mmap-ed region, but you can assume that it will either unmap at the start, or at the end, or the whole region (but not punch a hole in the middle of a region).</p><p>在 sys_munmap 函数中我们要处理以下事情：</p><ol><li>接收 addr 和 len 参数；</li><li>找出 addr 对应的 vma；</li><li>判断 vma 是否是 MAP_SHARED 模式，如果是就调用 filewrite 将文件写回磁盘；</li><li>取消 munmap 部分的映射；</li><li>调整 vma 的长度和起始地址。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_munmap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  </span><br><span class="line">  uint64 addr, len;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span> || argaddr(<span class="number">1</span>, &amp;len) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">vma</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NVMA; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">v</span> =</span> &amp;p-&gt;vmatable[i];</span><br><span class="line">    <span class="keyword">if</span> (v-&gt;valid &amp;&amp; (v-&gt;addr &lt;= addr &amp;&amp; addr &lt; (v-&gt;addr + len))) &#123;</span><br><span class="line">      vma = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!vma) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (vma-&gt;flags &amp; MAP_SHARED &amp;&amp; vma-&gt;file-&gt;writable) &#123;</span><br><span class="line">    filewrite(vma-&gt;file, addr, len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  uvmunmap(p-&gt;pagetable, addr, len / PGSIZE, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  vma-&gt;len -= len;</span><br><span class="line">  <span class="keyword">if</span>(vma-&gt;len == <span class="number">0</span>) vma-&gt;valid = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;addr == addr) vma-&gt;addr += len;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意修改 uvmunmap，否则会报 panic。</p><p>当进程退出的时候，即调用 kernel&#x2F;proc.c#exit，我们需要将它映射的所有文件都 munmap 掉，就像调用 munmap 系统调用。由于我的实现是父子进程并不共享物理内存，所以直接释放掉即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... kernel/proc.c#exit</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NVMA; i++) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">v</span> =</span> &amp;p-&gt;vmatable[i];</span><br><span class="line">  <span class="keyword">if</span> (v-&gt;valid) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v-&gt;flags &amp; MAP_SHARED &amp;&amp; v-&gt;file-&gt;writable) &#123;</span><br><span class="line">      filewrite(v-&gt;file, v-&gt;addr, v-&gt;len);</span><br><span class="line">    &#125;</span><br><span class="line">    uvmunmap(p-&gt;pagetable, v-&gt;addr, v-&gt;len/PGSIZE, <span class="number">1</span>);</span><br><span class="line">    v-&gt;valid = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后修改 kernel&#x2F;proc.c#fork，在子进程复制父进程的内存时，可能会复制到没有映射或无效的条目，也要修改 uvmcopy 将 panic 去掉。在 fork 函数中只需要将 vma 复制一份给子进程就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...kernel/proc.c#fork</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NVMA; i++) &#123;</span><br><span class="line">  np-&gt;vmatable[i] = p-&gt;vmatable[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里 mmaptest 和 fork test 就都可以通过了。</p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16f785924bf3438694413adae57db01b~tplv-k3u1fbpfcp-zoom-1.image"></p><p>这次的 grader 倒是顺利跑过了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个 lab 是对 file system 的进一步深入，不过我感觉跟虚拟内存可能更加相关？难点主要是在 mmap 系统调用，要考虑如何给 vma 找到一块合适的内存空间，想清楚这里之后其它的就比较简单了。page fault 的处理跟 lazy alloction 是一样的。munmap 系统调用就相当于做了一次反操作。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab9: file system</title>
      <link href="/post/801fac79.html"/>
      <url>/post/801fac79.html</url>
      
        <content type="html"><![CDATA[<p>本次 lab 感觉就是对 xv6 文件系统代码进行熟悉，我们要扩充 xv6 支持的最大文件大小并且给 xv6 实现软链接。</p><h2 id="Large-files-moderate"><a href="#Large-files-moderate" class="headerlink" title="Large files (moderate)"></a>Large files (moderate)</h2><p>xv6 原本支持的最大文件大小只有 12 + 256 个 block，也就是 inode 结构体中 addr 数组的前 12 个元素指出的 12 个 block加上最后一个元素指出的一个 block 中指出了 256 个 block。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cea2a50d75964b9dbb762ddd2cb821e5~tplv-k3u1fbpfcp-zoom-1.image"></p><p>如上图所示，最后一位 singly-indirect block num 指出了一个 block，里面又存储了 256 个 direct block num。一个 block 是 1024B，一个 block num 为 4B，所以正好存储 256 个 direct block num。</p><p>我们要做的就是将文件容量扩充为 11 + 256 + 256*256。改为将 addr 数组前 11 位作为 direct block num，第 12 位作为 singly-indirect block num，将第 13 位作为 doubly-indirect block num。doubly-indirect block num 指向一个 block，这个 block 里面的每个条目都是一个 singly-indirect block num，也就是说还需要再定位一次，才能取到真正的 block num。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>修改 kernel&#x2F;fs.h 中的这几个宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLY_NINDIRECT (BSIZE / sizeof(uint))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DOUBLY_NINDIRECT SINGLY_NINDIRECT * SINGLY_NINDIRECT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE (NDIRECT + SINGLY_NINDIRECT + DOUBLY_NINDIRECT)</span></span><br></pre></td></tr></table></figure><p>并且记得将 struct inode 和 struct dinode 结构体中的 addrs 数组修改一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint addrs[NDIRECT+<span class="number">1</span>+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br></pre></td></tr></table></figure><p>核心就是修改 bmap，仿照原来的代码，对 doubly-indirect block num 进行搜索即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; SINGLY_NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  bn -= SINGLY_NINDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    现在的 bn / 256 的值用于在第一级索引中定位一个 block num，取出这个 block 作为二级索引。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    bn % 256 的值用于在第二级索引中定位一个 block num，这个 block num 就是 data block num。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    所有的 block 都是按需申请，没有的话就创建一个。</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; DOUBLY_NINDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT+<span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    uint idx = bn / (BSIZE / <span class="keyword">sizeof</span>(uint));</span><br><span class="line">    <span class="keyword">if</span>((addr = a[idx]) == <span class="number">0</span>) &#123;</span><br><span class="line">      a[idx] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    idx = bn % (BSIZE / <span class="keyword">sizeof</span>(uint));</span><br><span class="line">    <span class="keyword">if</span>((addr = a[idx]) == <span class="number">0</span>) &#123;</span><br><span class="line">      a[idx] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后修改 itrunc 来释放一个文件的所有 block，跟 bmap 是差不多的，doubly-indirect blocks 多遍历一层就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  uint *a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">      ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; SINGLY_NINDIRECT; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j])</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT+<span class="number">1</span>])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; SINGLY_NINDIRECT; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j]) &#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span> =</span> bread(ip-&gt;dev, a[j]);</span><br><span class="line">        uint *data = (uint*)b-&gt;data;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; SINGLY_NINDIRECT; k++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(data[k])</span><br><span class="line">            bfree(ip-&gt;dev, data[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(b);</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Symbolic-links-moderate"><a href="#Symbolic-links-moderate" class="headerlink" title="Symbolic links (moderate)"></a>Symbolic links (moderate)</h2><p>给 xv6 实现软连接（符号连接）。符号连接通过路径名连接到目标文件，也就是说在使用 open 系统调用的时候，如果打开的是一个符号连接，那么 file system 就会找到这个软连接指向的目标文件，再去打开目标文件（除非指定了 O_NOFOLLOW 标识，那么 fs 就会直接打开软连接，而不会去追踪到目标文件）。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>前面添加新的系统调用和这里就跳过了。</p><p>在 kernel&#x2F;stat.h 中添加 T_SYMLINK 来标识一个 inode 类型是软连接，在 kernle&#x2F;fcntl.h 中添加一个新的标识符 O_NOFOLLOW，以让 open 系统调用判断是要打开一个软连接还是追踪软连接的目标文件。</p><p>首先实现 kernel&#x2F;sysfile.c#sys_symlink</p><p>这是一个系统调用函数，对应的用户空间的声明是 int symlink(char*, char*)；所以我们需要先将两个参数拿到。</p><p>接着开启一个事务，在事务中完成 inode 的创建和写入。调用 create 函数创建 inode，要注意 create 返回的时候已经持有了 inode 的锁，不需要再次获取锁了，并且在事务结束时要调用 iunlockput 函数来释放锁并且取消一次引用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_symlink</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">char</span> path[MAXPATH], target[MAXPATH];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, target, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, path, MAXPATH) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="keyword">if</span>((ip = create(path, T_SYMLINK, <span class="number">0</span>, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n = <span class="built_in">strlen</span>(target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(writei(ip, <span class="number">0</span>, (uint64)target, <span class="number">0</span>, n) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  iunlockput(ip); <span class="comment">// 释放在 create 中获取的锁</span></span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 kernel&#x2F;sysfile.c#sys_open 系统调用，新增判断当前 path 指向的 inode 是否是软连接，并且检查O_NOFOLLOW 标志位。Hints 中写到两点注意事项：</p><ol><li>如果一个软连接又指向一个软连接，那么要递归找出最终的目标文件；</li><li>软连接可能会成环，这个时候就返回错误，hints 中的解决策略是限制递归次数为 10 次。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(omode &amp; O_CREATE)&#123;</span><br><span class="line">  ip = create(path, T_FILE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(ip == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 新增的代码在此处</span></span><br><span class="line">  <span class="type">int</span> symlinkdepth = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    symlinkdepth++;</span><br><span class="line">    <span class="keyword">if</span> (symlinkdepth &gt; <span class="number">10</span>) &#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span> (ip-&gt;type == T_SYMLINK &amp;&amp; !(omode &amp; O_NOFOLLOW)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)path, <span class="number">0</span>, MAXPATH) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        iunlockput(ip);</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>不知道是代码写的太臭还是我这个台式捡垃圾捡的 CPU 太慢的原因，直接跑 make grade 是直接超时了，一会用笔记本跑一下。直接在 qemu 中跑 bigfile、symlinktest、usertests 都是没问题的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次 lab 比上一个简单得多，在 symlink 部分需要好好读一下接口。我一开始没看清 create 中就已经获取了 inode 锁，并且没有释放，将 unlock(dp) 看成了 unlock(ip)，也卡了不少时间。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab8: locks</title>
      <link href="/post/e613f387.html"/>
      <url>/post/e613f387.html</url>
      
        <content type="html"><![CDATA[<p>本次 lab 是要重新设计 xv6 的内存分配器和块缓存来获取更高的并行性。要增加并行性通常要设计到更改数据结构和上锁策略来减少竞态。</p><h2 id="Memory-allocator-moderate"><a href="#Memory-allocator-moderate" class="headerlink" title="Memory allocator (moderate)"></a>Memory allocator (moderate)</h2><p>原本的 allocator 中只有一个单独的 freelist，也就是说 page 的分配和释放都会频繁的产生竞争。所以给每个 CPU 设置一个单独的 freelist 和一个单独的锁。所以进程在不同的 CPU 上申请和分配 page 就可以并行运行了。如果当前 CPU 上 freelist 的为空的时候，就要去别的 CPU 那里偷取 page，这个时候依旧会产生竞争。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>首先修改 CPU 结构体，在每个 CPU 中加入一个之前的 kmem，让每个 CPU 可以单独的分配内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-CPU state.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kmem</span> <span class="title">kmem</span>;</span></span><br><span class="line">  <span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line">  <span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过 NCPU 参数可以知道，有 8 个 CPU，所以在初始化 alloctor 的时候将 freepage 分成 8 份，分别放入 8 个 CPU 的 kmem 中。其实也可以初始化的时候都放到一个 CPU 里，然后其它 CPU 去偷。但是我感觉这样会有一个冷启动的过程，不如在初始化的时候直接先分配了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 offset = (PHYSTOP - (uint64)end)/<span class="number">8</span>;</span><br><span class="line">  uint64 left, right;</span><br><span class="line">  left = (uint64) end;</span><br><span class="line">  right = left + offset;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> &amp;cpus[i];</span><br><span class="line">    initlock(&amp;c-&gt;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    p = (<span class="type">char</span>*)PGROUNDUP(left);</span><br><span class="line">    <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)right; p += PGSIZE) &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(((uint64)p % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)p &lt; end || (uint64)p &gt;= PHYSTOP)</span><br><span class="line">        panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">      <span class="built_in">memset</span>(p, <span class="number">1</span>, PGSIZE);</span><br><span class="line">      r = (<span class="keyword">struct</span> run*)p;</span><br><span class="line">      r-&gt;next = c-&gt;kmem.freelist;</span><br><span class="line">      c-&gt;kmem.freelist = r;</span><br><span class="line">    &#125;</span><br><span class="line">    left = right;</span><br><span class="line">    right = right + offset;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 kfree，在释放的时候申请当前 CPU 的 kmem 锁，将 page 释放到当前 CPU 的 freelist 中即可，注意开关中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  push_off();</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;c-&gt;kmem.lock);</span><br><span class="line">  r-&gt;next = c-&gt;kmem.freelist;</span><br><span class="line">  c-&gt;kmem.freelist = r;</span><br><span class="line">  release(&amp;c-&gt;kmem.lock);</span><br><span class="line"></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是 kalloc，在分配的时候由于当前 CPU 的 freelist 可能已经为空了，那么就需要去其它 CPU 那里偷。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  push_off();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  <span class="type">int</span> cid = cpuid();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> &amp;cpus[cid];</span><br><span class="line"></span><br><span class="line">  acquire(&amp;c-&gt;kmem.lock);</span><br><span class="line">  r = c-&gt;kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">    c-&gt;kmem.freelist = r-&gt;next;</span><br><span class="line">    release(&amp;c-&gt;kmem.lock);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    release(&amp;c-&gt;kmem.lock);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == cid) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">nc</span> =</span> &amp;cpus[i];</span><br><span class="line">      acquire(&amp;nc-&gt;kmem.lock);</span><br><span class="line">      r = nc-&gt;kmem.freelist;</span><br><span class="line">      <span class="keyword">if</span> (r) &#123;</span><br><span class="line">        acquire(&amp;c-&gt;kmem.lock);</span><br><span class="line">        nc-&gt;kmem.freelist = r-&gt;next;</span><br><span class="line">        release(&amp;c-&gt;kmem.lock);</span><br><span class="line">        release(&amp;nc-&gt;kmem.lock);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        release(&amp;nc-&gt;kmem.lock);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  pop_off();</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去其它 CPU 那里偷的时候，由于要获取其它 CPU 的锁，所以会产生竞争。还有一种情况就是当前进程持有当前 CPU 的锁去偷其它 CPU 的时候，那个被偷的 CPU 可能也正在尝试偷当前 CPU，这样就会产生死锁。</p><p>可以选择在去别的 CPU 那里偷之前把当前 CPU 的锁释放掉，这样就不会产生死锁，破坏了死锁的必要条件。我在大佬的博客上看到说如果这个时候释放了锁，就会导致重复偷取 page。我想了一下，如果说在释放当前 CPU 的 kmem 锁之后，该进程被调度走了，另外一个进程又过来执行 kalloc，也发现当前 CPU 的 freelist 是空的，也会进行偷取。但是我感觉当前已经是关中断了，那么时钟中断也会被屏蔽，当前进程就不会被调度了，所以应该不会产生这种情况吧。这一块没有太懂，不过能通过测试，暂时先这样。</p><h2 id="Buffer-cache-hard"><a href="#Buffer-cache-hard" class="headerlink" title="Buffer cache (hard)"></a>Buffer cache (hard)</h2><p>这部分要做的事情跟第一部分的目的是一样的，修改 bcache 结构体，并降低锁的粒度。将原本的用一个大锁锁住整个双向链表的设计，拆分成一个 Hash Table，每个 bucket 一个锁，那么就可以使得访问不同 bucket 的进程并行访问 buffer cache。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>根据 hints，最基本的思路是很容易想到的。将 buffer 以哈希表的形式组织，bucket 的数量为 13 个，每个 bucket 需要一把锁。并且把原本的双向链表设计去掉，原本的双向链表是为了实现 LRU，但现在我们通过给每个 buffer 记录时间戳来实现 LRU，时间戳就为 kernel&#x2F;trap.c 中的 ticks。</p><p>所以 bcache 结构改为以下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buckets</span>[<span class="title">NBUCKET</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">bucketlocks</span>[<span class="title">NBUCKET</span>];</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure><p>在 buf 结构体中去掉 prev 指针，并加入 timestamp 字段，用于实现 LRU：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> valid;   <span class="comment">// has data been read from disk?</span></span><br><span class="line">  <span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf?</span></span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">  uint refcnt;</span><br><span class="line">  uint timestamp;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样一来就不需要维护双向链表了，binit 的实现也很简单，只需要初始化锁并且将 bcache.buf 中的所有 buffer 都放进 bcache.buckets[0]，并初始化每个 buf 的 sleeplock 即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NBUCKET; i++) &#123;</span><br><span class="line">    initlock(&amp;bcache.bucketlocks[i], <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (b = bcache.buf; b &lt; bcache.buf+NBUF; b++) &#123;</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    b-&gt;next = bcache.buckets[<span class="number">0</span>].next;</span><br><span class="line">    bcache.buckets[<span class="number">0</span>].next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我最开始的实现中，bcache.lock 是用不上的（所以也没跑出正确答案）。但是根据 Hints：</p><p>Your solution might need to hold two locks in some cases; for example, during eviction you may need to hold the bcache lock and a lock per bucket. Make sure you avoid deadlock.</p><p>是需要上两把锁的，具体使用场景到后面再看。</p><p>由于我们现在不需要维护双向链表，在 brelse 的时候直接释放 buf 的 sleep 的 lock，然后再获取对应的 bucket 的 lock，将 refcnt– 即可，如果 refcnt &#x3D;&#x3D; 0，则将当前的 ticks 设置为 buf 的 timestamp。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> key = HASH_DEV_BLOCKNO(b-&gt;dev, b-&gt;blockno);</span><br><span class="line">  acquire(&amp;bcache.bucketlocks[key]);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">    b-&gt;timestamp = ticks;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  release(&amp;bcache.bucketlocks[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的修改 bpin 和 bunpin，这里就不贴出来了。</p><h3 id="bget"><a href="#bget" class="headerlink" title="bget"></a>bget</h3><p>整个 bget 是最折磨的地方，多线程场景下的问题还是太难发现了。</p><p>最开始我没有意识到问题的严重性，按照最初的思路，写了第一版代码，逻辑如下：</p><ol><li>获取 dev 和 blockno 对应的 bucket 的锁；</li><li>如果已经有缓存了就直接返回 buf，否则执行 3；</li><li>在所有的 bucket 中找出一个 refcnt 为 0，并且最近最久未使用的 buf。在这个过程中需要对 bucket 上锁，遍历完一个 bucket 之后，释放它的锁；</li><li>如果找到了这样的 buf，就申请它所在的 bucket 锁并进行 eviction，将它从原本的 bucket 中移除，否则直接 panic；</li><li>将找到的 buf 插入 dev 和 blockno 对应的 bucket 中，并设置 buf 的值；</li><li>释放 dev 和 blockno 对应的 bucket 的锁；</li><li>获取找到的 buf 的 sleeplock；</li><li>返回 buf；</li></ol><p>这样乍一看是没什么问题，但是事实并非如此。</p><p>首先一个容易注意到的点就是，会产生死锁。由于我们在发现没有缓存的时候，并没有释放刚刚获取的 bucket 的锁，然后就开始在所有 bucket 中找一个可以被 evict 的 buf，这时候要获取其它 bucket 的锁。那么如果一个进程 A 持有 bucket1 的锁，又去获取 bucket 2 的锁，但是进程 B 又持有 bucket2 的锁去获取 bucket1 的锁时，就产生了死锁。</p><p>所以在发现我们要找的 buf 并没有在缓存中时，要先释放当前持有的 bucket 的锁，再去进行 eviction。</p><p>第二个问题就是，当我们找到了那个可以被 evict 的 buf 时，将锁释放掉了，正式进行 evict 时，又去申请锁，但是在释放锁到重新申请锁的这个间隙，可能有其它进程又引用了刚刚找出来的那个 buf，使得它的 refcnt 不为 1，这个时候将其 evict 掉就会发生错误。</p><p>解决方案就是，在找出可以 evict 的 buf 后，不释放对应 bucket 的锁，而是直到 evict 之后再释放。那么其它进程在刚开始获取缓存的时候就会阻塞，因为它获取不到这个 bucket 的锁，待到 ecivt 结束后，它才能去查看 bucket，这时候它就看不到那个被 evict 的 buf 了。</p><p>完成以上两个修改之后，bcachetest 已经能够通过了。但是如果执行 usertests，第一个 manywrites 就无法通过，报的错误是 panic: freeing free block，即释放了一个原本已经释放的 block cache。而这种重复释放的原因，肯定就是同一个 block 被缓存了多次。</p><p>下面的思路来自于<a href="https://github.com/Miigon">Miigon</a>。</p><p>假设当前有两个进程同时访问同样缓存块，在第一个进程获取到对应的 bucket 锁后，发现不存在缓存，就释放了锁，进入寻找可 evict 的 buf 阶段。这时，第二个进程同样能够获取对应 bucket 的锁，并同样发现缓存不存在，也进入寻找可 evict 的 buf 阶段。</p><p>这个时候完全有可能发生的是，它们找到了两个不同的 buf，并且将它们 evict 掉之后都插入了它们要找的 block 对应的 bucket 中。这时就出现了同一块 block 有多个 cache 的情况。最后也就会触发 freeing free block。</p><p>这时候前文提到的那个 hint 就要回收了，再看一遍：</p><p>Your solution might need to hold two locks in some cases; for example, during eviction you may need to hold the bcache lock and a lock per bucket. Make sure you avoid deadlock.</p><p>再结合前一条：</p><p>It is OK to serialize eviction in bget (i.e., the part of bget that selects a buffer to re-use when a lookup misses in the cache).</p><p>现在想想其实就是暗示我们在寻找并 evict 可用 buf 的时候将整个流程串行化，保留最开始查看是否有缓存的并行。并且缓存丢失的概率一般来说都是非常低的，所以后面的串行化造成的性能损失其实是可以接受的。</p><p>所以现在利用上 bcache.lock，在发现缓存不存在释放掉对应 bucket 的锁之后，立刻获取 bcache.lock 这把大锁。由于在释放对应 bucket 锁到获取 bcache.lock 期间，可能有别的进程已经完成了对我们要找的 block 设置 cache，所以在获取完 bcache.lock 后，再进行一次查找缓存，如果发现已经存在了，就直接返回对应的 buf。</p><p>这样一来，就算有多个进程同时进入 bget，也只有第一个进程可以获取到 bcache.lock，并完成缓存的设置，后面的进程都会被获取完锁后的第二轮查找缓存给拦住。这样就避免了一个 block 被缓存多次。</p><p>下面是完整的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> key = HASH_DEV_BLOCKNO(dev, blockno);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.bucketlocks[key]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span> (b = bcache.buckets[key].next; b; b = b-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno) &#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;bcache.bucketlocks[key]);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;bcache.bucketlocks[key]);</span><br><span class="line">  <span class="comment">// 一定要先释放再去获取 bcache.lock</span></span><br><span class="line">  <span class="comment">// 否则如果另一个进程持有 bcache.lock，再在下面获取 bucketlocks[key] 就会死锁  </span></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (b = bcache.buckets[key].next; b; b = b-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno) &#123;</span><br><span class="line">      acquire(&amp;bcache.bucketlocks[key]);</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;bcache.bucketlocks[key]);</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached.</span></span><br><span class="line">  <span class="type">int</span> i, bidx = <span class="number">-1</span>, flag = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">tmp</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NBUCKET; i++) &#123;</span><br><span class="line">    acquire(&amp;bcache.bucketlocks[i]);</span><br><span class="line">    <span class="keyword">for</span> (b = &amp;bcache.buckets[i]; b-&gt;next; b = b-&gt;next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (b-&gt;next-&gt;refcnt == <span class="number">0</span> &amp;&amp; (!tmp || b-&gt;next-&gt;timestamp &gt; tmp-&gt;next-&gt;timestamp)) &#123;</span><br><span class="line">          tmp = b;</span><br><span class="line">          flag = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">      release(&amp;bcache.bucketlocks[i]); <span class="comment">// 如果没有找到 buf 就释放锁</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果找到了新 buf，那就释放之前找到的 buf 的 bucket 锁，并保留当前 bucket 的锁</span></span><br><span class="line">      flag = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (bidx != <span class="number">-1</span>) release(&amp;bcache.bucketlocks[bidx]);</span><br><span class="line">      bidx = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">    panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  b = tmp-&gt;next;</span><br><span class="line">  tmp-&gt;next = b-&gt;next;</span><br><span class="line">  release(&amp;bcache.bucketlocks[bidx]); <span class="comment">// 进行 evict 后再释放锁</span></span><br><span class="line">  </span><br><span class="line">  acquire(&amp;bcache.bucketlocks[key]);</span><br><span class="line">  b-&gt;next = bcache.buckets[key].next;</span><br><span class="line">  bcache.buckets[key].next = b;</span><br><span class="line">  b-&gt;dev = dev;</span><br><span class="line">  b-&gt;blockno = blockno;</span><br><span class="line">  b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">  b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">  release(&amp;bcache.bucketlocks[key]);</span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">  acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3a5f446f27d4dd1ac4690c109f64f29~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>多线程场景下的问题真的很难搞，感觉在业务场景下，用一些常见的模式还没有那么难。到系统编程的场景下，这些问题都要自己考虑，解决一个问题之后可能又产生另一个问题，我自己对于这方面的能力还是太弱了。</p><p>引用一下<a href="https://github.com/Miigon">Miigon</a>大佬的总结：</p><blockquote><p>锁竞争优化一般有几个思路：</p><ul><li>只在必须共享的时候共享（对应为将资源从 CPU 共享拆分为每个 CPU 独立）</li><li>必须共享时，尽量减少在关键区中停留的时间（对应“大锁化小锁”，降低锁的粒度）</li></ul></blockquote><p>第一种思路就是本次 lab 的第一部分，只有当前 CPU 的 freelist 已经为空时，才去和其它的 CPU 共享 freelist，其它情况下都是并行执行的。</p><p>第二种思路就是本次 lab 的第二部分，bcache 是没有办法单独划分给每个 CPU 的，属于必须共享，所以只能通过缩小临界区，缩小锁的粒度来实现。</p><p>后续这方面还是得多多加强。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab7: Multithreading</title>
      <link href="/post/9662ca7f.html"/>
      <url>/post/9662ca7f.html</url>
      
        <content type="html"><![CDATA[<p>本次实验要实现用户级线程之间的切换，使用多线程来加速程序，并实现屏障。</p><p>在听课的时候感觉这次实验是要实现内核级线程，让一个进程中的多个线程可以同时运行在多个 CPU 上面，感觉有点害怕。不过看实验说明书的时候才知道是实现的用户级线程，其实应该叫做协程，而且很多代码都已经给出来了，做之前要读一遍 user&#x2F;uthread.c。每个用户线程对应一个内核线程是 Optional chanllenge 部分的任务了，有时间再做吧。这样一来本次的实验还是很简单的。</p><h2 id="Uthread-switching-between-moderate"><a href="#Uthread-switching-between-moderate" class="headerlink" title="Uthread: switching between (moderate)"></a>Uthread: switching between (moderate)</h2><p>这部分是实现用户级线程的切换。在课上教授已经讲过了内核级线程是如何切换的了。大部分内容都可以借鉴。</p><p>在切换线程时，要把当前运行线程的 callee registers 保存下来。</p><p>thread_switch needs to save&#x2F;restore only the callee-save registers.</p><p>我对这里的理解是，用户级线程的切换一定是手动调用 thread_schedule 然后调用 thread_switch 进行切换的。所以对用户级线程来说，恢复现场就是在之前调用 thread_switch 函数后调用 ret 返回到 thread_schedule 函数中，那么由于 C 编译器会在调用函数的时候把 caller registers 保存在线程的栈上，所以我们只需要记下 ra 来定位返回的位置，还有 sp 指出线程栈的位置，并且把所有的 callee register 保存即可（跟内核级线程的切换 Context 是一样的）。</p><p>这部分要做得任务只有两个，在 thread_create 函数中添加代码。要做到线程的切换，我们必须初始化它的 ra 和 sp，这样才可以使得其它线程调用 thread_switch 通过 ret 返回跳到 ra 所在位置执行。在创建的时候设置 ra 和 sp 相当于伪造一个执行现场，返回到那里。</p><p>我选择是直接把寄存器存在 thread 结构体中，这样可以直接把 swtch.S 里的内容复制过来就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">    uint64     ra;</span><br><span class="line">    uint64     sp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// callee saved</span></span><br><span class="line">    uint64     s0;</span><br><span class="line">    uint64     s1;</span><br><span class="line">    uint64     s2;</span><br><span class="line">    uint64     s3;</span><br><span class="line">    uint64     s4;</span><br><span class="line">    uint64     s5;</span><br><span class="line">    uint64     s6;</span><br><span class="line">    uint64     s7;</span><br><span class="line">    uint64     s8;</span><br><span class="line">    uint64     s9;</span><br><span class="line">    uint64     s10;</span><br><span class="line">    uint64     s11;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>       <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/* the thread&#x27;s stack */</span></span><br><span class="line">    <span class="type">int</span>        state;             <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将线程的 ra 初始化为 func 的起始地址，并且设置线程栈。注意栈是从高地址扩展到低地址的，所以初始化的时候应该将指针指向栈的最高地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">thread_create</span><span class="params">(<span class="type">void</span> (*func)())</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  t-&gt;ra = (uint64)func;</span><br><span class="line">  t-&gt;sp = (uint64)t-&gt;<span class="built_in">stack</span> + STACK_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 thread_schedule 调用 thread_switch 就可以了。注意 t 才是当前线程，而 current 是要被调度的线程。</p><h2 id="Using-threads-moderate"><a href="#Using-threads-moderate" class="headerlink" title="Using threads (moderate)"></a>Using threads (moderate)</h2><p>这部分跟 xv6 无关了，就是用 pthread + lock 来控制并发访问一个 hash table。</p><p>先看一下 hash table 的实现。本质上是一个 entry 类型的数组，里面有 NBUCKET 个链表，key 通过摸 NBUCKET 来决定插入到哪个链表的表头。</p><p>所以回答第一个问题：</p><p>Why are there missing keys with 2 threads, but not with 1 thread? Identify a sequence of events with 2 threads that can lead to a key being missing.</p><p>当两个线程同时调用 insert 函数的时候，两个线程看到的链表头都是同一个，那么在插入的时候，后插入的会把先插入的给覆盖掉。</p><p>然后是实现并发控制，其实就是给每个 bucket 都分配一把锁，这样不同的线程在访问不同的 bucket 的时候就可以并发执行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> bucketlocks[NBUCKET]; <span class="comment">// 声明锁</span></span><br></pre></td></tr></table></figure><p>在 main 函数中调用 pthread_mutex_init 进行初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; i++) &#123;</span><br><span class="line">    pthread_mutex_init(&amp;bucketlocks[i], <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 put 中上锁即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = key % NBUCKET;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// is the key already present?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(e)&#123;</span><br><span class="line">    <span class="comment">// update the existing key.</span></span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// the new is new.</span></span><br><span class="line">    pthread_mutex_lock(&amp;bucketlocks[i]);</span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">    pthread_mutex_unlock(&amp;bucketlocks[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Barrier-moderate"><a href="#Barrier-moderate" class="headerlink" title="Barrier (moderate)"></a>Barrier (moderate)</h2><p>这部分要通过 pthread_cond 来实现一个 barrier。关于 barrier 和 waitgroup 的区别：</p><p>屏障是一种同步原语，它会阻止多个线程或 goroutine 的运行，直到它们都到达某个点，在该点它们都被同时释放。 屏障可用于确保仅在所有线程完成其<strong>计算的特定阶段</strong>后才执行某些操作。</p><p>另一方面，WaitGroup 是一种同步原语，用于等待一组 goroutine 完成它们的执行，然后再继续。 WaitGroup 用一个计数初始化，每个 goroutine 在开始工作之前递增计数，并在完成时递减计数。 主线程（或另一个 goroutine）在 WaitGroup 上等待，直到计数达到零，这表明所有 goroutine 都已完成。 这允许主线程与并行任务的完成同步。</p><p>直接实现 barrier 函数即可。需要注意的是 barrier 函数也可能出现竞态。比如说线程 1 进入 barrier，将 bstate.nthread 加 1，然后比较一下还没有达到 nthread，正打算休眠，结果线程 2 进入 barrier，将 bstate.nthread 加 1，比较一下发现已经达到了 nthread，于是执行了一次唤醒操作，接着线程 1 又休眠了，那么线程 1 无法被唤醒，下一轮也就永远无法到达 nthread 了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">barrier</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">  <span class="comment">// then increment bstate.round.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">  bstate.nthread++;</span><br><span class="line">  <span class="keyword">if</span> (bstate.nthread &lt; nthread) &#123;</span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    bstate.nthread = <span class="number">0</span>;</span><br><span class="line">    bstate.round++;</span><br><span class="line">    pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以通过上锁将增加 bstate.nthread++、比较、休眠或唤醒合成一个原子操作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次 lab 由于跟 xv6 相关的部分只有一个，并且跟教授上课讲得内核级线程的切换几乎一样，只是省去了先切换到调度线程这一步，所以实现起来很简单。后续有时间可以回来实现一下内核级线程。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab6: Copy-on-Write Fork for xv6</title>
      <link href="/post/b1b06482.html"/>
      <url>/post/b1b06482.html</url>
      
        <content type="html"><![CDATA[<p>lab6 是实现 COW fork，在 fork 子进程的时候不直接将父进程的物理内存复制给子进程，而是只复制页表，并且把双方 PTE 设置为只读的。在进程需要进行写操作的适合，会触发 page fault，处理 page fault 的时候再复制一份内存，映射给进程，然后把 PTE 重新映射并且修改为可读写。</p><p>COW 能够节约复制的时间，只复制要修改的 page，并且可以很大程度上避免复制完后调用 exec 的浪费。</p><h2 id="Implement-copy-on-write-hard"><a href="#Implement-copy-on-write-hard" class="headerlink" title="Implement copy-on write (hard)"></a>Implement copy-on write (hard)</h2><p>Your task is to implement copy-on-write fork in the xv6 kernel. You are done if your modified kernel executes both the cowtest and usertests programs successfully.</p><p>首先来实现 reasonable plans 中的第三点，修改 kernel&#x2F;kalloc.c。因为实现 COW 之后，就会存在多个进程引用同一个 page 的情况，所以当进程退出，要释放内存的时候不能直接释放，而是要看还有没有别的进程在引用该 page。</p><p>我们需要用一个计数器来记录每个 page 的引用数量，只有当引用数为 0 的时候才能释放。当调用 kernel&#x2F;kalloc.c#kalloc 函数的时候，将这个新分配的 page 的引用计数设置为 1。当调用 kernel&#x2F;kalloc.c#kfree 函数的时候，将需要释放的 page 的引用计数减 1，引用计数为 0 的时候释放物理内存。当执行 fork 系统调用的时候，在复制 page 的映射时，将 page 的引用计数加 1。</p><p>添加以下全局变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... kalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">pincountlock</span>;</span> <span class="comment">// 锁住计数器，防止发生竞态，记得在 kinit 中初始化锁</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pincounts[<span class="number">32768</span>]; <span class="comment">// 每个页的引用计数器</span></span><br></pre></td></tr></table></figure><p>再实现以下函数，用以操作 page 的引用计数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pa 转化成计数器的下标</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pa2pincount</span><span class="params">(uint64 pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (pa - KERNBASE) / PGSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对应 page 的引用计数加 1</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pin</span><span class="params">(uint64 pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  pa = PGROUNDUP(pa);</span><br><span class="line">  acquire(&amp;pincountlock);</span><br><span class="line">  <span class="keyword">if</span> (pincounts[pa2pincount(pa)] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    pincounts[pa2pincount(pa)]++; </span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;pincountlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对应 page 的引用计数减 1</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">unpin</span><span class="params">(uint64 pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  pa = PGROUNDUP(pa);</span><br><span class="line">  acquire(&amp;pincountlock);</span><br><span class="line">  <span class="keyword">if</span> (pincounts[pa2pincount(pa)] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    pincounts[pa2pincount(pa)]--;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;pincountlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 kalloc 和 kfree 函数，加上对引用计数的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  unpin((uint64)pa);</span><br><span class="line">  acquire(&amp;pincountlock);</span><br><span class="line">  <span class="keyword">if</span> (pincounts[pa2pincount((uint64)pa)] != <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;pincountlock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;pincountlock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">    uint64 pa = (uint64) r;</span><br><span class="line">    pincounts[pa2pincount(pa)] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 kernel&#x2F;vm.c#uvmcopy() 函数，让它不实际复制内存，而是复制一下页表，并且把父子进程的 W 位置为 0。并且我们需要在 PTE 中的 flags 中选择一位用作 COW 标识。我这里选择的是 RSW 的低位。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/811e09570d6b4b35a6a5dfaf99d8a508~tplv-k3u1fbpfcp-zoom-1.image"></p><p>我在 riscv.h 中定义了一个宏来方便计算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_COW (1L &lt;&lt; 8)</span></span><br></pre></td></tr></table></figure><p>我直接将 lab3 写过的复制页表的函数复制过来，稍微做了一些修改，然后在原本复制内存的函数中调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> uvmcopypg(old, new, sz, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopypg</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">pagetable_t</span> npagetable, uint64 sz, uint64 start)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = PGROUNDUP(start); i &lt; sz; i+=PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopypg: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopypg: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    *pte &amp;= ~PTE_W; <span class="comment">// 将 W 位置为 0</span></span><br><span class="line">    *pte |= PTE_COW; <span class="comment">// 将 COW 位置为 1</span></span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="keyword">if</span>(mappages(npagetable, i, PGSIZE, pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    pin(pa); <span class="comment">// 映射成功，将这一页的引用计数加 1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  err:</span><br><span class="line">  uvmunmap(npagetable, PGROUNDUP(start), (i - PGROUNDUP(start)) / PGSIZE, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来实现一个 page fault handler 来处理 COW fork page fault，在这个函数中进行一些判断看能否处理这个 page fault，如果不行就返回 -1，否则返回 1，用于在 usertrap 中杀死进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">cowhandler</span><span class="params">(uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint flags; </span><br><span class="line">  va = PGROUNDDOWN(va);</span><br><span class="line">  <span class="keyword">if</span> (va &gt;= MAXVA) &#123; <span class="comment">// 测试 copyout 的时候 walk 中爆了 panic，va 存在大于 MAXVA 的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pte = walk(p-&gt;pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// va 必须在 heap 中，并且对应的 pte 必须存在且有效，同时 COW 位应该是 1</span></span><br><span class="line">  <span class="keyword">if</span> (va &gt;= p-&gt;sz || ((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) == <span class="number">0</span>) || (*pte &amp; PTE_COW) == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  uint64 pa = PTE2PA(*pte); <span class="comment">// 将旧 page 的地址取出用于复制</span></span><br><span class="line">  uint64 ka = (uint64) kalloc();   <span class="comment">// 分配新的 page</span></span><br><span class="line">  <span class="keyword">if</span> (ka == <span class="number">0</span>) &#123; <span class="comment">// hints 中说如果没有内存可以分配了就杀死进程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  memmove((<span class="type">void</span> *)ka, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">  <span class="comment">// 将标识设置为可写，并去掉 COW 标识</span></span><br><span class="line">  flags = PTE_FLAGS(*pte);</span><br><span class="line">  flags &amp;= ~PTE_COW;</span><br><span class="line">  flags |= PTE_W;</span><br><span class="line">  uvmunmap(p-&gt;pagetable, va, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 在取消映射时会调用 kfree，这里不用调用 unpin</span></span><br><span class="line">  <span class="keyword">if</span> (mappages(p-&gt;pagetable, va, PGSIZE, ka, flags)) &#123;</span><br><span class="line">    kfree((<span class="type">void</span> *) ka);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟 lazy allocation 一样，需要在 usertrap 中调用 page fault handler 来处理 page fault。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ... usertrap</span></span><br><span class="line">  intr_on();</span><br><span class="line"></span><br><span class="line">  syscall();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) &#123;</span><br><span class="line">  uint64 va = r_stval();</span><br><span class="line">  <span class="keyword">if</span> (cowhandler(va) == <span class="number">-1</span>) &#123; <span class="comment">// 调用 cowhandler 返回值为 -1 就杀死进程</span></span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">  p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后只需要在 copyout 中调用 cowhandler 函数来处理 dstva 指向的是 on-demand page 的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    cowhandler(dstva);</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>lab6 只有一个部分，任务指导书也讲得非常清楚，实现起来不是很难。我在做得时候由于一开始没有对 pincount 上锁，导致发生竞态卡了不少时间。</p><p>到这个 lab 应该就是虚拟内存系列 lab 的最后一个了，感觉还是 lab3 是最为困难的，在写完 lab3 之后对整个 xv6 就会有一定的理解了，对操作虚拟内存也会更加熟悉，做后面这几个就没有那么困难了。</p><p>对于 page table、traps、page fault 有了较为深入的理解，收获很大。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab5: xv6 lazy page allocation</title>
      <link href="/post/32a9d8d3.html"/>
      <url>/post/32a9d8d3.html</url>
      
        <content type="html"><![CDATA[<p>xv6 中 sbrk 的实现默认是 eager allocation，也就是一旦用户进程申请了内存，那么内核马上就会分配。但实际上，用户进程难以估量自己需要多少内存，所以往往会额外申请，导致内存消耗增加，并且有部分内存永远不会被用到。</p><p>所以可以用 lazy page allocation 来解决这个问题，sbrk 只用来记住分配了哪些用户地址（即更新 sz），而不先分配内存，直到产生了 page fault 再分配内存。</p><h2 id="Lazytests-and-Usertests"><a href="#Lazytests-and-Usertests" class="headerlink" title="Lazytests and Usertests"></a>Lazytests and Usertests</h2><p>partⅠ和 partⅡ 的话，Frans 教授在课上讲过了，这里就不重复了。partⅢ 就是实现 Frans 教授说的要对 xv6 做进一步的修改，这些修改都已经写在 Hints 中了：</p><ol><li>处理 sbrk 的参数为负数的情况；</li><li>如果发生 page fault 的地址比 sbrk 分配的地址还大的时候，杀死进程；</li><li>处理用户进程通过系统调用传递了一个正确的地址，但是这个地址还没有被分配内存的情况（即修改copyin 和 copyout 等函数）。</li><li>如果发生 page fault 后没有可用内存了，杀死进程；</li><li>如果发生 page fault 的地址访问到了 guard page，杀死进程。</li></ol><p>第一个要修改的地方在 kernel&#x2F;sysproc.c#sys_sbrk 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    myproc()-&gt;sz = myproc()-&gt;sz + n; <span class="comment">// just add sz, but not allocate memory.</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    myproc()-&gt;sz = uvmdealloc(myproc()-&gt;pagetable, myproc()-&gt;sz, myproc()-&gt;sz + n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前两个部分中，我们在 kernel&#x2F;trap.c#usertrap 中添加了代码，那么对它进行进一步的修改，添加了一个 pgfhandler 函数，用来处理指定虚拟地址发生的 page fault：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="comment">// ok</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">15</span> || r_scause() == <span class="number">13</span>) &#123;</span><br><span class="line">  <span class="comment">// load page fault or store page fault</span></span><br><span class="line">  uint64 va = r_stval(); <span class="comment">// va is the address that cause the page fault</span></span><br><span class="line">  <span class="keyword">if</span> (pgfhandler(va) == <span class="number">-1</span>) &#123; <span class="comment">// if can&#x27;t handle the page fault, kill the process</span></span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">  p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中，我们判断是否能够进行 page fault handle，如果不行就杀死这个进程。做了以下判断：</p><ol><li>该虚拟地址是否在堆中；</li><li>该虚拟地址是否访问到了 guard page；</li><li>是否还有物理内存可以分配；</li><li>新分配的页是否已经映射了，防止报 remap。</li></ol><p>如果可以处理，那么就进行处理，否则返回 0，在 usertrap 中将 p-&gt;killed 标识为 1（如果在这里面标识为 1 的话会杀死初始进程）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pgfhandler</span><span class="params">(uint64 va)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span> (va &gt;= p-&gt;sz || PGROUNDUP(va) == p-&gt;kstack) &#123;</span><br><span class="line">    <span class="comment">// if va is a invalid address, kill the process.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    uint64 ka = (uint64) kalloc();</span><br><span class="line">    <span class="keyword">if</span> (ka == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// if there is no memory can use, kill the process.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">memset</span>((<span class="type">void</span> *) ka, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      va = PGROUNDDOWN(va);</span><br><span class="line">      <span class="type">pte_t</span> * pte;</span><br><span class="line">      <span class="comment">// avoid remap panic.</span></span><br><span class="line">      <span class="keyword">if</span> ((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) != <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_V) != <span class="number">0</span>) &#123;</span><br><span class="line">        kfree((<span class="type">void</span> *) ka);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// map new page above.</span></span><br><span class="line">      <span class="keyword">if</span>(mappages(p-&gt;pagetable, va, PGSIZE, ka, PTE_W|PTE_U|PTE_R) != <span class="number">0</span>) &#123;</span><br><span class="line">        kfree((<span class="type">void</span> *) ka);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意要把 kernel&#x2F;vm.c#uvmunmap 和 kernel&#x2F;vm.c&#x2F;uvmcopy 函数中的 panic 去掉，直接 continue 即可，因为使用了 lazy allocation 之后，在 unmap 的时候会出现 walk 不出来或者本来就没有 map 的情况，不能 panic，在 uvmcopy 的时候也会出现 walk 不出来，或者复制到了一个无效的 pte。代码就不贴出来了。</p><p>最后一步，修改 kernel&#x2F;vm.c#copyin, kernel&#x2F;vm.c#copyinstr, kernel&#x2F;vm.c#copyout，将需要访问的用户空间地址做一个预处理，也就是调用 pgfhandler 先进行一波缺页处理，否则这些函数可能访问到没有分配的内存。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次 lab 相对简单，尤其是 Frans 教授上课已经把前两部分讲了，也很详细的讲了 page fault 是如何处理的。就是有一些细节要注意，我最开始就没想到要处理 copyin 和 copyout。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab4: Traps</title>
      <link href="/post/282c8539.html"/>
      <url>/post/282c8539.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>This lab explores how system calls are implemented using traps. You will first do a warm-up exercises with stacks and then you will implement an example of user-level trap handling.</p></blockquote><p>lab4 相对 lab3 要简单很多，需要写的代码行数不多，并且给的 hints 也很直接。只要听了 lecture 5 和 lecture 6 都能够明白其中的原理。这两次课分别讲了 xv6 的栈结构跟 trap 的一些细节。</p><h2 id="RISC-V-assembly-easy"><a href="#RISC-V-assembly-easy" class="headerlink" title="RISC-V assembly (easy)"></a>RISC-V assembly (easy)</h2><p>就是去看 user&#x2F;call.c 和 user&#x2F;call.asm 中的函数 g, f, main，然后回答一些问题。我没有看 RISC-V 的手册，太长了有点不好搜索。有不懂的指令去 Google 一下反而还方便一点。这边就直接贴出答案了，第三题的答案可能会不一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Q: Which registers contain arguments to functions? For example, which register holds 13  in main&#x27;s call to printf?</span><br><span class="line">A: a0-a7. a2.</span><br><span class="line"></span><br><span class="line">Q: Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)</span><br><span class="line">A: Function f and g are inlined by the compiler.</span><br><span class="line"></span><br><span class="line">Q: At what address is the function printf located?</span><br><span class="line">A: 0x630.</span><br><span class="line"></span><br><span class="line">Q: What value is in the register ra just after the jalr to printf in main?</span><br><span class="line">A: 0x38.</span><br><span class="line"></span><br><span class="line">Q: ...</span><br><span class="line">A: Set i to 0x726c6400. Do not need to modify 57616, because it&#x27;s decimal value is just  110. Little- or big-endian is no matter with values.</span><br><span class="line"></span><br><span class="line">Q: ...</span><br><span class="line">A: It will read the value set in register a2 by the previous function.</span><br></pre></td></tr></table></figure><h2 id="Backtrace-moderate"><a href="#Backtrace-moderate" class="headerlink" title="Backtrace (moderate)"></a>Backtrace (moderate)</h2><p>这部分是实现一个类似于 gdb 的 backtrace，打印函数调用栈帧中的返回地址。在 kernel&#x2F;printf.c 中添加一个 backtrace() 函数，然后在 sys_sleep 中调用 进行测试。</p><p>要实现 backtrace 首先要理解 xv6 的函数栈帧结构，根据老师上课的 ppt：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a608d22b3c5e44a19680ade600fcf85d~tplv-k3u1fbpfcp-zoom-1.image"></p><p>可以看到，函数栈帧之间其实就像一个链表，被 fp 指针给连接到一起，所以我们只需要拿到当前函数的 fp，就可以一直遍历整个函数调用链。当前的 fp 被存放在 s0 寄存器中。在 kernel&#x2F;risv.h 中添加以下函数来取出 s0 中的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_fp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在栈中，函数的返回地址固定在 fp - 8 的位置，调用该函数的函数的 fp 在 fp - 16 的位置。我们一直遍历到这一页结束就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 fp, ra, last;</span><br><span class="line">  fp = r_fp();</span><br><span class="line">  last = PGROUNDUP(fp);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    ra = fp<span class="number">-8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *((uint64 *)(ra)));</span><br><span class="line">    fp = *((uint64 *)(fp<span class="number">-16</span>));</span><br><span class="line">    <span class="keyword">if</span> (fp == last) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Alarm-hard"><a href="#Alarm-hard" class="headerlink" title="Alarm (hard)"></a>Alarm (hard)</h2><p>这部分就是有难度的地方了。要实现一个用户级的中断，用户程序通过调用 sigalarm(interval, handler) 系统调用来设置一个计时器，每隔 interval 个 tick，就调用 handler 函数进行处理。并且在 handler 函数返回之后，会调用 sigreturn() 函数，被中断的用户程序要正常恢复执行，也就是说对于被中断的用户程序来说 alarm handler是透明的。</p><p>每次在收到 timer 硬件发出的中断时，就是一个 tick，它不是一个确定的时间单位。而 timer interrupt 会触发 trap，所以可以知道 alarm handler 是要在 trap 中触发的，类似于在 trap 中又套了一层 trap。</p><p>我们需要在 struct proc 结构体中添加一些新的属性来保存触发 handler 的间隔，handler 函数指针，距离上次调用 handler 过去了几个 tick，当前是否有 handler 在执行，以及一个 struct trapframe 用来保存被打断的程序的寄存器值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... struct proc</span></span><br><span class="line"><span class="type">int</span> ticks;                   <span class="comment">// Alarm ticks</span></span><br><span class="line"><span class="type">void</span> (*handler)();           <span class="comment">// Alarm handler</span></span><br><span class="line"><span class="type">int</span> passedticks;             <span class="comment">// Record how many ticks passed</span></span><br><span class="line"><span class="type">int</span> isrunninghandler;        <span class="comment">// Avoid re-entrant calls to a handler</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">savedtf</span>;</span>   <span class="comment">// Save trapframe when call handler</span></span><br></pre></td></tr></table></figure><p>ticks、handler、passedticks 在 sigalarm 系统调用中设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="type">int</span> ticks;</span><br><span class="line">  uint64 handler;</span><br><span class="line">  <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;ticks) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">1</span>, &amp;handler) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  p-&gt;ticks = ticks;</span><br><span class="line">  p-&gt;handler = (<span class="type">void</span> (*)()) handler;</span><br><span class="line">  p-&gt;passedticks = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在 kernel&#x2F;trap.c#usertrap 中处理 timer interrupt。当 which_dev &#x3D; 2 的时候，表明是 timer interrupt。</p><p>由于执行完 handler 之后，需要回到被中断的程序继续执行，所以在这里要将这个程序的状态保存下来，在 sigreturn 系统调用中恢复。我这里图方便就直接将所有的寄存器和状态都保存下来了。保存完状态后，<strong>将 p-&gt;trapframe-&gt;epc 的值设置为 handler 的地址</strong>。usertrap 会调用 usertrapret，usertrapret 会将 p-&gt;trapframe-&gt;epc 设置到 spec 寄存器中，userret 在返回时调用 sret 指令会将 sepc 寄存器中的值设置到 pc 中，所以用户程序就会跳到 handler 中去执行了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// ok</span><br><span class="line">if (which_dev == 2 &amp;&amp; p-&gt;ticks != 0) &#123;</span><br><span class="line">  p-&gt;passedticks++;</span><br><span class="line">  // if there is no handler running and it&#x27;s time to call handler</span><br><span class="line">  if (p-&gt;passedticks == p-&gt;ticks &amp;&amp; p-&gt;isrunninghandler == 0) &#123;</span><br><span class="line">    p-&gt;isrunninghandler = 1;</span><br><span class="line">    // save trapframe</span><br><span class="line">    memmove(p-&gt;savedtf, p-&gt;trapframe, sizeof(struct trapframe));</span><br><span class="line">    p-&gt;trapframe-&gt;epc = (uint64) p-&gt;handler;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 handler 程序执行完后，在测试中就是 periodic 函数，其中会调用 sigreturn，在这里面回复原来的函数的执行。</p><p>首先将 passedticks 重置，以便下一轮触发，然后将 isrunninghandler 置 0，表示没有在执行的 handler，然后将保存在 savedfp 中的寄存器值都重新写入 trapframe 中，接着调用 usertrapret 将寄存器的值都恢复，就像从 trap 中恢复出来一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  p-&gt;passedticks = <span class="number">0</span>;</span><br><span class="line">  p-&gt;isrunninghandler = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// Restore trapframe</span></span><br><span class="line">  memmove(p-&gt;trapframe, p-&gt;savedtf, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">  <span class="comment">// Restore registers when usertrapret calls userret, and userret calls sret to back to the interrupted code.</span></span><br><span class="line">  usertrapret();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次的 lab 其实就像老师喂饼一样，看过 lecture5&#x2F;6 之后，再把 xv6 book Chapter4 看完，其中的原理肯定会明白，然后就是一些小细节可能会为难一点（C 语言不太好的甚至会被语法为难😭），其它难点不多，但是确实对 trap 有深入的理解。Robert 我的神！</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab3: Page Table</title>
      <link href="/post/b51235b3.html"/>
      <url>/post/b51235b3.html</url>
      
        <content type="html"><![CDATA[<p>lab3 属实是重量级，折磨了我好长时间。做 lab3 之前一定一定一定要先仔细的看 <a href="https://pdos.csail.mit.edu/6.S081/2020/xv6/book-riscv-rev1.pdf">xv6 book</a> 和<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/pgtbl.html">任务指导书</a>，不然就是无头苍蝇乱碰了。</p><p>同时还有 kernel&#x2F;memlayout.h、kernel&#x2F;vm.c、kernel&#x2F;kalloc.c 都需要认真看看相关代码。</p><p>Lab3 就是要给每一个进程都添加一个自己的内核页表，并且把用户页表中的映射给复制进去，在进程进入内核态之后，可以使用进程中的内核页表，通过硬件来进行寻址。在实现这个 lab 之前，xv6 只能从用户态传入一个地址，但是这个地址在内核中是无法使用的，因为内核页表中没有这个映射，所以只能通过软件模拟 MMU 来进行寻址，效率不高。</p><h2 id="Print-a-page-table-easy"><a href="#Print-a-page-table-easy" class="headerlink" title="Print a page table (easy)"></a>Print a page table (easy)</h2><p>任务书上说是可以帮助后面的 debug，但是我没有用到。不过可以做到对于 xv6 的页表有一个初步的认识。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33074b82b5b04df996bdf0c4f9f0aed6~tplv-k3u1fbpfcp-zoom-1.image"></p><p>xv6 的页表如上图所示。在 CPU 的 satp 寄存器中存储了第二层页表的物理地址，它里面存储了 512 条 PTE（page table entry），每条 PTE 的高 44 位 PPN 用于计算出下一层页表的物理地址或者拼接出存储数据的物理地址。一条虚拟地址被分成了 L2、L1、L0 各 9 bit，对应着三层页表，分别指出三层页表中的 PTE。还有 offset，占 12 bit，用于和第 0 层的 PPN 拼接得到数据的物理地址。</p><p>所以要打印这个页表，我们就要从第二层开始，逐层遍历 PTE 并打印，然后取出下一层的页表开始遍历打印，直到最低层。</p><p>pagetable_t 其实就是一个 uint64 类型的指针，其实也就是一个数组，数组中有 512 个元素对应 512 条 PTE，进行遍历的过程中要判断 PTE 是否有效，无效就不打印，还要判断 PTE 是否指向下一层的页表，如果是就将 PTE 转化成下一层页表的物理地址，递归到下一层进行打印，否则就直接打印。根据任务指导书，具体如何判断 PTE 参考 kernel&#x2F;vm.c#freewalk 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_vmprint(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level) &#123;</span><br><span class="line">  <span class="keyword">if</span> (level == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> (pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="keyword">if</span> (level != <span class="number">0</span> &amp;&amp; !((pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="number">0</span>)) <span class="keyword">continue</span>;</span><br><span class="line">      uint64 pa = PTE2PA(pte);</span><br><span class="line">      <span class="type">int</span> j;</span><br><span class="line">      <span class="keyword">for</span> (j = level; j &lt;= <span class="number">2</span>; j++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">2</span>) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;.. &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, pa);</span><br><span class="line">      _vmprint((<span class="type">pagetable_t</span>) pa, level<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  _vmprint(pagetable, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="A-kernel-pagetable-per-process-hard"><a href="#A-kernel-pagetable-per-process-hard" class="headerlink" title="A kernel pagetable per process (hard)"></a>A kernel pagetable per process (hard)</h2><p>xv6 中，每个进程都有一个自己的用户空间页表，这个页表只包含该进程的用户地址空间的映射。在内核中有一个单独的内核页表，所有的进程进入内核态后，都是用的是这个内核页表。<strong>所以用户地址在内核中是无法使用的，因为内核页表中没有对该地址的映射</strong>，<strong>只能通过 walk 来模拟 MMU 将用户虚拟地址再转化为物理地址使用。</strong></p><p>所以部分的任务就是给每个进程都弄一个自己的内核页表，并且在下个部分将用户空间页表中的映射复制到自己的内核页表中，这样在进入内核态的时候就可以直接使用这些映射了。</p><p>首先，我们在 strcut proc 中添加一个 kpagetable 变量来存储内核页表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pagetable_t</span> kpagetable;      <span class="comment">// Process&#x27;s kernel pagetable</span></span><br></pre></td></tr></table></figure><p>我们需要在创建进程的时候给他复制一份内核页表，内核页表是通过 kernel&#x2F;vm.c#kvminit 初始化，在其中使用 kernel&#x2F;vm.c#kvmmap 进行一些映射，我们需要修改版的 kvminit 函数和 kvmmap 函数来对进程的内核页表进行修改。因为这两个函数只是针对全局的 kernel_pagetable，没办法传参数。照着写就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ukvmmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;ukvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_kpagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line">  pagetable = uvmcreate();</span><br><span class="line">  <span class="keyword">if</span> (pagetable == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  ukvmmap(pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  ukvmmap(pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CLINT</span></span><br><span class="line">  ukvmmap(pagetable, CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  ukvmmap(pagetable, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  ukvmmap(pagetable, KERNBASE, KERNBASE, (uint64) etext - KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  ukvmmap(pagetable, (uint64) etext, (uint64) etext, PHYSTOP - (uint64) etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  ukvmmap(pagetable, TRAMPOLINE, (uint64) trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在 kernel&#x2F;proc.c#allocproc 中调用上述函数来初始化进程的内核页表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... kernel/proc.c#allocproc</span></span><br><span class="line">p-&gt;kpagetable = proc_kpagetable(p);</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;kpagetable == <span class="number">0</span>) &#123;</span><br><span class="line">  freeproc(p);</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照任务说明书，我们需要将进程的内核栈映射到内核页表中，原本内核栈的初始化是在 kernel&#x2F;proc.c#procinit 中，现在我们将内核栈放在 allocproc 中来分配，就跟在内核页表初始化之后。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... kernel/proc.c#allocproc</span></span><br><span class="line"><span class="type">char</span> *pa = kalloc();</span><br><span class="line"><span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">  panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">uint64 va = KSTACK((<span class="type">int</span>) (p - proc));</span><br><span class="line">ukvmmap(p-&gt;kpagetable, va, (uint64) pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">p-&gt;kstack = va;</span><br></pre></td></tr></table></figure><p>到这里内核页表就初始化完成了。接下来修改 kernel&#x2F;proc.c#scheduler 函数，因为当前每个进程有了自己的内核页表，那么在进入内核态之后就要使用自己的页表，也就是将第二层页表的物理地址放入 satp 寄存器中，<strong>在进程执行完之后一定要把全局的内核页表再设置回去</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... kernel/proc.c#scheduler</span></span><br><span class="line">p-&gt;state = RUNNING;</span><br><span class="line">c-&gt;proc = p;</span><br><span class="line">w_satp(MAKE_SATP(p-&gt;kpagetable));</span><br><span class="line">sfence_vma(); <span class="comment">// 使用 vma 指令清除 TLB 缓存，否则可能访问到其他进程的数据！</span></span><br><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line">kvminithart(); <span class="comment">// 在切换完毕之后使用 kvminithart 将全局内核页表设置会 satp</span></span><br></pre></td></tr></table></figure><p>接下来就是释放页表空间了，这一部分也卡了我很久。在 kernel&#x2F;proc.c#freeproc 中是释放进程的逻辑，我们要在这里面添加释放进程的内核页表的逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;kpagetable)</span><br><span class="line">  proc_freekpagetable(p, p-&gt;sz);</span><br><span class="line">p-&gt;kpagetable = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>proc_freekpagetable 函数的实现主要干了两件事，第一是释放掉进程的内核栈，第二是取消了进程的内核页表中的映射，但是<strong>一定不能释放映射指向的物理地址</strong>！因为进程的内核页表仅仅只是复制了映射。我们只释放页表本身的空间。</p><p>仿照 freewalk 实现了 proc_freekpagetable 函数，只释放掉页表页，而不释放最低层 PTE 指向的物理内存，具体做法是判断 PTE 是否还是指向下一层页表，如果是才进到下一层释放，这样就不会进到数据页中去释放内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freekpagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> ((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>) &#123; <span class="comment">// 判断是否还有下一层</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      freekpagetable((<span class="type">pagetable_t</span>) child);</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*) pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里 usertests 测试就可以通过了。</p><h2 id="Simplify-copyin-x2F-copyinstr-hard"><a href="#Simplify-copyin-x2F-copyinstr-hard" class="headerlink" title="Simplify copyin&#x2F;copyinstr (hard)"></a>Simplify copyin&#x2F;copyinstr (hard)</h2><p>这部分就是在刚刚给进程添加的内核页表中添加用户地址空间的映射。那么在内核中就可以直接使用用户空间地址，使用硬件 MMU 进行寻址，相比于用软件模拟 MMU 寻址效率更高。目标就是将 kernel&#x2F;vm.c#copyin 和 kernel&#x2F;vm.c#copyinstr 分别替换成 kernel&#x2F;vmcopyin.c#copyin_new 和 kernel&#x2F;vmcopyin.c#copyinstr_new。所以我们要在修改用户页表的每一处也对进程的内核页表都进行同步才能做到这一点。</p><p>首先仿照 kernel&#x2F;vm.c#uvmcopy 实现 kernel&#x2F;vm.c#uvmcopypg 用以拷贝页表，因为 uvmcopy 是在 fork 的时候把父进程的内存拷贝给子进程，所以它新分配了物理内存给子进程，所以我们不能直接用，因为<strong>内核页表仅仅只是拷贝映射</strong>，而拷贝映射的空间在 allocproc 时就已经分配了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopypg</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">pagetable_t</span> kpagetable, uint64 sz, uint64 start)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = PGROUNDUP(start); i &lt; sz; i+=PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopypg: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopypg: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte) &amp; ~PTE_U; <span class="comment">// 一定要设置 U 标识符，否则内核无法访问这个 PTE</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mappages(kpagetable, i, PGSIZE, pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  err:</span><br><span class="line">  uvmunmap(kpagetable, PGROUNDUP(start), (i - PGROUNDUP(start)) / PGSIZE, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来按照提示，分别在 kernel&#x2F;proc.c#userinit、kernel&#x2F;proc.c#fork、kernel&#x2F;exec.c#exec、kernel&#x2F;proc.c#growproc 中添加同步内核页表的代码。</p><p><strong>userinit</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 在进程页表初始化完成之后拷贝页表</span></span><br><span class="line"><span class="comment">// copy pagetable&#x27;s mappings to kpagetable, but don&#x27;t copy pa.</span></span><br><span class="line"><span class="keyword">if</span> (uvmcopypg(p-&gt;pagetable, p-&gt;kpagetable, p-&gt;sz, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  panic(<span class="string">&quot;uvmcopypg: fail to copy pagetable to kpagetable!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fork</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 在子进程拷贝完父进程的用户页表后，再将子进程的用户页表拷贝给内核页表</span></span><br><span class="line"><span class="keyword">if</span>(uvmcopypg(np-&gt;pagetable, np-&gt;kpagetable, p-&gt;sz, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  freeproc(np);</span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exec</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在成功生成 user image 后，先清除原本的内核页表，再将新的用户页表拷贝到内核页表</span></span><br><span class="line">uvmunmap(p-&gt;kpagetable, <span class="number">0</span>, PGROUNDUP(oldsz) / PGSIZE, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (uvmcopypg(pagetable, p-&gt;kpagetable, sz, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">goto</span> bad;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Commit to the user image.</span></span><br><span class="line">oldpagetable = p-&gt;pagetable;</span><br><span class="line">p-&gt;pagetable = pagetable;</span><br></pre></td></tr></table></figure><p><strong>growproc</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在进程空间扩容并且进程用户页表扩容之后，将扩容的那部分数据拷贝到内核页表</span></span><br><span class="line">    <span class="keyword">if</span> (uvmcopypg(p-&gt;pagetable, p-&gt;kpagetable, sz, sz-n)&lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果拷贝失败了，那么进程就要缩回到原本的容量</span></span><br><span class="line">      sz = uvmdealloc(p-&gt;pagetable, sz, sz-n);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">    <span class="comment">// 在进程空间缩小后并且进程页表页表也缩小之后，将缩小的那部分映射给去掉</span></span><br><span class="line">    <span class="type">int</span> npages = (PGROUNDUP(sz-n) - PGROUNDUP(sz)) / PGSIZE;</span><br><span class="line">    uvmunmap(p-&gt;kpagetable, PGROUNDUP(sz), npages, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于操作系统最低的虚拟地址在 0xC000000，也就是 PLIC 寄存器的地址，如果用户地址空间范围到了 0xC000000 之上，那么就会覆盖掉内核的数据。我们要限制用户地址空间不能超过这个地址。所以我们在 growproc 中判断，如果新的 sz 大于等于 PLIC 了，那么就直接返回 -1 而不执行扩容。</p><p>最后就是一个很大的坑，也就是上述全部实现之后会报 remap 的错误，返回去看 xv6 book 之后才发现，在 PLIC 之下还有一段数据是 CLINT，所以如果映射到了这一段，而这里是我们在初始化内核页表的时候就进行映射了的，所以会报 remap 错误。</p><p>查看 start.c 后发现 CLINT 仅在内核启动的时候需要，也就是说用户进程在内核中并不需要使用到这一段，所以干脆直接在初始化内核页表的时候不进行这部分的映射了。</p><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/170f9ee70f9e4ff59711e06f0c10a916~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个 lab3 确实难度不低，首先要对 xv6 的页表机制有一个比较深入的理解，然后 DEBUG 也比较难，我除了用 gdb 调试之外，还用了很多 panic 来尽早的发现是在哪里错了。如果不仔细读 xv6 book 把他理解清除的话大抵是做不出来了吧。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab2: System Calls</title>
      <link href="/post/ef0d189.html"/>
      <url>/post/ef0d189.html</url>
      
        <content type="html"><![CDATA[<p>这个 lab 是让我们在 xv6 中添加两个新的系统调用，来熟悉系统调用是怎么工作的，还有阅读内核代码，后续的 lab 中会添加更多的系统调用。</p><h2 id="System-call-tracing-moderate"><a href="#System-call-tracing-moderate" class="headerlink" title="System call tracing (moderate)"></a>System call tracing (moderate)</h2><p>trace 系统调用用于追踪程序执行的过程中的系统调用。trace 的使用方法是 trace + mask + 用户程序及参数，比如：</p><p>控制台输入 trace 32 grep hello README，就会出现以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ trace 32 grep hello README</span><br><span class="line">3: syscall read -&gt; 1023</span><br><span class="line">3: syscall read -&gt; 966</span><br><span class="line">3: syscall read -&gt; 70</span><br><span class="line">3: syscall read -&gt; 0</span><br></pre></td></tr></table></figure><p>为什么只 trace 了 read 呢？是因为参数 mask 为 32，二进制为 100000，从 0 开始第 5 位为 1，对应着read 系统调用号 5，所以 mask 用 bitmap 的方式来标识要追踪哪些系统调用。</p><p>根据任务提示，在 user&#x2F;user.h 中添加系统调用的 prototype，在 user&#x2F;usys.pl 中添加 stub，在 kernel&#x2F;syscall.h 中添加新的 syscall number，仿照原有的系统调用来写即可。</p><p>接下来是 trace 的实现逻辑，其实就是在进程的数据结构 struct proc 中添加一个新的成员变量 trace_mask 来记录要对哪些系统调用进行 trace。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="type">int</span> trace_mask;              <span class="comment">// To remember trace mask</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统调用的入口处在 kernel&#x2F;syscall.c#syscall 函数中，在这里根据寄存器 a7 中存储的系统调用号，从 syscalls 数组中取出对应的系统调用进行执行，所以我们要在上面的声明中加入我们在 sysproc.c 中新实现的 sys_trace 函数。其实它干的事情就仅仅是在进程中设置 trace_mask 而已。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    myproc()-&gt;trace_mask = mask;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 syscalls 取出一个系统调用函数并执行完毕后，我们就可以通过存储在 proc 中的 trace_mask 来判断这个系统调用是否需要进行 trace 了，也就是判断 trace_mask 中这个系统调用号这一位是不是 1。如果是的话就按照 lab 的格式需要打印 trace 信息。我们需要一个数组来存储系统调用号和系统调用名的对应关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="type">int</span> pid = p-&gt;pid;</span><br><span class="line">    <span class="type">int</span> trace_mask = p-&gt;trace_mask;</span><br><span class="line">    <span class="keyword">if</span> (trace_mask != <span class="number">0</span> &amp;&amp; ((trace_mask &gt;&gt; (num)) &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %s -&gt; %d\n&quot;</span>, pid, syscall_name[num<span class="number">-1</span>],p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要 trace 的系统调用使用了 fork 创建了子进程，我们也需要能够 trace 子进程进行的系统调用，所以要在 kernel&#x2F;proc.c#fork 中将 trace_mask 复制给子进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np-&gt;trace_mask = p-&gt;trace_mask;</span><br></pre></td></tr></table></figure><p>trace 的用户程序，xv6 中已经给出，接下来只要将 $U&#x2F;_trace 添加到 Makefile 中就可以运行了。</p><h2 id="Sysinfo-moderate"><a href="#Sysinfo-moderate" class="headerlink" title="Sysinfo (moderate)"></a>Sysinfo (moderate)</h2><p>sysinfo 系统调用用于打印剩余的内存还有多少和打印当前有多少进程处于运行状态，它接受一个 struct sysinfo 结构体参数，然后内核会将信息填入到这个参数中。</p><p>添加 prototype、stub、syscall number、系统调用声明这里就省略了，和上面的操作是一样的。重点说一下 kernel&#x2F;sysproc.c#sys_sysinfo 函数的实现。</p><p>想要获得有多少空余的内存，需要在 kernel&#x2F;kalloc.c 中添加函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">free_mem_size</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    r = kmem.freelist;</span><br><span class="line">    <span class="type">int</span> page_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r) &#123;</span><br><span class="line">        page_num++;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">    <span class="keyword">return</span> page_num * PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 kmem 结构体中存储了一个 freelist 来记录空闲的页数，freelist 中每一个节点都是一个 run 结构体的指针，所以遍历 freelist 并统计剩余的空闲页数即可。</p><p>想要获取有多少进程正在运行，需要在 kernel&#x2F;proc.c 中添加函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">used_proc_num</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">    uint64 proc_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p -&gt; state != UNUSED) &#123;</span><br><span class="line">            proc_num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程都被保存在 proc 数组中，遍历这个数组并判断进程状态再统计数量即可。</p><p>然后我们在 kernel&#x2F;sysproc.c#sys_sysinfo 中调用这两个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    uint64 fm = free_mem_size();</span><br><span class="line">    uint64 np = used_proc_num();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span> =</span> &#123;</span><br><span class="line">        fm,np</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    uint64 addr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;info, <span class="keyword">sizeof</span>(info)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据提示，参考 kernel&#x2F;sysfile.c#sys_fstat 和 kernel&#x2F;file.c#filestat 是如何使用 copyout 来讲数据拷贝回用户空间的。</p><p>最后把 $U&#x2F;_sysinfotest 加入到 Makefile 的 UPROGS 中即可运行。</p><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a739fc6c9d6e4c8d9ceb9f4ee3e922ad~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个 lab 乍一看比较难，但是把整个相关的源码看过一遍之后就还好了，第一个 trace 系统调用，将在进程中保存 trace_mask 和系统调用入口是怎么调用系统调用的关联起来其实就知道怎么实现了。第二个也是阅读 kalloc.c 和 proc.c 的相关代码，就知道怎么操作 kmem 和 proc 了。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab1: Xv6 and Unix utilities</title>
      <link href="/post/f71bd04b.html"/>
      <url>/post/f71bd04b.html</url>
      
        <content type="html"><![CDATA[<p>这个 lab 是用来熟悉 xv6 和它的系统调用的，就是用它的系统调用来实现一些小工具。在实现之后要将程序加入 Makefile 里的 UPROGS 中才能执行。</p><h2 id="sleep-eazy"><a href="#sleep-eazy" class="headerlink" title="sleep (eazy)"></a>sleep (eazy)</h2><p>就是调用已经实现的系统调用 sleep （具体实现在 sysproc.c#sys_sleep 中 ） 来实现即可，非常简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有指定参数提示错误信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;must enter a sleep time!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> time = atoi(argv[<span class="number">0</span>]); <span class="comment">// 使用工具函数 atoi 将字符串转化成数字</span></span><br><span class="line">  sleep(time); <span class="comment">// 调用系统调用</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pingpong-eazy"><a href="#pingpong-eazy" class="headerlink" title="pingpong (eazy)"></a>pingpong (eazy)</h2><p>使用 pipe 系统调用创建管道，用 fork 系统调用创建子进程，然后两个进程使用这个管道进行通信，使用 read&#x2F;write 系统调用对 pipe 进行读写即可；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 创建两个管道</span></span><br><span class="line">  <span class="type">int</span> send[<span class="number">2</span>], recv[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">if</span> (pipe(send) &lt; <span class="number">0</span> || pipe(recv) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;there is a problem when create a pipe!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">    <span class="comment">// pid 为 0，即是子进程  </span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    read(send[<span class="number">0</span>], &amp;c, <span class="number">1</span>); <span class="comment">// 阻塞在这里直到父进程向管道中写入</span></span><br><span class="line">    <span class="type">int</span> pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, pid);</span><br><span class="line">    write(recv[<span class="number">1</span>], <span class="string">&quot;a&quot;</span>, <span class="number">1</span>); <span class="comment">// 向父进程发送消息，阻塞直到父进程读取消息</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    write(send[<span class="number">1</span>], <span class="string">&quot;a&quot;</span>, <span class="number">1</span>); <span class="comment">// 向子进程发送消息</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    read(recv[<span class="number">0</span>], &amp;c, <span class="number">1</span>); <span class="comment">// 阻塞，直到收到子进程的消息</span></span><br><span class="line">    <span class="type">int</span> pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, pid);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="primes-moderate-x2F-hard"><a href="#primes-moderate-x2F-hard" class="headerlink" title="primes (moderate&#x2F;hard)"></a>primes (moderate&#x2F;hard)</h2><p>这个是利用 fork 和 pipe 来实现并发的处理质数（除了 1 和 它本身，不能被整除的数）。一开始我还没有懂什么意思，看了这张图之后还是没有搞懂：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e359d7633b124b3c87f734b3d57d2e5b~tplv-k3u1fbpfcp-zoom-1.image"></p><p>后来看到一个 golang 版本的实现才明白是什么意思，也就是 root 父进程向一个通道中发送 2-35，并且 fork 出一个子进程，将这个通道传递给子进程，子进程从管道中读取出一个数，比如当前情况下这个数就是 2，它是一个质数（<strong>通道中的第一个数一定是质数，因为它没有被任何比它小的数给过滤掉</strong>），那么就打印。</p><p>接着这个子进程，再创建一个通道并 fork 一个子进程，然后将父进程通道中剩下的 3-35 都对刚刚取出来的质数 2 取模，如果不等于 0，表示起码不能被 2 整除，就将它放到新创建的通道中给它的子进程处理（看看它能不能被剩下的数整除）。</p><p>循环往复直到有一个子进程在通道里读不出东西了，这个时候表示 2-35 的所有质数都被找到了，就返回。要注意的是，每个进程都要等待它的子进程退出之后才能退出，所以要调用 wait 等待子进程退出。并且<strong>对于不再使用的通道要及时将其关闭</strong>，否则程序算不到 35 就会使 xv6 资源不足。关闭通道分关闭读端和写端，父进程对自己创建的通道只需要写而不需要读，所以它可以将读端先关闭，写完之后再将写端关闭，而子进程对于收到的通道只需要读不需要写，所以在收到之后，它可以先关闭写端，读完后再关闭读端。<strong>父进程不能再创建完后就关闭，而要在 fork 之后再关闭</strong>，因为如果先关闭了，那么子进程再持有到这个通道的文件描述符后，会发现通道的读端是关闭，无法读取数据，会被阻塞（卡了我好久）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">processor</span><span class="params">(<span class="type">int</span> *pipeline)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    close(pipeline[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> prime;</span><br><span class="line">    <span class="type">int</span> read_len = read(pipeline[<span class="number">0</span>], &amp;prime, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (read_len == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipeline[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line">    <span class="type">int</span> out[<span class="number">2</span>];</span><br><span class="line">    pipe(out);</span><br><span class="line">    <span class="keyword">if</span> (!fork())</span><br><span class="line">    &#123;</span><br><span class="line">        processor(out);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(out[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="keyword">while</span> (read(pipeline[<span class="number">0</span>], &amp;num, <span class="keyword">sizeof</span>(<span class="type">int</span>)) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % prime != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                write(out[<span class="number">1</span>], &amp;num, <span class="keyword">sizeof</span>(num));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(out[<span class="number">1</span>]);</span><br><span class="line">        close(pipeline[<span class="number">0</span>]);</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> pipeline[<span class="number">2</span>];</span><br><span class="line">    pipe(pipeline);</span><br><span class="line">    <span class="keyword">if</span> (!fork())</span><br><span class="line">    &#123;</span><br><span class="line">        processor(pipeline);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(pipeline[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> num = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            write(pipeline[<span class="number">1</span>], &amp;num, <span class="keyword">sizeof</span>(num));</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">35</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                close(pipeline[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="find-moderate"><a href="#find-moderate" class="headerlink" title="find (moderate)"></a>find (moderate)</h2><p>find 是用来找出在文件夹中所有的指定名称的文件。</p><p>可以参考 user&#x2F;ls.c 来看如何读取文件夹，并且使用递归来读取子文件夹（不用递归 “.” 和 “..” ，否则会爆栈）。使用 strcmp() 来比较字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件路径中将文件名解析出来，对 ls 中的版本做了修改，去掉了填充</span></span><br><span class="line"><span class="type">char</span> *</span><br><span class="line"><span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="keyword">for</span> (p = path + <span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">        ;</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *filename)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ls: path too long\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">    p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">    *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (de.inum == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        memmove(p, de.name, DIRSIZ);</span><br><span class="line">        p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (stat(buf, &amp;st) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ls: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// st.type 为 2 就是文件，使用 strcmp 作比较</span></span><br><span class="line">        <span class="keyword">if</span> (st.type == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(fmtname(buf), filename))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// st.type 为 1 就是文件夹，判断是否需要递归</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (st.type == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) || !<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            find(buf, filename);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将路径和文件名传入</span></span><br><span class="line">    find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="xargs-moderate"><a href="#xargs-moderate" class="headerlink" title="xargs (moderate)"></a>xargs (moderate)</h2><p>xargs 从标准输入中读取数据，将每一行当作参数添加到 xargs 后面的程序中当作参数，比如：</p><p>echo hello too | xargs echo bye -&gt; echo bye hello too.</p><p>| 符号表示通过管道将数据发送到程序中，所以我们读数据的时候只要使用 read 系统调用在标准输出中读取就可以了，标准输出的 fd 编号为 0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGS 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> buf_idx, read_len;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="type">char</span>* args[MAXARGS];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        args[i<span class="number">-1</span>] = argv[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比如 find . b | xargs grep hello 就有可能传入多行数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buf_idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从标准输出中读取数据到 buf 里，一次读取一个字符</span></span><br><span class="line">            read_len = read(<span class="number">0</span>, &amp;buf[buf_idx], <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">            <span class="comment">// 如果读到了 &#x27;\n&#x27; 或者已经没有数据了，就停止</span></span><br><span class="line">            <span class="keyword">if</span> (read_len &lt;= <span class="number">0</span> || buf[buf_idx] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buf_idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (read_len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加入字符串结束的标识</span></span><br><span class="line">        buf[buf_idx] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        args[argc<span class="number">-1</span>] = buf;</span><br><span class="line">        <span class="comment">// fork 出一条子进程来执行</span></span><br><span class="line">        <span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">            exec(args[<span class="number">0</span>], args);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43b467766b674fc0b1e77ebf0184b67d~tplv-k3u1fbpfcp-zoom-1.image"></p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to my blog!</p><p>I am a second-year graduate student majoring in computer science. I am very interested in system programming and database kernel, and I hope to work in this field in the future.</p><p>The reason I am called “bigboss” is that I am a big fan of the Metal Gear Solid game series.</p><p>I will upload some of my notes or project summaries during the learning process.</p><p>If there are any errors found or if you have any good suggestions, please contact me.</p><p>I am very willing to discuss these issues.</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>search</title>
      <link href="/search/index.html"/>
      <url>/search/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
