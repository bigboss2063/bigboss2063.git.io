<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DDIA：批处理</title>
      <link href="/post/a8095396.html"/>
      <url>/post/a8095396.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Unix 哲学：</p><ol><li>让每个程序都<strong>做好一件事</strong>。要做一件新的工作，写一个新程序，而不是通过添加 “功能” 让老程序复杂化。</li><li>期待每个程序的输出成为另一个程序的输入。不要将无关信息混入输出。避免使用严格的列数据或二进制输入格式。不要坚持交互式输入。</li><li>设计和构建软件时，即使是操作系统，也让它们能够尽早地被试用，最好在几周内完成。不要犹豫，扔掉笨拙的部分，重建它们。</li><li>优先使用工具来减轻编程任务，即使必须曲线救国编写工具，且在用完后很可能要扔掉大部分。</li></ol></blockquote><p>在 Unix 中，可以通过文件描述符和管道来将程序与程序组合起来。将这个思想过渡到 MapReduce 中，将 Mapper 和 Reducer 组合起来的接口是分布式文件系统。</p><p>分布式批处理框架需要解决两个问题：</p><ol><li><strong>分区：</strong>在 MapReduce 中，Mapper 负责接受输入的文件块，讲这些文件块进行分区、排序并合并到可配置数量的 Reducer 中。即把相关数据（可能是键相同）都放在同一个地方（同一个 Reducer 那里）。但是排序是一个代价昂贵的操作，所以在后 MapReduce 时代，数据流处理引擎都会减少非必要的排序。</li><li><strong>容错：</strong>MapReduce 会在一个任务完成后进行写盘，这使得单个任务的恢复很轻松，但是写盘的开销是很大的，这使得在无故障的情况下执行速度会减慢。并且 MapReduce 执行过程中可能出错的概率也不会很大，所以这个开销也许是不值得的，这与设计 MapReduce 时候 Google 的实际需求有关。后 MapReduce 时代的数据流引擎则会将中间状态保存在内存中，减少物化中间状态（写盘）。但这样如果节点发生故障，可能需要从故障节点开始将后面的算子全部计算一遍。如果算子是确定的，就可以减少重算的数据量。</li></ol><p>MapReduce 的几种连接算法：</p><ul><li><strong>排序合并连接：</strong>Mapper 根据连接键将参与连接的输入进行分区、排序和合并，将相同键的所有记录都传递给同一个 Reducer；</li><li>广播散列连接：两个连接输入之一很小，<strong>小到它的散列表可以完全放进内存</strong>，那么它不需要分区，而是给连接输入大端的每个分区启动一个 Mapper，将小端散列表加载到每个 Mapper 中，利用这个散列表跟大端进行连接。</li><li><strong>分区散列连接：</strong>如果两个连接输入按照同样的方式分区，即使用<strong>同样的散列函数、同样的连接键、同样的分区数量</strong>，那么可以独立地对每个分区应用散列表方法。</li></ul><p>其中大多数连接方法也在 <strong>MPP （大规模并行处理）数据库和数据流引擎</strong>内部使用。</p><p>本章中主要介绍的分布式批处理框架是 <strong>Hadoop</strong>。</p><blockquote><p>正如我们所看到的，Hadoop 有点像 Unix 的分布式版本，其中 HDFS 是文件系统，而 MapReduce 是 Unix 进程的怪异实现（总是在 Map 阶段和 Reduce 阶段运行 <code>sort</code> 工具）。</p></blockquote><p>Hadoop 和分布式数据库的不同点在于：</p><ul><li>Hadoop  <strong>存储具有多样性：</strong>不需要根据 schema 来存储数据，直接将数据不加以区分（原始形式）的转储到分布式文件系统（HDFS）中。可以加快数据收集速度，并且让数据消费者来解释数据，增加灵活性；</li><li>Hadoop <strong>处理模型具有多样性：</strong>使用分布式批处理框架可以轻松的在大型数据集上<strong>运行自己的代码</strong>；</li><li>Hadoop <strong>针对频繁故障设计：</strong>MapReduce 被设计为以单个粒度重试任务，当发生失败的概率足够高的时候，这是一种合理的权衡，可以避免将整个作业重试。</li></ul><blockquote><p>ps：文中好像把 MapReduce 和 Hadoop 等价了？</p></blockquote><p>由于 MapReduce 虽然很好懂，但是直接使用比较困难。并且 MapReduce 存在一些性能问题（比如过多的物化中间状态、过多的排序），几种用于分布式批处理的数据流引擎应运而生，它们有以下优点：</p><ul><li>减少排序等昂贵操作；</li><li>减少不必要的 Mapper。实际上没有严格定义的 Mapper 和 Reducer 了，只有<strong>算子</strong>；</li><li>工作流中的连接和数据依赖都是显示声明的，调度程序可以利用<strong>局部性</strong>进行优化；</li><li><strong>算子间的中间状态不保存到 HDFS 中，而是保存到节点的内存或磁盘上</strong>（不放到分布式文件系统中可以减少复制的开销）。但是可能会使得任务执行失败时候的重新计算量变大；</li><li>MapReduce 没开启一个任务都启动一个 JVM，而现在 <strong>JVM 可以重用，减少启动开销</strong>。</li></ul><p>数据流引擎中也引入了图模型，可以在整个图上执行某种离线处理或分析。但由于图算法通常有很多跨机器通信的额外开销，所以会明显拖慢分布式图算法。当图可以放进一台机器的内存（或者甚至能放进磁盘就行），在单机（甚至单线程）上执行图算法的性能也可能大于分布式批处理。只有当单机的内存（磁盘）放不下图的时候，使用分布式方法就不可避免了。</p><p>批处理作业的显著特点是<strong>输出从输入衍生</strong>，并且<strong>输入数据是有界的</strong>，所以批处理作业最终都会完成。而流处理的输入是无界的，作业可能会永远持续下去。</p>]]></content>
      
      
      <categories>
          
          <category> DDIA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDIA：一致性与共识</title>
      <link href="/post/6b17822.html"/>
      <url>/post/6b17822.html</url>
      
        <content type="html"><![CDATA[<p>本章讨论了分布式一致性与共识的<del>滑梯</del>。</p><p>在分布式一致性方面，主要讨论了线性一致性和因果一致性。</p><p>线性一致性的目的是<strong>让多副本数据看起来好像只有一个副本一样</strong>，并且使其上所有操作都原子性地生效。</p><p>在线性一致性系统中，只要客户端完成写操作，那么所有客户端进行读操作都能够看到刚刚写入的值，而不会读到旧值。也就是线性一致性是一个<strong>新鲜度保证</strong>。</p><p>通过记录所有请求和相应的时序，并检查它们是否可以排列成有效的顺序，以检查一个系统是否是线性一致性的是可能的，但这个<strong>计算代价是昂贵的</strong>。</p><p>线性一致性有用的场景：</p><ul><li>锁和领导选举；</li><li>约束和唯一性保证；</li><li>跨信道的时序依赖。</li></ul><p>如何实现线性一致的系统？最简单的答案就是真的只用一个副本（因为线性一致的目的就是让多个副本看起来像只有一个副本）。但这个方案显然无法容错，所以使用复制的方法，哪些可以保证线性一致性呢？</p><ul><li>单主复制（可能线性一致）：如果从主库或者跟主库同步更新的从库读取数据，那么可能是线性一致的。但如果使用了快照隔离，这样不能保证读取的新鲜度，无法保证线性一致。或并发处理上出现问题，也无法保证线性一致。</li><li><strong>共识算法（线性一致）</strong>：共识算法和单主复制类似，但是它避免了单主复制中脑裂和陈旧副本等问题，所以共识算法可以真正做到线性一致；</li><li>多主复制（非线性一致）：多主复制在每个数据中心都有一个领导者，都可以进行写入，那么他们的副本往往都是不一致的，在异步复制写入到其它节点时，需要解决写入冲突。</li><li>无主复制（也许不是线性一致）：最安全的方式是假定无主复制的系统不是线性一致的。</li></ul><p>在大多数分布式系统中，<strong>为了提高性能</strong>，而选择了牺牲线性一致性，而不是为了容错。没有办法在保持线性一致性的基础上提高性能，只能通过选择<strong>更弱的一致性模型</strong>来提高性能。</p><p>为了能够提高性能，选择<strong>因果一致性</strong>可能会更好。如果一个系统服从因果关系所规定的顺序，我们就说它是因果一致的。</p><p>线性一致性将所有操作放在单一的全序时间线中，而<strong>因果一致性则是偏序的，它允许一些操作并发执行</strong>（不存在因果关系的操作）。这部分并发操作可以减少不必要的等待和通信，可以提高系统的性能。而且对网络问题的敏感度要低得多。</p><p>我们可以使用<strong>兰伯特时间戳</strong>等方式来生成与因果关系一致的序列号。这样的序列号可以提供一种全序关系，使得那些不是并发的操作之间可以进行比较，从而可以<strong>根据这个全序关系来捕获关于因果的信息</strong>。</p><p>但有时候，仅仅有这个序列号还不够：考虑这样一个场景，我们需要确保用户名是唯一的，并拒绝同一用户名的其他并发注册。如果一个节点要通过注册，则需要知道其他的节点没有在并发抢注同一用户名的过程中。</p><p>那么怎么让这个节点知道其它节点有没有并发抢注同一用户名呢？这时候就需要<strong>共识</strong>了。</p><p>共识问题通常形式化如下：一个或多个节点可以 <strong>提议（propose）</strong> 某些值，而共识算法 <strong>决定（decides）</strong> 采用其中的某个值。</p><p>共识算法必须满足以下性质：</p><ul><li>一致同意：没有两个节点的决定不同；</li><li>完整性：没有节点决定两次；</li><li>有效性：如果一个节点决定了值 <code>v</code> ，则 <code>v</code> 由某个节点所提议（不能凭空做出一个决定）；</li><li><strong>终止</strong>：由所有未崩溃的节点来最终决定值（这是一个<strong>活性属性</strong>，其它三个都是<strong>安全属性</strong>，以确保当系统故障了，一个共识算法不能简单地永远闲坐着等死，<strong>它必须取得进展</strong>）。</li></ul><p>有很多等价的共识问题：</p><ul><li>线性一致性的 CAS 寄存器；</li><li>原子事务提交；</li><li>全序广播；</li><li>锁和租约；</li><li>成员&#x2F;协调服务；</li><li>唯一性约束（即上面那个例子中的场景）。</li></ul><p>如果采用“<strong>独裁</strong>”的方式，即将决策的权利都交给一个节点，那么事情就简单了。但这样就会导致如果这个“独裁者”宕机了，系统可能就无法推进。</p><p>应对这种情况有三种方式：</p><ol><li>等待领导者恢复（无法满足终止属性）；</li><li>人工故障切换（无法满足终止属性，且会更慢）；</li><li><strong>使用算法自动切换领导者</strong>。</li></ol><blockquote><p>如果你发现自己想要解决的问题可以归结为共识，并且希望它能容错，使用一个类似 ZooKeeper 的东西是明智之举。</p></blockquote><p>并不是所有的系统都需要共识，也不是所有系统都需要线性一致性。一切都是根据场景的需要（甚至大多数数据库都不支持）。</p>]]></content>
      
      
      <categories>
          
          <category> DDIA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDIA：分布式系统的麻烦</title>
      <link href="/post/349aae9a.html"/>
      <url>/post/349aae9a.html</url>
      
        <content type="html"><![CDATA[<p>在分布式系统中会发生的错误和处理错误的方式跟在单机上有本质的区别：</p><blockquote><p>装有良好软件的个人计算机通常要么功能完好，要么完全失效，而不是介于两者之间。</p></blockquote><p>而在分布式系统中，系统的部分可能在正常运行，但也有一部分会以某种<strong>不可预知</strong>的方式被破坏，这被称作部分失效（partial failure）。而难点也正是在于部分失效是 <strong>不确定性的（nondeterministic）</strong>。</p><p>在这一章中，讨论了分布式系统中可能发生的一些问题：</p><ul><li>网络数据包可能会丢失或延迟；</li><li>节点的时钟可能与其他节点的时钟不同步；</li><li>一个进程可能由于一些原因被暂停，而恢复的时候进程并不会意识到自己被暂停过了。</li></ul><p>这类问题都是部分失效的问题，所以分布式系统需要<strong>在软件层面建立对部分失效的容错机制</strong>，这样整个系统在部分失效的情况下也可以正常运行。</p><p>为了容忍错误，首先需要检测它们。大部分分布式算法都是通过<strong>超时</strong>来确定远程节点是否可用。但是超时检测并不能判断出节点到底是出现故障了还是由于网络环境的波动而导致响应消息延迟。</p><p>由于分布式系统节点之间通信的唯一方式是通过网络发送数据包，所以在分布式系统中不能依赖于单一节点做出判断，通常都是需要<strong>法定人数</strong>达成一致。</p><p>所以分布式系统的实现是非常困难的，对于一般的（能够在单机上就能处理的问题），把系统放在一台机器上是一种更加合理的选择。但需要获取容错和低延迟时，就不得不使用分布式系统了。</p><p>在分布式系统重出现的网络、时钟或进程的问题，可以通过昂贵的代价来解决。如果不是安全关键的系统，如航天、金融相关的，那么<strong>便宜而不安全</strong>的组件是一种更好的选择（我们的目的就是<strong>从不可靠的组件构建可靠的系统</strong>）。否则才去选择昂贵而安全的组件。</p><p>研究人员提出了很多共识算法，这些共识算法可以达到容忍分布式系统中出现的问题的目的。当然算法在理论上也许可以证明正确（一个系统模型中的算法总是满足它在所有我们假设可能发生的情况下的性质，那么这个算法是正确的），但是在现实中，总是有一些错误潜伏在系统中，会打破提出的假设。所以经验测试同样很重要。</p>]]></content>
      
      
      <categories>
          
          <category> DDIA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDIA：事务</title>
      <link href="/post/9058578b.html"/>
      <url>/post/9058578b.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>事实并非如此简单：与其他技术设计选择一样，事务有其优势和局限性。为了理解这些权衡，让我们了解事务所提供保证的细节 —— 无论是在正常运行中还是在各种极端（但是现实存在）的情况下。</p></blockquote><p>事务的作用是允许应用程序假装某些并发问题和某些类型的硬件和软件故障不存在（对应用程序透明）。将各式各样的错误简化成一种简单的情况：事务中止（transaction），应用程序需要做的就是重试即可。</p><p>事务大大简化了应用程序对于一些问题的处理，这导致了底层事务在实现上具有很高的复杂度，并且会影响性能。所以事务虽然可以帮助防止很多问题发生，但如果在非常简单的访问模式下（例如每次读写单条记录），根本无需事务。事务往往使用在更加复杂的访问模式。</p><blockquote><p>今天，当一个系统声称自己 “符合 ACID” 时，实际上能期待的是什么保证并不清楚。不幸的是，ACID 现在几乎已经变成了一个营销术语。</p></blockquote><p>可以看出作者对这些厂商营销很不满，已经很多次提到营销创造出来的词汇或者制造噱头的情况了。</p><p>事务的安全保证通常用 ACID 来描述：</p><ul><li><p>原子性（Atomicity）：<strong>能够在错误时中止事务，丢弃该事务进行的所有写入变更的能力。</strong>（作者说或许<strong>可中止性</strong>是更好的术语）。</p></li><li><p>一致性（Consistency）：<strong>对数据的一组特定约束必须始终成立</strong>。</p></li><li><p>隔离性（Isolation）：<strong>同时执行的事务之间是相互隔离的。</strong></p></li><li><p>持久性（Durability）：<strong>一旦事务成功完成，即使发生硬件故障或数据库崩溃，写入的任何数据也不会丢失。</strong></p></li></ul><p>事务并发执行会引起以下问题：</p><ul><li>脏读：一个客户端读取到另一个客户端尚未提交的写入。<strong>读已提交</strong> 或更强的隔离级别可以防止脏读；</li><li>脏写：一个客户端覆盖写入了另一个客户端尚未提交的写入。<strong>几乎所有</strong>的事务实现都可以防止脏写；</li><li>读取偏差（不可重复读）：在同一个事务中，客户端在不同的时间点会看见数据库的不同状态。</li><li>丢失更新：两个客户端同时执行读取-修改-写入操作序列。后完成的写操作没有根据先完成的写操作写入，而是直接覆盖了前面的写操作，前面一次写入就看作丢失；</li><li>写入偏差：一个事务读取一些东西，根据它所看到的值作出决定（即读取跟写入是因果关系，如果在写入时，读取的值已经是过时的，就会发生写入偏差）；</li><li>幻读：事务读取某些符合搜索条件的对象，另一个事务写入一个符合条件的记录，导致幻读。</li></ul><p>书中还提到了许多细节，这一章内容实在是太多了，还是要再看一次。</p><p>读未提交、读提交、快照隔离这些隔离级别都是弱隔离级别，它们仍然需要应用程序开发人员手动处理一些问题。只有可串行化隔离级别才能防范所有这些问题。</p><p>可串行化隔离级别有三种实现方式：</p><ol><li>字面上的串行化：如果事务执行足够快（短），并且单个 CPU 已经能够处理事务吞吐量，那么直接在单核上处理是一个简单有效的选择（如 VoltDB，Redis）；</li><li>两阶段锁定（2PL）：经过 Grow 和 Shrink 两阶段。但是性能很差，所以尽量避免使用它；</li><li>可串行化快照隔离（SSI）：在快照隔离级别上，使用乐观的方式，在事务提交的时候检查，事务中做得修改能否支持可串行化，如果不可以，那么就中止事务。有两种检测方式：<ol><li>检测对旧 MVCC 对象版本的读取，即在提交的时候检查之前忽略的写入是否已经生效了；</li><li>检测影响先前读取的写入：在索引（或表中）记录哪些数据被读取了，要对这些数据写入时，对读取这些数据的事务进行通知，告知它们，读取的数据可能已经过时了；</li></ol></li></ol><p>无论哪种数据模型，事务都是非常有价值的数据库功能。</p><p>本章在单机数据库中讨论这些内容，而引入到分布式数据库中又会导致一系列新的挑战。</p>]]></content>
      
      
      <categories>
          
          <category> DDIA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDIA：分区</title>
      <link href="/post/aeb0d97f.html"/>
      <url>/post/aeb0d97f.html</url>
      
        <content type="html"><![CDATA[<h1 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h1><blockquote><p>我们必须跳出电脑指令序列的窠臼。 叙述定义、描述元数据、梳理关系，而不是编写过程。</p><p>—— Grace Murray Hopper，未来的计算机及其管理（1962）</p></blockquote><p>这一章讲了在分布式数据库中的分区问题。</p><p><strong>分区的目的</strong>：当数据量非常大的时候，在单台机器上存储和处理不再可行，所以需要把大数据集拆分成更小的子集，这些子集称为分区，将分区存储在不同的节点上，可以增加并行性，同时增加可以存储的数据量。</p><p>主要的分区方法：</p><ol><li>键范围（Range）分区：</li></ol><p>​对一个分区指定 StartKey 和 EndKey，所有在 [StartKey, EndKey] 之间的键都存储在这个分区中。这种分区方式的优点是一个分区中的 Key 都是有序的，可以很好的支持范围查询，但缺点是如果经常访问相邻的 Key 会导致热点风险。</p><ol start="2"><li>散列（Hashing）分区：</li></ol><p>​根据散列函数来决定一个键应该被分到哪个区间，这种方式破坏了键的有序性，从而范围查询就效率低下了，但是分配更加均匀了。</p><p>​使用这种分区方式，通常是先创建固定数量的分区，这个数量会超过节点数量，当添加节点时，新的节点会从原本的节点哪里窃取分区，删除节点则相反。或者使用动态分区。</p><ol start="3"><li>混合分区：</li></ol><p>​例如使用符合主键：使用键的一部分来标识分区，而使用另一部分作为排序顺序。当主键确定的时候，可以进行高效的范围查询。</p><p>次级索引也需要分区，有两种方法：</p><ol><li>基于文档分区（本地索引）：其中次级索引存储在与主键和值相同的分区中。这种分区的方式写入的效率高，但读取有分散&#x2F;收集的额外开销；</li><li>基于关键词分区（全局索引）：其中次级索引被分散在不同的分区。这样分区，读取就不需要分散&#x2F;收集，但写入需要更新各个分区。</li></ol><p>分区再平衡（rebalancing）：随着时间的推移，节点的状态可能会改变，要进行分区迁移。</p><p>几种分区再平衡的方法：</p><ol><li>固定数量的分区：</li></ol><p>​创建固定数量的分区，这个数量会超过节点数量，当添加节点时，新的节点会从原本的节点哪里窃取分区，删除节点则相反。</p><ol start="2"><li>动态分区：</li></ol><p>​当分区中的数据多于上限时会进行分区分裂（Split），少于下限时会进行分区合并（Merge）。</p><ol start="3"><li>按节点比例分区：</li></ol><p>​给每个节点创建固定数量的分区。在这种情况下，每个分区的大小与数据集大小成比例地增长，而节点数量保持不变，但是当增加节点数时，分区将再次变小。</p><p>请求路由：解决当客户端想要发出请求时，判断要给哪个节点发送。</p><p>请求路由的几个方式：</p><ol><li>允许客户联系任意节点，如果正确则直接处理请求，否则由该节点将请求路由到正确的节点；</li><li>客户联系路由层，由路由层来进行负载均衡；</li><li>客户端可以知道分区和节点是如何分配的，自行决定如何发送请求。</li></ol>]]></content>
      
      
      <categories>
          
          <category> DDIA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab11: networking</title>
      <link href="/post/15f71c04.html"/>
      <url>/post/15f71c04.html</url>
      
        <content type="html"><![CDATA[<p>本次 lab 要给 xv6 实现网卡（Qemu 模拟 E1000 网卡）驱动。任务说明书里给了一大段说明以及 E1000 的操作手册。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="xv6-发送和接收网络包的流程"><a href="#xv6-发送和接收网络包的流程" class="headerlink" title="xv6 发送和接收网络包的流程"></a>xv6 发送和接收网络包的流程</h3><p>发送数据包：</p><ol><li>用户程序调用 connect 系统调用创建 socket 并获取 socket 的文件描述符；</li><li>调用 write 系统调用往 socket 的文件描述符中写入数据；</li><li>进入内核，调用 filewrite 函数，由于要写入的文件类型是 FD_SOCK，所以调用 sockwrite 函数，创建一个 mbuf 并将数据从用户空间拷贝过来；</li><li>调用 net_tx_udp 函数进行 udp 头部封装；</li><li>进一步调用 net_tx_ip 函数进行 ip 头部封装；</li><li>调用 net_tx_eth 函数，并将 m 通过e1000_transmit 函数传递给网卡驱动；</li><li>由 e1000_transmit 函数将 mbuf 放到发送队列的尾部，等待网卡设备发送。</li></ol><p>接受数据包：</p><ol><li>网卡接收到新的数据包，产生中断，内核调用中断处理函数 e1000_intr；</li><li>调用 e1000_recv 函数，开始读取缓冲队列中的消息；</li><li>读到一条消息后，通过net_rx 函数向上层传递；</li><li>根据消息的类型，判断是调用 net_rx_ip 函数还是 net_rx_arp 函数；</li><li>如果是 ip 消息，还需要进一步调用net_rx_udp 函数进行拆解；</li><li>调用 sockrecvudp 函数，在其中找到对应的 socket，再通过 mbufq_pushtail 函数将消息放到队列中，待 sockread 函数读取；</li></ol><p>以上就是 xv6 收发网络包的大体流程，具体可以自己阅读源码。</p><h3 id="描述符和缓冲队列"><a href="#描述符和缓冲队列" class="headerlink" title="描述符和缓冲队列"></a>描述符和缓冲队列</h3><p>驱动中有两种缓冲队列，发送和接收的队列，分别有两种描述符对应这两种队列。描述中中记录了对应缓存的存储地址、数据长度，还有一些标志位来让网卡和网卡驱动进行一些判断：</p><ul><li>E1000_TXD_STAT_DD 标志位就是让网卡驱动在发送数据时判断当前拿到的描述符对应的缓存是否已经发送了；</li><li>E1000_RXD_STAT_DD 标志位就是在接受数据的时候判断是否是没有接收过的数据；</li><li>E1000_TXD_CMD_RS 表示 Report Status，当这个字段被设置时，表示在数据包发送完成后，e1000 网卡会自动填充传输描述符中的报告状态区域，可以用来检查数据包是否发送成功。</li><li>E1000_TXD_CMD_EOP 表示 End Of Packet，当这个字段被设置时，表示数据包已经到达了传输描述符中的缓冲区的末尾。当该字段被设置时，意味着这是一个完整的数据包，可以开始传输了。</li></ul><p>上面的这几个 status 或 cmd 位是我们需要用到的。</p><h3 id="环形缓冲队列的头尾"><a href="#环形缓冲队列的头尾" class="headerlink" title="环形缓冲队列的头尾"></a>环形缓冲队列的头尾</h3><p>regs 数组中存储着 e1000 的寄存器的值，完成 lab 来说，需要使用到 regs[E1000_TDT]，即下一个需要传输的环形缓冲队列的索引，还有 regs[E1000_RDT]，即当前已经读到并且读过的环形缓冲队列索引。根据 Hints 来增加索引即可。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>首先实现 e1000_transmit。根据刚刚的调用流程分析，可能会有多个进程同时调用该函数，所以为了防止发生竞态，需要对函数上锁。接下来的步骤就是按照 Hints 来就行：</p><ol><li>上锁；</li><li>获取 regs[E1000_TDT] 位置的描述符；</li><li>判断描述符 status 的 E1000_TXD_STAT_DD 是否被设置，没被设置说明之前数据还没发送，这个描述符对应的位置不能放入一个新的数据，返回 -1；</li><li>否则如果这个描述符对应的位置有数据则释放（调用 mbuffree）；</li><li>重新设置描述符的 addr、length、cmd；</li><li>更新 regs[E1000_TDT] 为 （regs[E1000_TDT]+1）% TX_RING_SIZE；</li><li>将参数 m 放入缓冲区中；</li><li>释放锁，返回 0；</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">e1000_transmit</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// the mbuf contains an ethernet frame; program it into</span></span><br><span class="line">  <span class="comment">// the TX descriptor ring so that the e1000 sends it. Stash</span></span><br><span class="line">  <span class="comment">// a pointer so that it can be freed after sending.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;e1000_lock);</span><br><span class="line"></span><br><span class="line">  uint32 txrid = regs[E1000_TDT];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span> *<span class="title">txdesc</span> =</span> &amp;tx_ring[txrid];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((txdesc-&gt;status &amp; E1000_TXD_STAT_DD) == <span class="number">0</span>) &#123;</span><br><span class="line">    release(&amp;e1000_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(txdesc-&gt;addr != <span class="number">0</span>) &#123;</span><br><span class="line">    mbuffree((<span class="keyword">struct</span> mbuf *) tx_mbufs[txrid]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  txdesc-&gt;addr = (uint64) m-&gt;head;</span><br><span class="line">  txdesc-&gt;length = m-&gt;len;</span><br><span class="line">  txdesc-&gt;cmd |= E1000_TXD_CMD_RS;</span><br><span class="line">  txdesc-&gt;cmd |= E1000_TXD_CMD_EOP;</span><br><span class="line"></span><br><span class="line">  regs[E1000_TDT] = (txrid + <span class="number">1</span>) % TX_RING_SIZE;</span><br><span class="line"></span><br><span class="line">  tx_mbufs[txrid] = m;</span><br><span class="line"></span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是 e1000_recv，注意它是不可以上锁的。第一是只有在处理中断的时候会调用该函数，不会发生竞态，第二是如果接收到的数据包是 ARP 数据包，那么在解包的时候就会调用 net_tx_arp 函数回复自己的 mac，会调用 e1000_transmit 再次获取锁，发生 panic。</p><p>根据 Hints：</p><ol><li>获取下一个要读的描述符；</li><li>判断描述符的 E1000_RXD_STAT_DD 位是否被设置，没被设置就返回。注意这里要用一个循环来读取，直到不满足条件：</li></ol><p>Your e1000_recv() code must scan the RX ring and deliver each new packet’s mbuf to the network stack (in net.c) by calling net_rx().</p><ol start="3"><li>将描述符指向的数据通过 net_rx 传递给上层；</li><li>创建一个新的 mbuf 放入该位置中；</li><li>更新 regs[E1000_RDT] 为当前位置；</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">e1000_recv</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Check for packets that have arrived from the e1000</span></span><br><span class="line">  <span class="comment">// Create and deliver an mbuf for each packet (using net_rx()).</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  uint32 rxrid = (regs[E1000_RDT] + <span class="number">1</span>) % RX_RING_SIZE;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rx_desc</span> *<span class="title">rxdesc</span> =</span> &amp;rx_ring[rxrid];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (rxdesc-&gt;status &amp; E1000_RXD_STAT_DD) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m</span> =</span> rx_mbufs[rxrid];</span><br><span class="line"></span><br><span class="line">    m-&gt;len = rxdesc-&gt;length;</span><br><span class="line">    net_rx(m);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">nm</span> =</span> mbufalloc(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    rxdesc-&gt;addr = (uint64) nm-&gt;head;</span><br><span class="line">    rxdesc-&gt;status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rx_mbufs[rxrid] = nm;</span><br><span class="line"></span><br><span class="line">    regs[E1000_RDT] = rxrid;</span><br><span class="line"></span><br><span class="line">    rxrid = (regs[E1000_RDT] + <span class="number">1</span>) % RX_RING_SIZE;</span><br><span class="line"></span><br><span class="line">    rxdesc = &amp;rx_ring[rxrid];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b539074750aa422aa18595066f9f3c56~tplv-k3u1fbpfcp-zoom-1.image"></p><p>这次不用跑 usertests，很快就跑完了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次实验给的材料太多了，还挺难看完的。建议选着看就行了，因为我感觉实际上只看 Hints 也能做个八九不离十。这次 lab 相对简单，有很多可以做的事情都在 Optional Challenges 中，感觉有时间可以做一做。</p><h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2><p>MIT 6.S081 Fall 2020 的 lab 算是全部做完了，如释重负，不过 Optional Challenges 是一个没做。后续计划再整体好好过一遍代码整理对应的知识。其实我感觉收益还是蛮大的，只要动手了，即使实现的版本是性能不高并且简单的，对相应知识的理解也能更加深刻，更别说后续再做 Optional Challenges。</p><p>并且我感觉这门课的 lab 比起 6.824 来说更加与课程内容强相关，上课没懂的地方看看代码或许就懂了，上手也会更加简单。</p><p>还剩了几堂 Lecture 没看完，希望五月份之前能搞定吧。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab10: mmap</title>
      <link href="/post/a1137fe6.html"/>
      <url>/post/a1137fe6.html</url>
      
        <content type="html"><![CDATA[<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>这次 lab 是要给 xv6 添加 mmap 和 munmap 系统调用。</p><p>mmap 的好处在于可以将一个文件直接映射到进程的地址空间中，从而避免了不必要的数据复制，提高了文件操作的效率。与使用 read 和 write 系统调用不同，mmap 操作不需要将文件数据从内核缓冲区复制到用户缓冲区，也不需要将用户缓冲区中的数据复制回内核缓冲区。相反，它通过映射文件的方式，将文件数据直接映射到了进程的地址空间中，因而可以提高文件操作的效率。</p><p>同时 mmap 也避免了由于使用 read 和 write 系统调用而造成的在用户空间和内核空间的上下文切换，节省了系统调用的开销。</p><h3 id="系统调用声明"><a href="#系统调用声明" class="headerlink" title="系统调用声明"></a>系统调用声明</h3><p>mmap 系统调用的函数声明为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, uint64 len, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, uint64 offset)</span>;</span><br></pre></td></tr></table></figure><ul><li>addr 为文件在用户地址空间的起始地址，一般传入 0，由内核设置；</li><li>len 为要映射的字节数量；</li><li>prot 为权限字段，指明该文件是可读（PROT_READ）、可写（PROT_WRITE）或可执行（PROT_EXEC）的；</li><li>flags 为标记位，标记映射的模式，MAP_SHARED 模式标识在 munmap 的时候需要把改动写回磁盘，MAP_PRIVATE 模式则不需要；</li><li>fd 是文件的描述符；</li><li>offset 为文件起始位置到开始映射的位置的偏移量。</li></ul><p>munmap 系统调用的函数声明为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, uint64 len)</span>;</span><br></pre></td></tr></table></figure><ul><li>addr 为从哪里开始解除映射；</li><li>len 为解除映射的字节数。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>添加 mmap 和 munmap 系统调用的过程这里就省略了。直接来看实现。</p><p>首先，为了能够让用户进程知道关于文件映射的信息，需要在 proc 结构体记录下。新增 vma 结构体，来存储文件映射的相关信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma</span> &#123;</span></span><br><span class="line">  <span class="type">int</span>    valid; <span class="comment">// 该 vma 是否有效</span></span><br><span class="line">  uint64 addr;  <span class="comment">// 文件在进程地址空间中的起始地址</span></span><br><span class="line">  uint64 len;   <span class="comment">// 文件映射了多少字节</span></span><br><span class="line">  <span class="type">int</span>    prot;  <span class="comment">// 文件权限</span></span><br><span class="line">  <span class="type">int</span>    flags; <span class="comment">// 映射模式标识</span></span><br><span class="line">  <span class="type">int</span>    fd;    <span class="comment">// 文件标识符</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span> <span class="comment">// 指向对应的文件结构体</span></span><br><span class="line">  uint64 offset; <span class="comment">// 文件映射的偏移</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>并且在 proc 结构体中添加一个 vma 数组，根据 hint，大小为 16 即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma</span> <span class="title">vmatable</span>[<span class="title">NVMA</span>];</span> <span class="comment">// NVMA 为定义在 kernel/param.h 中的宏</span></span><br></pre></td></tr></table></figure><p>接着在 kernel&#x2F;sysfile.c 中实现 sys_mmap 函数。大致流程如下：</p><ol><li>接收 mmap 系统调用传递的参数；</li><li>判断参数是否可以满足映射条件：</li></ol><!----><ol><li><ol><li>只读文件在 MAP_PRIVATE 模式下，是可写的；</li><li>只读文件在 MAP_SHARED 模式下，是不可写的。</li></ol></li></ol><!----><ol start="3"><li>从进程中记录的 vma 中找出一个空闲的 vma，并在进程的 heap 中找出一段可用的内存，将这段内存的起始地址作为系统调用的返回值。注意在这里是不进行内存分配的，只是标记，跟 lazy alloction 是一样的，这样可以让映射比内存空间更大的文件成为可能。为了和进程正在使用的地址空间区分开，选择从 heap 的高位置开始向下扩展来映射文件，即从 TRAPFRAME 开始。</li><li>设置 vma 的值；</li><li>filedup 对应文件；</li></ol><p>mmap should increase the file’s reference count so that the structure doesn’t disappear when the file is closed.</p><p>close 系统调用关闭是的一个打开的文件描述符，只是减少该文件的打开引用数，在这里增加一次引用后，就算调用了 close 也不会影响到对已经映射的内存。</p><ol start="6"><li>返回映射的起始地址；</li></ol><p>实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_mmap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  uint64 len, offset;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> prot, flags, fd;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">1</span>, &amp;len) &lt; <span class="number">0</span> || argint(<span class="number">2</span>, &amp;prot) &lt; <span class="number">0</span> || argint(<span class="number">3</span>, &amp;flags) &lt; <span class="number">0</span> || argint(<span class="number">4</span>, &amp;fd) &lt; <span class="number">0</span> || argaddr(<span class="number">5</span>, &amp;offset) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> =</span> p-&gt;ofile[fd];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ((file-&gt;readable &amp;&amp; !file-&gt;writable) &amp;&amp; (prot &amp; PROT_WRITE) &amp;&amp; (flags &amp; MAP_SHARED)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">vma</span> =</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">  uint64 addr = TRAPFRAME;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!p-&gt;vmatable[i].valid &amp;&amp; !found) &#123;</span><br><span class="line">      found = <span class="number">1</span>;</span><br><span class="line">      vma = &amp;p-&gt;vmatable[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;vmatable[i].valid &amp;&amp; p-&gt;vmatable[i].addr &lt; addr) &#123;</span><br><span class="line">      addr = p-&gt;vmatable[i].addr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  addr = addr - len;</span><br><span class="line"></span><br><span class="line">  vma-&gt;valid = <span class="number">1</span>;</span><br><span class="line">  vma-&gt;fd = fd;</span><br><span class="line">  vma-&gt;file = file;</span><br><span class="line">  vma-&gt;len = len;</span><br><span class="line">  vma-&gt;offset = offset;</span><br><span class="line">  vma-&gt;prot = prot;</span><br><span class="line">  vma-&gt;flags = flags;</span><br><span class="line">  vma-&gt;addr = addr;</span><br><span class="line"></span><br><span class="line">  filedup(vma-&gt;file);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成这一步后，在用户程序中调用 mmap 就会返回一个正确的映射后的起始地址了，但是当进行访问的时候，由于并没有分配内存，就会触发 page fault，所以跟 lazy alloction 一样，在 kernel&#x2F;trap.c#usertrap 中处理 page fault。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) &#123;</span><br><span class="line">  uint64 va = r_stval();</span><br><span class="line">  <span class="keyword">if</span> (mmaphandler(va) == <span class="number">-1</span>) &#123;</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>kernel&#x2F;vm.c#mmaphandler 函数接收一个虚拟内存地址（发生 page fault 的地址），来处理 pagefault。</p><p>在 mmaphandler 中，我们需要做以下事情：</p><ol><li>找出 va 是映射在哪个页中，也就是需要找出对应的 vma；</li><li>给 vma 正式分配内存；</li><li>根据 vma 中记录的 prot 来设置 PTE 的 flags；</li><li>将物理地址和虚拟地址进行映射；</li><li>使用 readi 将文件读到刚分配的内存中。在进行操作的时候要开启事务，并且对 inode 上锁。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mmaphandler</span><span class="params">(uint64 va)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">vma</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NVMA; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">v</span> =</span> &amp;p-&gt;vmatable[i];</span><br><span class="line">    <span class="keyword">if</span> (v-&gt;valid) &#123;</span><br><span class="line">      <span class="keyword">if</span> (va &gt;= v-&gt;addr &amp;&amp; va &lt; (v-&gt;addr + v-&gt;len * PGSIZE)) &#123;</span><br><span class="line">        vma = v;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vma == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  uint64 ka = (uint64)kalloc();</span><br><span class="line">  <span class="keyword">if</span> (ka == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>((<span class="type">void</span> *) ka, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  va = PGROUNDDOWN(va);</span><br><span class="line">  <span class="type">pte_t</span> * pte;</span><br><span class="line">  <span class="comment">// avoid remap panic.</span></span><br><span class="line">  <span class="keyword">if</span> ((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) != <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_V) != <span class="number">0</span>) &#123;</span><br><span class="line">    kfree((<span class="type">void</span> *) ka);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> flags = PTE_FLAGS(*pte);</span><br><span class="line">  <span class="keyword">if</span> (vma-&gt;prot &amp; PROT_READ) &#123;</span><br><span class="line">    flags |= PTE_R;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vma-&gt;prot &amp; PROT_WRITE) &#123;</span><br><span class="line">    flags |= PTE_W;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vma-&gt;prot &amp; PROT_EXEC) &#123;</span><br><span class="line">    flags |= PTE_X;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(mappages(p-&gt;pagetable, va, PGSIZE, ka, flags | PTE_U) != <span class="number">0</span>) &#123;</span><br><span class="line">    kfree((<span class="type">void</span> *) ka);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ip = vma-&gt;file-&gt;ip;</span><br><span class="line">  begin_op();</span><br><span class="line">  ilock(ip);</span><br><span class="line">  <span class="keyword">if</span> (readi(ip, <span class="number">0</span>, ka, PGROUNDDOWN(vma-&gt;offset + (va - vma-&gt;addr)), PGSIZE) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlock(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就可以访问我们映射到内存中的文件了。</p><p>接下来要实现 munmap 系统调用（kernel&#x2F;sysfile.c#sys_munmap），注意根据文档，munmap 可以是一部分，但是不会是在中间。</p><p>An munmap call might cover only a portion of an mmap-ed region, but you can assume that it will either unmap at the start, or at the end, or the whole region (but not punch a hole in the middle of a region).</p><p>在 sys_munmap 函数中我们要处理以下事情：</p><ol><li>接收 addr 和 len 参数；</li><li>找出 addr 对应的 vma；</li><li>判断 vma 是否是 MAP_SHARED 模式，如果是就调用 filewrite 将文件写回磁盘；</li><li>取消 munmap 部分的映射；</li><li>调整 vma 的长度和起始地址。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_munmap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  </span><br><span class="line">  uint64 addr, len;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span> || argaddr(<span class="number">1</span>, &amp;len) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">vma</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NVMA; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">v</span> =</span> &amp;p-&gt;vmatable[i];</span><br><span class="line">    <span class="keyword">if</span> (v-&gt;valid &amp;&amp; (v-&gt;addr &lt;= addr &amp;&amp; addr &lt; (v-&gt;addr + len))) &#123;</span><br><span class="line">      vma = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!vma) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (vma-&gt;flags &amp; MAP_SHARED &amp;&amp; vma-&gt;file-&gt;writable) &#123;</span><br><span class="line">    filewrite(vma-&gt;file, addr, len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  uvmunmap(p-&gt;pagetable, addr, len / PGSIZE, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  vma-&gt;len -= len;</span><br><span class="line">  <span class="keyword">if</span>(vma-&gt;len == <span class="number">0</span>) vma-&gt;valid = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;addr == addr) vma-&gt;addr += len;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意修改 uvmunmap，否则会报 panic。</p><p>当进程退出的时候，即调用 kernel&#x2F;proc.c#exit，我们需要将它映射的所有文件都 munmap 掉，就像调用 munmap 系统调用。由于我的实现是父子进程并不共享物理内存，所以直接释放掉即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... kernel/proc.c#exit</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NVMA; i++) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">v</span> =</span> &amp;p-&gt;vmatable[i];</span><br><span class="line">  <span class="keyword">if</span> (v-&gt;valid) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v-&gt;flags &amp; MAP_SHARED &amp;&amp; v-&gt;file-&gt;writable) &#123;</span><br><span class="line">      filewrite(v-&gt;file, v-&gt;addr, v-&gt;len);</span><br><span class="line">    &#125;</span><br><span class="line">    uvmunmap(p-&gt;pagetable, v-&gt;addr, v-&gt;len/PGSIZE, <span class="number">1</span>);</span><br><span class="line">    v-&gt;valid = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后修改 kernel&#x2F;proc.c#fork，在子进程复制父进程的内存时，可能会复制到没有映射或无效的条目，也要修改 uvmcopy 将 panic 去掉。在 fork 函数中只需要将 vma 复制一份给子进程就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...kernel/proc.c#fork</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NVMA; i++) &#123;</span><br><span class="line">  np-&gt;vmatable[i] = p-&gt;vmatable[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里 mmaptest 和 fork test 就都可以通过了。</p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16f785924bf3438694413adae57db01b~tplv-k3u1fbpfcp-zoom-1.image"></p><p>这次的 grader 倒是顺利跑过了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个 lab 是对 file system 的进一步深入，不过我感觉跟虚拟内存可能更加相关？难点主要是在 mmap 系统调用，要考虑如何给 vma 找到一块合适的内存空间，想清楚这里之后其它的就比较简单了。page fault 的处理跟 lazy alloction 是一样的。munmap 系统调用就相当于做了一次反操作。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab9: file system</title>
      <link href="/post/801fac79.html"/>
      <url>/post/801fac79.html</url>
      
        <content type="html"><![CDATA[<p>本次 lab 感觉就是对 xv6 文件系统代码进行熟悉，我们要扩充 xv6 支持的最大文件大小并且给 xv6 实现软链接。</p><h2 id="Large-files-moderate"><a href="#Large-files-moderate" class="headerlink" title="Large files (moderate)"></a>Large files (moderate)</h2><p>xv6 原本支持的最大文件大小只有 12 + 256 个 block，也就是 inode 结构体中 addr 数组的前 12 个元素指出的 12 个 block加上最后一个元素指出的一个 block 中指出了 256 个 block。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cea2a50d75964b9dbb762ddd2cb821e5~tplv-k3u1fbpfcp-zoom-1.image"></p><p>如上图所示，最后一位 singly-indirect block num 指出了一个 block，里面又存储了 256 个 direct block num。一个 block 是 1024B，一个 block num 为 4B，所以正好存储 256 个 direct block num。</p><p>我们要做的就是将文件容量扩充为 11 + 256 + 256*256。改为将 addr 数组前 11 位作为 direct block num，第 12 位作为 singly-indirect block num，将第 13 位作为 doubly-indirect block num。doubly-indirect block num 指向一个 block，这个 block 里面的每个条目都是一个 singly-indirect block num，也就是说还需要再定位一次，才能取到真正的 block num。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>修改 kernel&#x2F;fs.h 中的这几个宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLY_NINDIRECT (BSIZE / sizeof(uint))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DOUBLY_NINDIRECT SINGLY_NINDIRECT * SINGLY_NINDIRECT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE (NDIRECT + SINGLY_NINDIRECT + DOUBLY_NINDIRECT)</span></span><br></pre></td></tr></table></figure><p>并且记得将 struct inode 和 struct dinode 结构体中的 addrs 数组修改一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint addrs[NDIRECT+<span class="number">1</span>+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br></pre></td></tr></table></figure><p>核心就是修改 bmap，仿照原来的代码，对 doubly-indirect block num 进行搜索即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; SINGLY_NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  bn -= SINGLY_NINDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    现在的 bn / 256 的值用于在第一级索引中定位一个 block num，取出这个 block 作为二级索引。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    bn % 256 的值用于在第二级索引中定位一个 block num，这个 block num 就是 data block num。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    所有的 block 都是按需申请，没有的话就创建一个。</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; DOUBLY_NINDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT+<span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    uint idx = bn / (BSIZE / <span class="keyword">sizeof</span>(uint));</span><br><span class="line">    <span class="keyword">if</span>((addr = a[idx]) == <span class="number">0</span>) &#123;</span><br><span class="line">      a[idx] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    idx = bn % (BSIZE / <span class="keyword">sizeof</span>(uint));</span><br><span class="line">    <span class="keyword">if</span>((addr = a[idx]) == <span class="number">0</span>) &#123;</span><br><span class="line">      a[idx] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后修改 itrunc 来释放一个文件的所有 block，跟 bmap 是差不多的，doubly-indirect blocks 多遍历一层就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  uint *a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">      ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; SINGLY_NINDIRECT; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j])</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT+<span class="number">1</span>])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; SINGLY_NINDIRECT; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j]) &#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span> =</span> bread(ip-&gt;dev, a[j]);</span><br><span class="line">        uint *data = (uint*)b-&gt;data;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; SINGLY_NINDIRECT; k++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(data[k])</span><br><span class="line">            bfree(ip-&gt;dev, data[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(b);</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Symbolic-links-moderate"><a href="#Symbolic-links-moderate" class="headerlink" title="Symbolic links (moderate)"></a>Symbolic links (moderate)</h2><p>给 xv6 实现软连接（符号连接）。符号连接通过路径名连接到目标文件，也就是说在使用 open 系统调用的时候，如果打开的是一个符号连接，那么 file system 就会找到这个软连接指向的目标文件，再去打开目标文件（除非指定了 O_NOFOLLOW 标识，那么 fs 就会直接打开软连接，而不会去追踪到目标文件）。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>前面添加新的系统调用和这里就跳过了。</p><p>在 kernel&#x2F;stat.h 中添加 T_SYMLINK 来标识一个 inode 类型是软连接，在 kernle&#x2F;fcntl.h 中添加一个新的标识符 O_NOFOLLOW，以让 open 系统调用判断是要打开一个软连接还是追踪软连接的目标文件。</p><p>首先实现 kernel&#x2F;sysfile.c#sys_symlink</p><p>这是一个系统调用函数，对应的用户空间的声明是 int symlink(char*, char*)；所以我们需要先将两个参数拿到。</p><p>接着开启一个事务，在事务中完成 inode 的创建和写入。调用 create 函数创建 inode，要注意 create 返回的时候已经持有了 inode 的锁，不需要再次获取锁了，并且在事务结束时要调用 iunlockput 函数来释放锁并且取消一次引用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_symlink</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">char</span> path[MAXPATH], target[MAXPATH];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, target, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, path, MAXPATH) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="keyword">if</span>((ip = create(path, T_SYMLINK, <span class="number">0</span>, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n = <span class="built_in">strlen</span>(target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(writei(ip, <span class="number">0</span>, (uint64)target, <span class="number">0</span>, n) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  iunlockput(ip); <span class="comment">// 释放在 create 中获取的锁</span></span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 kernel&#x2F;sysfile.c#sys_open 系统调用，新增判断当前 path 指向的 inode 是否是软连接，并且检查O_NOFOLLOW 标志位。Hints 中写到两点注意事项：</p><ol><li>如果一个软连接又指向一个软连接，那么要递归找出最终的目标文件；</li><li>软连接可能会成环，这个时候就返回错误，hints 中的解决策略是限制递归次数为 10 次。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(omode &amp; O_CREATE)&#123;</span><br><span class="line">  ip = create(path, T_FILE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(ip == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 新增的代码在此处</span></span><br><span class="line">  <span class="type">int</span> symlinkdepth = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    symlinkdepth++;</span><br><span class="line">    <span class="keyword">if</span> (symlinkdepth &gt; <span class="number">10</span>) &#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span> (ip-&gt;type == T_SYMLINK &amp;&amp; !(omode &amp; O_NOFOLLOW)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)path, <span class="number">0</span>, MAXPATH) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        iunlockput(ip);</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>不知道是代码写的太臭还是我这个台式捡垃圾捡的 CPU 太慢的原因，直接跑 make grade 是直接超时了，一会用笔记本跑一下。直接在 qemu 中跑 bigfile、symlinktest、usertests 都是没问题的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次 lab 比上一个简单得多，在 symlink 部分需要好好读一下接口。我一开始没看清 create 中就已经获取了 inode 锁，并且没有释放，将 unlock(dp) 看成了 unlock(ip)，也卡了不少时间。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab8: locks</title>
      <link href="/post/e613f387.html"/>
      <url>/post/e613f387.html</url>
      
        <content type="html"><![CDATA[<p>本次 lab 是要重新设计 xv6 的内存分配器和块缓存来获取更高的并行性。要增加并行性通常要设计到更改数据结构和上锁策略来减少竞态。</p><h2 id="Memory-allocator-moderate"><a href="#Memory-allocator-moderate" class="headerlink" title="Memory allocator (moderate)"></a>Memory allocator (moderate)</h2><p>原本的 allocator 中只有一个单独的 freelist，也就是说 page 的分配和释放都会频繁的产生竞争。所以给每个 CPU 设置一个单独的 freelist 和一个单独的锁。所以进程在不同的 CPU 上申请和分配 page 就可以并行运行了。如果当前 CPU 上 freelist 的为空的时候，就要去别的 CPU 那里偷取 page，这个时候依旧会产生竞争。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>首先修改 CPU 结构体，在每个 CPU 中加入一个之前的 kmem，让每个 CPU 可以单独的分配内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-CPU state.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kmem</span> <span class="title">kmem</span>;</span></span><br><span class="line">  <span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line">  <span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过 NCPU 参数可以知道，有 8 个 CPU，所以在初始化 alloctor 的时候将 freepage 分成 8 份，分别放入 8 个 CPU 的 kmem 中。其实也可以初始化的时候都放到一个 CPU 里，然后其它 CPU 去偷。但是我感觉这样会有一个冷启动的过程，不如在初始化的时候直接先分配了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 offset = (PHYSTOP - (uint64)end)/<span class="number">8</span>;</span><br><span class="line">  uint64 left, right;</span><br><span class="line">  left = (uint64) end;</span><br><span class="line">  right = left + offset;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> &amp;cpus[i];</span><br><span class="line">    initlock(&amp;c-&gt;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    p = (<span class="type">char</span>*)PGROUNDUP(left);</span><br><span class="line">    <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)right; p += PGSIZE) &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(((uint64)p % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)p &lt; end || (uint64)p &gt;= PHYSTOP)</span><br><span class="line">        panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">      <span class="built_in">memset</span>(p, <span class="number">1</span>, PGSIZE);</span><br><span class="line">      r = (<span class="keyword">struct</span> run*)p;</span><br><span class="line">      r-&gt;next = c-&gt;kmem.freelist;</span><br><span class="line">      c-&gt;kmem.freelist = r;</span><br><span class="line">    &#125;</span><br><span class="line">    left = right;</span><br><span class="line">    right = right + offset;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 kfree，在释放的时候申请当前 CPU 的 kmem 锁，将 page 释放到当前 CPU 的 freelist 中即可，注意开关中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  push_off();</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;c-&gt;kmem.lock);</span><br><span class="line">  r-&gt;next = c-&gt;kmem.freelist;</span><br><span class="line">  c-&gt;kmem.freelist = r;</span><br><span class="line">  release(&amp;c-&gt;kmem.lock);</span><br><span class="line"></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是 kalloc，在分配的时候由于当前 CPU 的 freelist 可能已经为空了，那么就需要去其它 CPU 那里偷。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  push_off();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  <span class="type">int</span> cid = cpuid();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> &amp;cpus[cid];</span><br><span class="line"></span><br><span class="line">  acquire(&amp;c-&gt;kmem.lock);</span><br><span class="line">  r = c-&gt;kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">    c-&gt;kmem.freelist = r-&gt;next;</span><br><span class="line">    release(&amp;c-&gt;kmem.lock);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    release(&amp;c-&gt;kmem.lock);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == cid) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">nc</span> =</span> &amp;cpus[i];</span><br><span class="line">      acquire(&amp;nc-&gt;kmem.lock);</span><br><span class="line">      r = nc-&gt;kmem.freelist;</span><br><span class="line">      <span class="keyword">if</span> (r) &#123;</span><br><span class="line">        acquire(&amp;c-&gt;kmem.lock);</span><br><span class="line">        nc-&gt;kmem.freelist = r-&gt;next;</span><br><span class="line">        release(&amp;c-&gt;kmem.lock);</span><br><span class="line">        release(&amp;nc-&gt;kmem.lock);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        release(&amp;nc-&gt;kmem.lock);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  pop_off();</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去其它 CPU 那里偷的时候，由于要获取其它 CPU 的锁，所以会产生竞争。还有一种情况就是当前进程持有当前 CPU 的锁去偷其它 CPU 的时候，那个被偷的 CPU 可能也正在尝试偷当前 CPU，这样就会产生死锁。</p><p>可以选择在去别的 CPU 那里偷之前把当前 CPU 的锁释放掉，这样就不会产生死锁，破坏了死锁的必要条件。我在大佬的博客上看到说如果这个时候释放了锁，就会导致重复偷取 page。我想了一下，如果说在释放当前 CPU 的 kmem 锁之后，该进程被调度走了，另外一个进程又过来执行 kalloc，也发现当前 CPU 的 freelist 是空的，也会进行偷取。但是我感觉当前已经是关中断了，那么时钟中断也会被屏蔽，当前进程就不会被调度了，所以应该不会产生这种情况吧。这一块没有太懂，不过能通过测试，暂时先这样。</p><h2 id="Buffer-cache-hard"><a href="#Buffer-cache-hard" class="headerlink" title="Buffer cache (hard)"></a>Buffer cache (hard)</h2><p>这部分要做的事情跟第一部分的目的是一样的，修改 bcache 结构体，并降低锁的粒度。将原本的用一个大锁锁住整个双向链表的设计，拆分成一个 Hash Table，每个 bucket 一个锁，那么就可以使得访问不同 bucket 的进程并行访问 buffer cache。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>根据 hints，最基本的思路是很容易想到的。将 buffer 以哈希表的形式组织，bucket 的数量为 13 个，每个 bucket 需要一把锁。并且把原本的双向链表设计去掉，原本的双向链表是为了实现 LRU，但现在我们通过给每个 buffer 记录时间戳来实现 LRU，时间戳就为 kernel&#x2F;trap.c 中的 ticks。</p><p>所以 bcache 结构改为以下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buckets</span>[<span class="title">NBUCKET</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">bucketlocks</span>[<span class="title">NBUCKET</span>];</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure><p>在 buf 结构体中去掉 prev 指针，并加入 timestamp 字段，用于实现 LRU：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> valid;   <span class="comment">// has data been read from disk?</span></span><br><span class="line">  <span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf?</span></span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">  uint refcnt;</span><br><span class="line">  uint timestamp;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样一来就不需要维护双向链表了，binit 的实现也很简单，只需要初始化锁并且将 bcache.buf 中的所有 buffer 都放进 bcache.buckets[0]，并初始化每个 buf 的 sleeplock 即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NBUCKET; i++) &#123;</span><br><span class="line">    initlock(&amp;bcache.bucketlocks[i], <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (b = bcache.buf; b &lt; bcache.buf+NBUF; b++) &#123;</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    b-&gt;next = bcache.buckets[<span class="number">0</span>].next;</span><br><span class="line">    bcache.buckets[<span class="number">0</span>].next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我最开始的实现中，bcache.lock 是用不上的（所以也没跑出正确答案）。但是根据 Hints：</p><p>Your solution might need to hold two locks in some cases; for example, during eviction you may need to hold the bcache lock and a lock per bucket. Make sure you avoid deadlock.</p><p>是需要上两把锁的，具体使用场景到后面再看。</p><p>由于我们现在不需要维护双向链表，在 brelse 的时候直接释放 buf 的 sleep 的 lock，然后再获取对应的 bucket 的 lock，将 refcnt– 即可，如果 refcnt &#x3D;&#x3D; 0，则将当前的 ticks 设置为 buf 的 timestamp。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> key = HASH_DEV_BLOCKNO(b-&gt;dev, b-&gt;blockno);</span><br><span class="line">  acquire(&amp;bcache.bucketlocks[key]);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">    b-&gt;timestamp = ticks;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  release(&amp;bcache.bucketlocks[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的修改 bpin 和 bunpin，这里就不贴出来了。</p><h3 id="bget"><a href="#bget" class="headerlink" title="bget"></a>bget</h3><p>整个 bget 是最折磨的地方，多线程场景下的问题还是太难发现了。</p><p>最开始我没有意识到问题的严重性，按照最初的思路，写了第一版代码，逻辑如下：</p><ol><li>获取 dev 和 blockno 对应的 bucket 的锁；</li><li>如果已经有缓存了就直接返回 buf，否则执行 3；</li><li>在所有的 bucket 中找出一个 refcnt 为 0，并且最近最久未使用的 buf。在这个过程中需要对 bucket 上锁，遍历完一个 bucket 之后，释放它的锁；</li><li>如果找到了这样的 buf，就申请它所在的 bucket 锁并进行 eviction，将它从原本的 bucket 中移除，否则直接 panic；</li><li>将找到的 buf 插入 dev 和 blockno 对应的 bucket 中，并设置 buf 的值；</li><li>释放 dev 和 blockno 对应的 bucket 的锁；</li><li>获取找到的 buf 的 sleeplock；</li><li>返回 buf；</li></ol><p>这样乍一看是没什么问题，但是事实并非如此。</p><p>首先一个容易注意到的点就是，会产生死锁。由于我们在发现没有缓存的时候，并没有释放刚刚获取的 bucket 的锁，然后就开始在所有 bucket 中找一个可以被 evict 的 buf，这时候要获取其它 bucket 的锁。那么如果一个进程 A 持有 bucket1 的锁，又去获取 bucket 2 的锁，但是进程 B 又持有 bucket2 的锁去获取 bucket1 的锁时，就产生了死锁。</p><p>所以在发现我们要找的 buf 并没有在缓存中时，要先释放当前持有的 bucket 的锁，再去进行 eviction。</p><p>第二个问题就是，当我们找到了那个可以被 evict 的 buf 时，将锁释放掉了，正式进行 evict 时，又去申请锁，但是在释放锁到重新申请锁的这个间隙，可能有其它进程又引用了刚刚找出来的那个 buf，使得它的 refcnt 不为 1，这个时候将其 evict 掉就会发生错误。</p><p>解决方案就是，在找出可以 evict 的 buf 后，不释放对应 bucket 的锁，而是直到 evict 之后再释放。那么其它进程在刚开始获取缓存的时候就会阻塞，因为它获取不到这个 bucket 的锁，待到 ecivt 结束后，它才能去查看 bucket，这时候它就看不到那个被 evict 的 buf 了。</p><p>完成以上两个修改之后，bcachetest 已经能够通过了。但是如果执行 usertests，第一个 manywrites 就无法通过，报的错误是 panic: freeing free block，即释放了一个原本已经释放的 block cache。而这种重复释放的原因，肯定就是同一个 block 被缓存了多次。</p><p>下面的思路来自于<a href="https://github.com/Miigon">Miigon</a>。</p><p>假设当前有两个进程同时访问同样缓存块，在第一个进程获取到对应的 bucket 锁后，发现不存在缓存，就释放了锁，进入寻找可 evict 的 buf 阶段。这时，第二个进程同样能够获取对应 bucket 的锁，并同样发现缓存不存在，也进入寻找可 evict 的 buf 阶段。</p><p>这个时候完全有可能发生的是，它们找到了两个不同的 buf，并且将它们 evict 掉之后都插入了它们要找的 block 对应的 bucket 中。这时就出现了同一块 block 有多个 cache 的情况。最后也就会触发 freeing free block。</p><p>这时候前文提到的那个 hint 就要回收了，再看一遍：</p><p>Your solution might need to hold two locks in some cases; for example, during eviction you may need to hold the bcache lock and a lock per bucket. Make sure you avoid deadlock.</p><p>再结合前一条：</p><p>It is OK to serialize eviction in bget (i.e., the part of bget that selects a buffer to re-use when a lookup misses in the cache).</p><p>现在想想其实就是暗示我们在寻找并 evict 可用 buf 的时候将整个流程串行化，保留最开始查看是否有缓存的并行。并且缓存丢失的概率一般来说都是非常低的，所以后面的串行化造成的性能损失其实是可以接受的。</p><p>所以现在利用上 bcache.lock，在发现缓存不存在释放掉对应 bucket 的锁之后，立刻获取 bcache.lock 这把大锁。由于在释放对应 bucket 锁到获取 bcache.lock 期间，可能有别的进程已经完成了对我们要找的 block 设置 cache，所以在获取完 bcache.lock 后，再进行一次查找缓存，如果发现已经存在了，就直接返回对应的 buf。</p><p>这样一来，就算有多个进程同时进入 bget，也只有第一个进程可以获取到 bcache.lock，并完成缓存的设置，后面的进程都会被获取完锁后的第二轮查找缓存给拦住。这样就避免了一个 block 被缓存多次。</p><p>下面是完整的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> key = HASH_DEV_BLOCKNO(dev, blockno);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.bucketlocks[key]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span> (b = bcache.buckets[key].next; b; b = b-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno) &#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;bcache.bucketlocks[key]);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;bcache.bucketlocks[key]);</span><br><span class="line">  <span class="comment">// 一定要先释放再去获取 bcache.lock</span></span><br><span class="line">  <span class="comment">// 否则如果另一个进程持有 bcache.lock，再在下面获取 bucketlocks[key] 就会死锁  </span></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (b = bcache.buckets[key].next; b; b = b-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno) &#123;</span><br><span class="line">      acquire(&amp;bcache.bucketlocks[key]);</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;bcache.bucketlocks[key]);</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached.</span></span><br><span class="line">  <span class="type">int</span> i, bidx = <span class="number">-1</span>, flag = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">tmp</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NBUCKET; i++) &#123;</span><br><span class="line">    acquire(&amp;bcache.bucketlocks[i]);</span><br><span class="line">    <span class="keyword">for</span> (b = &amp;bcache.buckets[i]; b-&gt;next; b = b-&gt;next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (b-&gt;next-&gt;refcnt == <span class="number">0</span> &amp;&amp; (!tmp || b-&gt;next-&gt;timestamp &gt; tmp-&gt;next-&gt;timestamp)) &#123;</span><br><span class="line">          tmp = b;</span><br><span class="line">          flag = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">      release(&amp;bcache.bucketlocks[i]); <span class="comment">// 如果没有找到 buf 就释放锁</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果找到了新 buf，那就释放之前找到的 buf 的 bucket 锁，并保留当前 bucket 的锁</span></span><br><span class="line">      flag = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (bidx != <span class="number">-1</span>) release(&amp;bcache.bucketlocks[bidx]);</span><br><span class="line">      bidx = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">    panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  b = tmp-&gt;next;</span><br><span class="line">  tmp-&gt;next = b-&gt;next;</span><br><span class="line">  release(&amp;bcache.bucketlocks[bidx]); <span class="comment">// 进行 evict 后再释放锁</span></span><br><span class="line">  </span><br><span class="line">  acquire(&amp;bcache.bucketlocks[key]);</span><br><span class="line">  b-&gt;next = bcache.buckets[key].next;</span><br><span class="line">  bcache.buckets[key].next = b;</span><br><span class="line">  b-&gt;dev = dev;</span><br><span class="line">  b-&gt;blockno = blockno;</span><br><span class="line">  b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">  b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">  release(&amp;bcache.bucketlocks[key]);</span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">  acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3a5f446f27d4dd1ac4690c109f64f29~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>多线程场景下的问题真的很难搞，感觉在业务场景下，用一些常见的模式还没有那么难。到系统编程的场景下，这些问题都要自己考虑，解决一个问题之后可能又产生另一个问题，我自己对于这方面的能力还是太弱了。</p><p>引用一下<a href="https://github.com/Miigon">Miigon</a>大佬的总结：</p><blockquote><p>锁竞争优化一般有几个思路：</p><ul><li>只在必须共享的时候共享（对应为将资源从 CPU 共享拆分为每个 CPU 独立）</li><li>必须共享时，尽量减少在关键区中停留的时间（对应“大锁化小锁”，降低锁的粒度）</li></ul></blockquote><p>第一种思路就是本次 lab 的第一部分，只有当前 CPU 的 freelist 已经为空时，才去和其它的 CPU 共享 freelist，其它情况下都是并行执行的。</p><p>第二种思路就是本次 lab 的第二部分，bcache 是没有办法单独划分给每个 CPU 的，属于必须共享，所以只能通过缩小临界区，缩小锁的粒度来实现。</p><p>后续这方面还是得多多加强。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab7: Multithreading</title>
      <link href="/post/9662ca7f.html"/>
      <url>/post/9662ca7f.html</url>
      
        <content type="html"><![CDATA[<p>本次实验要实现用户级线程之间的切换，使用多线程来加速程序，并实现屏障。</p><p>在听课的时候感觉这次实验是要实现内核级线程，让一个进程中的多个线程可以同时运行在多个 CPU 上面，感觉有点害怕。不过看实验说明书的时候才知道是实现的用户级线程，其实应该叫做协程，而且很多代码都已经给出来了，做之前要读一遍 user&#x2F;uthread.c。每个用户线程对应一个内核线程是 Optional chanllenge 部分的任务了，有时间再做吧。这样一来本次的实验还是很简单的。</p><h2 id="Uthread-switching-between-moderate"><a href="#Uthread-switching-between-moderate" class="headerlink" title="Uthread: switching between (moderate)"></a>Uthread: switching between (moderate)</h2><p>这部分是实现用户级线程的切换。在课上教授已经讲过了内核级线程是如何切换的了。大部分内容都可以借鉴。</p><p>在切换线程时，要把当前运行线程的 callee registers 保存下来。</p><p>thread_switch needs to save&#x2F;restore only the callee-save registers.</p><p>我对这里的理解是，用户级线程的切换一定是手动调用 thread_schedule 然后调用 thread_switch 进行切换的。所以对用户级线程来说，恢复现场就是在之前调用 thread_switch 函数后调用 ret 返回到 thread_schedule 函数中，那么由于 C 编译器会在调用函数的时候把 caller registers 保存在线程的栈上，所以我们只需要记下 ra 来定位返回的位置，还有 sp 指出线程栈的位置，并且把所有的 callee register 保存即可（跟内核级线程的切换 Context 是一样的）。</p><p>这部分要做得任务只有两个，在 thread_create 函数中添加代码。要做到线程的切换，我们必须初始化它的 ra 和 sp，这样才可以使得其它线程调用 thread_switch 通过 ret 返回跳到 ra 所在位置执行。在创建的时候设置 ra 和 sp 相当于伪造一个执行现场，返回到那里。</p><p>我选择是直接把寄存器存在 thread 结构体中，这样可以直接把 swtch.S 里的内容复制过来就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">    uint64     ra;</span><br><span class="line">    uint64     sp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// callee saved</span></span><br><span class="line">    uint64     s0;</span><br><span class="line">    uint64     s1;</span><br><span class="line">    uint64     s2;</span><br><span class="line">    uint64     s3;</span><br><span class="line">    uint64     s4;</span><br><span class="line">    uint64     s5;</span><br><span class="line">    uint64     s6;</span><br><span class="line">    uint64     s7;</span><br><span class="line">    uint64     s8;</span><br><span class="line">    uint64     s9;</span><br><span class="line">    uint64     s10;</span><br><span class="line">    uint64     s11;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>       <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/* the thread&#x27;s stack */</span></span><br><span class="line">    <span class="type">int</span>        state;             <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将线程的 ra 初始化为 func 的起始地址，并且设置线程栈。注意栈是从高地址扩展到低地址的，所以初始化的时候应该将指针指向栈的最高地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">thread_create</span><span class="params">(<span class="type">void</span> (*func)())</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  t-&gt;ra = (uint64)func;</span><br><span class="line">  t-&gt;sp = (uint64)t-&gt;<span class="built_in">stack</span> + STACK_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 thread_schedule 调用 thread_switch 就可以了。注意 t 才是当前线程，而 current 是要被调度的线程。</p><h2 id="Using-threads-moderate"><a href="#Using-threads-moderate" class="headerlink" title="Using threads (moderate)"></a>Using threads (moderate)</h2><p>这部分跟 xv6 无关了，就是用 pthread + lock 来控制并发访问一个 hash table。</p><p>先看一下 hash table 的实现。本质上是一个 entry 类型的数组，里面有 NBUCKET 个链表，key 通过摸 NBUCKET 来决定插入到哪个链表的表头。</p><p>所以回答第一个问题：</p><p>Why are there missing keys with 2 threads, but not with 1 thread? Identify a sequence of events with 2 threads that can lead to a key being missing.</p><p>当两个线程同时调用 insert 函数的时候，两个线程看到的链表头都是同一个，那么在插入的时候，后插入的会把先插入的给覆盖掉。</p><p>然后是实现并发控制，其实就是给每个 bucket 都分配一把锁，这样不同的线程在访问不同的 bucket 的时候就可以并发执行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> bucketlocks[NBUCKET]; <span class="comment">// 声明锁</span></span><br></pre></td></tr></table></figure><p>在 main 函数中调用 pthread_mutex_init 进行初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; i++) &#123;</span><br><span class="line">    pthread_mutex_init(&amp;bucketlocks[i], <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 put 中上锁即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = key % NBUCKET;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// is the key already present?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(e)&#123;</span><br><span class="line">    <span class="comment">// update the existing key.</span></span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// the new is new.</span></span><br><span class="line">    pthread_mutex_lock(&amp;bucketlocks[i]);</span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">    pthread_mutex_unlock(&amp;bucketlocks[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Barrier-moderate"><a href="#Barrier-moderate" class="headerlink" title="Barrier (moderate)"></a>Barrier (moderate)</h2><p>这部分要通过 pthread_cond 来实现一个 barrier。关于 barrier 和 waitgroup 的区别：</p><p>屏障是一种同步原语，它会阻止多个线程或 goroutine 的运行，直到它们都到达某个点，在该点它们都被同时释放。 屏障可用于确保仅在所有线程完成其<strong>计算的特定阶段</strong>后才执行某些操作。</p><p>另一方面，WaitGroup 是一种同步原语，用于等待一组 goroutine 完成它们的执行，然后再继续。 WaitGroup 用一个计数初始化，每个 goroutine 在开始工作之前递增计数，并在完成时递减计数。 主线程（或另一个 goroutine）在 WaitGroup 上等待，直到计数达到零，这表明所有 goroutine 都已完成。 这允许主线程与并行任务的完成同步。</p><p>直接实现 barrier 函数即可。需要注意的是 barrier 函数也可能出现竞态。比如说线程 1 进入 barrier，将 bstate.nthread 加 1，然后比较一下还没有达到 nthread，正打算休眠，结果线程 2 进入 barrier，将 bstate.nthread 加 1，比较一下发现已经达到了 nthread，于是执行了一次唤醒操作，接着线程 1 又休眠了，那么线程 1 无法被唤醒，下一轮也就永远无法到达 nthread 了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">barrier</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">  <span class="comment">// then increment bstate.round.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">  bstate.nthread++;</span><br><span class="line">  <span class="keyword">if</span> (bstate.nthread &lt; nthread) &#123;</span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    bstate.nthread = <span class="number">0</span>;</span><br><span class="line">    bstate.round++;</span><br><span class="line">    pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以通过上锁将增加 bstate.nthread++、比较、休眠或唤醒合成一个原子操作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次 lab 由于跟 xv6 相关的部分只有一个，并且跟教授上课讲得内核级线程的切换几乎一样，只是省去了先切换到调度线程这一步，所以实现起来很简单。后续有时间可以回来实现一下内核级线程。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab6: Copy-on-Write Fork for xv6</title>
      <link href="/post/b1b06482.html"/>
      <url>/post/b1b06482.html</url>
      
        <content type="html"><![CDATA[<p>lab6 是实现 COW fork，在 fork 子进程的时候不直接将父进程的物理内存复制给子进程，而是只复制页表，并且把双方 PTE 设置为只读的。在进程需要进行写操作的适合，会触发 page fault，处理 page fault 的时候再复制一份内存，映射给进程，然后把 PTE 重新映射并且修改为可读写。</p><p>COW 能够节约复制的时间，只复制要修改的 page，并且可以很大程度上避免复制完后调用 exec 的浪费。</p><h2 id="Implement-copy-on-write-hard"><a href="#Implement-copy-on-write-hard" class="headerlink" title="Implement copy-on write (hard)"></a>Implement copy-on write (hard)</h2><p>Your task is to implement copy-on-write fork in the xv6 kernel. You are done if your modified kernel executes both the cowtest and usertests programs successfully.</p><p>首先来实现 reasonable plans 中的第三点，修改 kernel&#x2F;kalloc.c。因为实现 COW 之后，就会存在多个进程引用同一个 page 的情况，所以当进程退出，要释放内存的时候不能直接释放，而是要看还有没有别的进程在引用该 page。</p><p>我们需要用一个计数器来记录每个 page 的引用数量，只有当引用数为 0 的时候才能释放。当调用 kernel&#x2F;kalloc.c#kalloc 函数的时候，将这个新分配的 page 的引用计数设置为 1。当调用 kernel&#x2F;kalloc.c#kfree 函数的时候，将需要释放的 page 的引用计数减 1，引用计数为 0 的时候释放物理内存。当执行 fork 系统调用的时候，在复制 page 的映射时，将 page 的引用计数加 1。</p><p>添加以下全局变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... kalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">pincountlock</span>;</span> <span class="comment">// 锁住计数器，防止发生竞态，记得在 kinit 中初始化锁</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pincounts[<span class="number">32768</span>]; <span class="comment">// 每个页的引用计数器</span></span><br></pre></td></tr></table></figure><p>再实现以下函数，用以操作 page 的引用计数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pa 转化成计数器的下标</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pa2pincount</span><span class="params">(uint64 pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (pa - KERNBASE) / PGSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对应 page 的引用计数加 1</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pin</span><span class="params">(uint64 pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  pa = PGROUNDUP(pa);</span><br><span class="line">  acquire(&amp;pincountlock);</span><br><span class="line">  <span class="keyword">if</span> (pincounts[pa2pincount(pa)] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    pincounts[pa2pincount(pa)]++; </span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;pincountlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对应 page 的引用计数减 1</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">unpin</span><span class="params">(uint64 pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  pa = PGROUNDUP(pa);</span><br><span class="line">  acquire(&amp;pincountlock);</span><br><span class="line">  <span class="keyword">if</span> (pincounts[pa2pincount(pa)] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    pincounts[pa2pincount(pa)]--;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;pincountlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 kalloc 和 kfree 函数，加上对引用计数的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  unpin((uint64)pa);</span><br><span class="line">  acquire(&amp;pincountlock);</span><br><span class="line">  <span class="keyword">if</span> (pincounts[pa2pincount((uint64)pa)] != <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;pincountlock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;pincountlock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">    uint64 pa = (uint64) r;</span><br><span class="line">    pincounts[pa2pincount(pa)] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 kernel&#x2F;vm.c#uvmcopy() 函数，让它不实际复制内存，而是复制一下页表，并且把父子进程的 W 位置为 0。并且我们需要在 PTE 中的 flags 中选择一位用作 COW 标识。我这里选择的是 RSW 的低位。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/811e09570d6b4b35a6a5dfaf99d8a508~tplv-k3u1fbpfcp-zoom-1.image"></p><p>我在 riscv.h 中定义了一个宏来方便计算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_COW (1L &lt;&lt; 8)</span></span><br></pre></td></tr></table></figure><p>我直接将 lab3 写过的复制页表的函数复制过来，稍微做了一些修改，然后在原本复制内存的函数中调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> uvmcopypg(old, new, sz, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopypg</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">pagetable_t</span> npagetable, uint64 sz, uint64 start)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = PGROUNDUP(start); i &lt; sz; i+=PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopypg: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopypg: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    *pte &amp;= ~PTE_W; <span class="comment">// 将 W 位置为 0</span></span><br><span class="line">    *pte |= PTE_COW; <span class="comment">// 将 COW 位置为 1</span></span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="keyword">if</span>(mappages(npagetable, i, PGSIZE, pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    pin(pa); <span class="comment">// 映射成功，将这一页的引用计数加 1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  err:</span><br><span class="line">  uvmunmap(npagetable, PGROUNDUP(start), (i - PGROUNDUP(start)) / PGSIZE, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来实现一个 page fault handler 来处理 COW fork page fault，在这个函数中进行一些判断看能否处理这个 page fault，如果不行就返回 -1，否则返回 1，用于在 usertrap 中杀死进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">cowhandler</span><span class="params">(uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint flags; </span><br><span class="line">  va = PGROUNDDOWN(va);</span><br><span class="line">  <span class="keyword">if</span> (va &gt;= MAXVA) &#123; <span class="comment">// 测试 copyout 的时候 walk 中爆了 panic，va 存在大于 MAXVA 的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pte = walk(p-&gt;pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// va 必须在 heap 中，并且对应的 pte 必须存在且有效，同时 COW 位应该是 1</span></span><br><span class="line">  <span class="keyword">if</span> (va &gt;= p-&gt;sz || ((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) == <span class="number">0</span>) || (*pte &amp; PTE_COW) == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  uint64 pa = PTE2PA(*pte); <span class="comment">// 将旧 page 的地址取出用于复制</span></span><br><span class="line">  uint64 ka = (uint64) kalloc();   <span class="comment">// 分配新的 page</span></span><br><span class="line">  <span class="keyword">if</span> (ka == <span class="number">0</span>) &#123; <span class="comment">// hints 中说如果没有内存可以分配了就杀死进程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  memmove((<span class="type">void</span> *)ka, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">  <span class="comment">// 将标识设置为可写，并去掉 COW 标识</span></span><br><span class="line">  flags = PTE_FLAGS(*pte);</span><br><span class="line">  flags &amp;= ~PTE_COW;</span><br><span class="line">  flags |= PTE_W;</span><br><span class="line">  uvmunmap(p-&gt;pagetable, va, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 在取消映射时会调用 kfree，这里不用调用 unpin</span></span><br><span class="line">  <span class="keyword">if</span> (mappages(p-&gt;pagetable, va, PGSIZE, ka, flags)) &#123;</span><br><span class="line">    kfree((<span class="type">void</span> *) ka);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟 lazy allocation 一样，需要在 usertrap 中调用 page fault handler 来处理 page fault。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ... usertrap</span></span><br><span class="line">  intr_on();</span><br><span class="line"></span><br><span class="line">  syscall();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) &#123;</span><br><span class="line">  uint64 va = r_stval();</span><br><span class="line">  <span class="keyword">if</span> (cowhandler(va) == <span class="number">-1</span>) &#123; <span class="comment">// 调用 cowhandler 返回值为 -1 就杀死进程</span></span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">  p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后只需要在 copyout 中调用 cowhandler 函数来处理 dstva 指向的是 on-demand page 的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    cowhandler(dstva);</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>lab6 只有一个部分，任务指导书也讲得非常清楚，实现起来不是很难。我在做得时候由于一开始没有对 pincount 上锁，导致发生竞态卡了不少时间。</p><p>到这个 lab 应该就是虚拟内存系列 lab 的最后一个了，感觉还是 lab3 是最为困难的，在写完 lab3 之后对整个 xv6 就会有一定的理解了，对操作虚拟内存也会更加熟悉，做后面这几个就没有那么困难了。</p><p>对于 page table、traps、page fault 有了较为深入的理解，收获很大。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab5: xv6 lazy page allocation</title>
      <link href="/post/32a9d8d3.html"/>
      <url>/post/32a9d8d3.html</url>
      
        <content type="html"><![CDATA[<p>xv6 中 sbrk 的实现默认是 eager allocation，也就是一旦用户进程申请了内存，那么内核马上就会分配。但实际上，用户进程难以估量自己需要多少内存，所以往往会额外申请，导致内存消耗增加，并且有部分内存永远不会被用到。</p><p>所以可以用 lazy page allocation 来解决这个问题，sbrk 只用来记住分配了哪些用户地址（即更新 sz），而不先分配内存，直到产生了 page fault 再分配内存。</p><h2 id="Lazytests-and-Usertests"><a href="#Lazytests-and-Usertests" class="headerlink" title="Lazytests and Usertests"></a>Lazytests and Usertests</h2><p>partⅠ和 partⅡ 的话，Frans 教授在课上讲过了，这里就不重复了。partⅢ 就是实现 Frans 教授说的要对 xv6 做进一步的修改，这些修改都已经写在 Hints 中了：</p><ol><li>处理 sbrk 的参数为负数的情况；</li><li>如果发生 page fault 的地址比 sbrk 分配的地址还大的时候，杀死进程；</li><li>处理用户进程通过系统调用传递了一个正确的地址，但是这个地址还没有被分配内存的情况（即修改copyin 和 copyout 等函数）。</li><li>如果发生 page fault 后没有可用内存了，杀死进程；</li><li>如果发生 page fault 的地址访问到了 guard page，杀死进程。</li></ol><p>第一个要修改的地方在 kernel&#x2F;sysproc.c#sys_sbrk 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    myproc()-&gt;sz = myproc()-&gt;sz + n; <span class="comment">// just add sz, but not allocate memory.</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    myproc()-&gt;sz = uvmdealloc(myproc()-&gt;pagetable, myproc()-&gt;sz, myproc()-&gt;sz + n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前两个部分中，我们在 kernel&#x2F;trap.c#usertrap 中添加了代码，那么对它进行进一步的修改，添加了一个 pgfhandler 函数，用来处理指定虚拟地址发生的 page fault：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="comment">// ok</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">15</span> || r_scause() == <span class="number">13</span>) &#123;</span><br><span class="line">  <span class="comment">// load page fault or store page fault</span></span><br><span class="line">  uint64 va = r_stval(); <span class="comment">// va is the address that cause the page fault</span></span><br><span class="line">  <span class="keyword">if</span> (pgfhandler(va) == <span class="number">-1</span>) &#123; <span class="comment">// if can&#x27;t handle the page fault, kill the process</span></span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">  p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中，我们判断是否能够进行 page fault handle，如果不行就杀死这个进程。做了以下判断：</p><ol><li>该虚拟地址是否在堆中；</li><li>该虚拟地址是否访问到了 guard page；</li><li>是否还有物理内存可以分配；</li><li>新分配的页是否已经映射了，防止报 remap。</li></ol><p>如果可以处理，那么就进行处理，否则返回 0，在 usertrap 中将 p-&gt;killed 标识为 1（如果在这里面标识为 1 的话会杀死初始进程）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pgfhandler</span><span class="params">(uint64 va)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span> (va &gt;= p-&gt;sz || PGROUNDUP(va) == p-&gt;kstack) &#123;</span><br><span class="line">    <span class="comment">// if va is a invalid address, kill the process.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    uint64 ka = (uint64) kalloc();</span><br><span class="line">    <span class="keyword">if</span> (ka == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// if there is no memory can use, kill the process.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">memset</span>((<span class="type">void</span> *) ka, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      va = PGROUNDDOWN(va);</span><br><span class="line">      <span class="type">pte_t</span> * pte;</span><br><span class="line">      <span class="comment">// avoid remap panic.</span></span><br><span class="line">      <span class="keyword">if</span> ((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) != <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_V) != <span class="number">0</span>) &#123;</span><br><span class="line">        kfree((<span class="type">void</span> *) ka);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// map new page above.</span></span><br><span class="line">      <span class="keyword">if</span>(mappages(p-&gt;pagetable, va, PGSIZE, ka, PTE_W|PTE_U|PTE_R) != <span class="number">0</span>) &#123;</span><br><span class="line">        kfree((<span class="type">void</span> *) ka);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意要把 kernel&#x2F;vm.c#uvmunmap 和 kernel&#x2F;vm.c&#x2F;uvmcopy 函数中的 panic 去掉，直接 continue 即可，因为使用了 lazy allocation 之后，在 unmap 的时候会出现 walk 不出来或者本来就没有 map 的情况，不能 panic，在 uvmcopy 的时候也会出现 walk 不出来，或者复制到了一个无效的 pte。代码就不贴出来了。</p><p>最后一步，修改 kernel&#x2F;vm.c#copyin, kernel&#x2F;vm.c#copyinstr, kernel&#x2F;vm.c#copyout，将需要访问的用户空间地址做一个预处理，也就是调用 pgfhandler 先进行一波缺页处理，否则这些函数可能访问到没有分配的内存。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次 lab 相对简单，尤其是 Frans 教授上课已经把前两部分讲了，也很详细的讲了 page fault 是如何处理的。就是有一些细节要注意，我最开始就没想到要处理 copyin 和 copyout。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab4: Traps</title>
      <link href="/post/282c8539.html"/>
      <url>/post/282c8539.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>This lab explores how system calls are implemented using traps. You will first do a warm-up exercises with stacks and then you will implement an example of user-level trap handling.</p></blockquote><p>lab4 相对 lab3 要简单很多，需要写的代码行数不多，并且给的 hints 也很直接。只要听了 lecture 5 和 lecture 6 都能够明白其中的原理。这两次课分别讲了 xv6 的栈结构跟 trap 的一些细节。</p><h2 id="RISC-V-assembly-easy"><a href="#RISC-V-assembly-easy" class="headerlink" title="RISC-V assembly (easy)"></a>RISC-V assembly (easy)</h2><p>就是去看 user&#x2F;call.c 和 user&#x2F;call.asm 中的函数 g, f, main，然后回答一些问题。我没有看 RISC-V 的手册，太长了有点不好搜索。有不懂的指令去 Google 一下反而还方便一点。这边就直接贴出答案了，第三题的答案可能会不一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Q: Which registers contain arguments to functions? For example, which register holds 13  in main&#x27;s call to printf?</span><br><span class="line">A: a0-a7. a2.</span><br><span class="line"></span><br><span class="line">Q: Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)</span><br><span class="line">A: Function f and g are inlined by the compiler.</span><br><span class="line"></span><br><span class="line">Q: At what address is the function printf located?</span><br><span class="line">A: 0x630.</span><br><span class="line"></span><br><span class="line">Q: What value is in the register ra just after the jalr to printf in main?</span><br><span class="line">A: 0x38.</span><br><span class="line"></span><br><span class="line">Q: ...</span><br><span class="line">A: Set i to 0x726c6400. Do not need to modify 57616, because it&#x27;s decimal value is just  110. Little- or big-endian is no matter with values.</span><br><span class="line"></span><br><span class="line">Q: ...</span><br><span class="line">A: It will read the value set in register a2 by the previous function.</span><br></pre></td></tr></table></figure><h2 id="Backtrace-moderate"><a href="#Backtrace-moderate" class="headerlink" title="Backtrace (moderate)"></a>Backtrace (moderate)</h2><p>这部分是实现一个类似于 gdb 的 backtrace，打印函数调用栈帧中的返回地址。在 kernel&#x2F;printf.c 中添加一个 backtrace() 函数，然后在 sys_sleep 中调用 进行测试。</p><p>要实现 backtrace 首先要理解 xv6 的函数栈帧结构，根据老师上课的 ppt：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a608d22b3c5e44a19680ade600fcf85d~tplv-k3u1fbpfcp-zoom-1.image"></p><p>可以看到，函数栈帧之间其实就像一个链表，被 fp 指针给连接到一起，所以我们只需要拿到当前函数的 fp，就可以一直遍历整个函数调用链。当前的 fp 被存放在 s0 寄存器中。在 kernel&#x2F;risv.h 中添加以下函数来取出 s0 中的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_fp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在栈中，函数的返回地址固定在 fp - 8 的位置，调用该函数的函数的 fp 在 fp - 16 的位置。我们一直遍历到这一页结束就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 fp, ra, last;</span><br><span class="line">  fp = r_fp();</span><br><span class="line">  last = PGROUNDUP(fp);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    ra = fp<span class="number">-8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *((uint64 *)(ra)));</span><br><span class="line">    fp = *((uint64 *)(fp<span class="number">-16</span>));</span><br><span class="line">    <span class="keyword">if</span> (fp == last) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Alarm-hard"><a href="#Alarm-hard" class="headerlink" title="Alarm (hard)"></a>Alarm (hard)</h2><p>这部分就是有难度的地方了。要实现一个用户级的中断，用户程序通过调用 sigalarm(interval, handler) 系统调用来设置一个计时器，每隔 interval 个 tick，就调用 handler 函数进行处理。并且在 handler 函数返回之后，会调用 sigreturn() 函数，被中断的用户程序要正常恢复执行，也就是说对于被中断的用户程序来说 alarm handler是透明的。</p><p>每次在收到 timer 硬件发出的中断时，就是一个 tick，它不是一个确定的时间单位。而 timer interrupt 会触发 trap，所以可以知道 alarm handler 是要在 trap 中触发的，类似于在 trap 中又套了一层 trap。</p><p>我们需要在 struct proc 结构体中添加一些新的属性来保存触发 handler 的间隔，handler 函数指针，距离上次调用 handler 过去了几个 tick，当前是否有 handler 在执行，以及一个 struct trapframe 用来保存被打断的程序的寄存器值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... struct proc</span></span><br><span class="line"><span class="type">int</span> ticks;                   <span class="comment">// Alarm ticks</span></span><br><span class="line"><span class="type">void</span> (*handler)();           <span class="comment">// Alarm handler</span></span><br><span class="line"><span class="type">int</span> passedticks;             <span class="comment">// Record how many ticks passed</span></span><br><span class="line"><span class="type">int</span> isrunninghandler;        <span class="comment">// Avoid re-entrant calls to a handler</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">savedtf</span>;</span>   <span class="comment">// Save trapframe when call handler</span></span><br></pre></td></tr></table></figure><p>ticks、handler、passedticks 在 sigalarm 系统调用中设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="type">int</span> ticks;</span><br><span class="line">  uint64 handler;</span><br><span class="line">  <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;ticks) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">1</span>, &amp;handler) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  p-&gt;ticks = ticks;</span><br><span class="line">  p-&gt;handler = (<span class="type">void</span> (*)()) handler;</span><br><span class="line">  p-&gt;passedticks = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在 kernel&#x2F;trap.c#usertrap 中处理 timer interrupt。当 which_dev &#x3D; 2 的时候，表明是 timer interrupt。</p><p>由于执行完 handler 之后，需要回到被中断的程序继续执行，所以在这里要将这个程序的状态保存下来，在 sigreturn 系统调用中恢复。我这里图方便就直接将所有的寄存器和状态都保存下来了。保存完状态后，<strong>将 p-&gt;trapframe-&gt;epc 的值设置为 handler 的地址</strong>。usertrap 会调用 usertrapret，usertrapret 会将 p-&gt;trapframe-&gt;epc 设置到 spec 寄存器中，userret 在返回时调用 sret 指令会将 sepc 寄存器中的值设置到 pc 中，所以用户程序就会跳到 handler 中去执行了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// ok</span><br><span class="line">if (which_dev == 2 &amp;&amp; p-&gt;ticks != 0) &#123;</span><br><span class="line">  p-&gt;passedticks++;</span><br><span class="line">  // if there is no handler running and it&#x27;s time to call handler</span><br><span class="line">  if (p-&gt;passedticks == p-&gt;ticks &amp;&amp; p-&gt;isrunninghandler == 0) &#123;</span><br><span class="line">    p-&gt;isrunninghandler = 1;</span><br><span class="line">    // save trapframe</span><br><span class="line">    memmove(p-&gt;savedtf, p-&gt;trapframe, sizeof(struct trapframe));</span><br><span class="line">    p-&gt;trapframe-&gt;epc = (uint64) p-&gt;handler;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 handler 程序执行完后，在测试中就是 periodic 函数，其中会调用 sigreturn，在这里面回复原来的函数的执行。</p><p>首先将 passedticks 重置，以便下一轮触发，然后将 isrunninghandler 置 0，表示没有在执行的 handler，然后将保存在 savedfp 中的寄存器值都重新写入 trapframe 中，接着调用 usertrapret 将寄存器的值都恢复，就像从 trap 中恢复出来一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  p-&gt;passedticks = <span class="number">0</span>;</span><br><span class="line">  p-&gt;isrunninghandler = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// Restore trapframe</span></span><br><span class="line">  memmove(p-&gt;trapframe, p-&gt;savedtf, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">  <span class="comment">// Restore registers when usertrapret calls userret, and userret calls sret to back to the interrupted code.</span></span><br><span class="line">  usertrapret();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次的 lab 其实就像老师喂饼一样，看过 lecture5&#x2F;6 之后，再把 xv6 book Chapter4 看完，其中的原理肯定会明白，然后就是一些小细节可能会为难一点（C 语言不太好的甚至会被语法为难😭），其它难点不多，但是确实对 trap 有深入的理解。Robert 我的神！</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab3: Page Table</title>
      <link href="/post/b51235b3.html"/>
      <url>/post/b51235b3.html</url>
      
        <content type="html"><![CDATA[<p>lab3 属实是重量级，折磨了我好长时间。做 lab3 之前一定一定一定要先仔细的看 <a href="https://pdos.csail.mit.edu/6.S081/2020/xv6/book-riscv-rev1.pdf">xv6 book</a> 和<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/pgtbl.html">任务指导书</a>，不然就是无头苍蝇乱碰了。</p><p>同时还有 kernel&#x2F;memlayout.h、kernel&#x2F;vm.c、kernel&#x2F;kalloc.c 都需要认真看看相关代码。</p><p>Lab3 就是要给每一个进程都添加一个自己的内核页表，并且把用户页表中的映射给复制进去，在进程进入内核态之后，可以使用进程中的内核页表，通过硬件来进行寻址。在实现这个 lab 之前，xv6 只能从用户态传入一个地址，但是这个地址在内核中是无法使用的，因为内核页表中没有这个映射，所以只能通过软件模拟 MMU 来进行寻址，效率不高。</p><h2 id="Print-a-page-table-easy"><a href="#Print-a-page-table-easy" class="headerlink" title="Print a page table (easy)"></a>Print a page table (easy)</h2><p>任务书上说是可以帮助后面的 debug，但是我没有用到。不过可以做到对于 xv6 的页表有一个初步的认识。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33074b82b5b04df996bdf0c4f9f0aed6~tplv-k3u1fbpfcp-zoom-1.image"></p><p>xv6 的页表如上图所示。在 CPU 的 satp 寄存器中存储了第二层页表的物理地址，它里面存储了 512 条 PTE（page table entry），每条 PTE 的高 44 位 PPN 用于计算出下一层页表的物理地址或者拼接出存储数据的物理地址。一条虚拟地址被分成了 L2、L1、L0 各 9 bit，对应着三层页表，分别指出三层页表中的 PTE。还有 offset，占 12 bit，用于和第 0 层的 PPN 拼接得到数据的物理地址。</p><p>所以要打印这个页表，我们就要从第二层开始，逐层遍历 PTE 并打印，然后取出下一层的页表开始遍历打印，直到最低层。</p><p>pagetable_t 其实就是一个 uint64 类型的指针，其实也就是一个数组，数组中有 512 个元素对应 512 条 PTE，进行遍历的过程中要判断 PTE 是否有效，无效就不打印，还要判断 PTE 是否指向下一层的页表，如果是就将 PTE 转化成下一层页表的物理地址，递归到下一层进行打印，否则就直接打印。根据任务指导书，具体如何判断 PTE 参考 kernel&#x2F;vm.c#freewalk 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_vmprint(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level) &#123;</span><br><span class="line">  <span class="keyword">if</span> (level == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> (pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="keyword">if</span> (level != <span class="number">0</span> &amp;&amp; !((pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="number">0</span>)) <span class="keyword">continue</span>;</span><br><span class="line">      uint64 pa = PTE2PA(pte);</span><br><span class="line">      <span class="type">int</span> j;</span><br><span class="line">      <span class="keyword">for</span> (j = level; j &lt;= <span class="number">2</span>; j++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">2</span>) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;.. &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, pa);</span><br><span class="line">      _vmprint((<span class="type">pagetable_t</span>) pa, level<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  _vmprint(pagetable, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="A-kernel-pagetable-per-process-hard"><a href="#A-kernel-pagetable-per-process-hard" class="headerlink" title="A kernel pagetable per process (hard)"></a>A kernel pagetable per process (hard)</h2><p>xv6 中，每个进程都有一个自己的用户空间页表，这个页表只包含该进程的用户地址空间的映射。在内核中有一个单独的内核页表，所有的进程进入内核态后，都是用的是这个内核页表。<strong>所以用户地址在内核中是无法使用的，因为内核页表中没有对该地址的映射</strong>，<strong>只能通过 walk 来模拟 MMU 将用户虚拟地址再转化为物理地址使用。</strong></p><p>所以部分的任务就是给每个进程都弄一个自己的内核页表，并且在下个部分将用户空间页表中的映射复制到自己的内核页表中，这样在进入内核态的时候就可以直接使用这些映射了。</p><p>首先，我们在 strcut proc 中添加一个 kpagetable 变量来存储内核页表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pagetable_t</span> kpagetable;      <span class="comment">// Process&#x27;s kernel pagetable</span></span><br></pre></td></tr></table></figure><p>我们需要在创建进程的时候给他复制一份内核页表，内核页表是通过 kernel&#x2F;vm.c#kvminit 初始化，在其中使用 kernel&#x2F;vm.c#kvmmap 进行一些映射，我们需要修改版的 kvminit 函数和 kvmmap 函数来对进程的内核页表进行修改。因为这两个函数只是针对全局的 kernel_pagetable，没办法传参数。照着写就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ukvmmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;ukvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_kpagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line">  pagetable = uvmcreate();</span><br><span class="line">  <span class="keyword">if</span> (pagetable == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  ukvmmap(pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  ukvmmap(pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CLINT</span></span><br><span class="line">  ukvmmap(pagetable, CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  ukvmmap(pagetable, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  ukvmmap(pagetable, KERNBASE, KERNBASE, (uint64) etext - KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  ukvmmap(pagetable, (uint64) etext, (uint64) etext, PHYSTOP - (uint64) etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  ukvmmap(pagetable, TRAMPOLINE, (uint64) trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在 kernel&#x2F;proc.c#allocproc 中调用上述函数来初始化进程的内核页表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... kernel/proc.c#allocproc</span></span><br><span class="line">p-&gt;kpagetable = proc_kpagetable(p);</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;kpagetable == <span class="number">0</span>) &#123;</span><br><span class="line">  freeproc(p);</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照任务说明书，我们需要将进程的内核栈映射到内核页表中，原本内核栈的初始化是在 kernel&#x2F;proc.c#procinit 中，现在我们将内核栈放在 allocproc 中来分配，就跟在内核页表初始化之后。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... kernel/proc.c#allocproc</span></span><br><span class="line"><span class="type">char</span> *pa = kalloc();</span><br><span class="line"><span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">  panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">uint64 va = KSTACK((<span class="type">int</span>) (p - proc));</span><br><span class="line">ukvmmap(p-&gt;kpagetable, va, (uint64) pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">p-&gt;kstack = va;</span><br></pre></td></tr></table></figure><p>到这里内核页表就初始化完成了。接下来修改 kernel&#x2F;proc.c#scheduler 函数，因为当前每个进程有了自己的内核页表，那么在进入内核态之后就要使用自己的页表，也就是将第二层页表的物理地址放入 satp 寄存器中，<strong>在进程执行完之后一定要把全局的内核页表再设置回去</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... kernel/proc.c#scheduler</span></span><br><span class="line">p-&gt;state = RUNNING;</span><br><span class="line">c-&gt;proc = p;</span><br><span class="line">w_satp(MAKE_SATP(p-&gt;kpagetable));</span><br><span class="line">sfence_vma(); <span class="comment">// 使用 vma 指令清除 TLB 缓存，否则可能访问到其他进程的数据！</span></span><br><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line">kvminithart(); <span class="comment">// 在切换完毕之后使用 kvminithart 将全局内核页表设置会 satp</span></span><br></pre></td></tr></table></figure><p>接下来就是释放页表空间了，这一部分也卡了我很久。在 kernel&#x2F;proc.c#freeproc 中是释放进程的逻辑，我们要在这里面添加释放进程的内核页表的逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;kpagetable)</span><br><span class="line">  proc_freekpagetable(p, p-&gt;sz);</span><br><span class="line">p-&gt;kpagetable = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>proc_freekpagetable 函数的实现主要干了两件事，第一是释放掉进程的内核栈，第二是取消了进程的内核页表中的映射，但是<strong>一定不能释放映射指向的物理地址</strong>！因为进程的内核页表仅仅只是复制了映射。我们只释放页表本身的空间。</p><p>仿照 freewalk 实现了 proc_freekpagetable 函数，只释放掉页表页，而不释放最低层 PTE 指向的物理内存，具体做法是判断 PTE 是否还是指向下一层页表，如果是才进到下一层释放，这样就不会进到数据页中去释放内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freekpagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> ((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>) &#123; <span class="comment">// 判断是否还有下一层</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      freekpagetable((<span class="type">pagetable_t</span>) child);</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*) pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里 usertests 测试就可以通过了。</p><h2 id="Simplify-copyin-x2F-copyinstr-hard"><a href="#Simplify-copyin-x2F-copyinstr-hard" class="headerlink" title="Simplify copyin&#x2F;copyinstr (hard)"></a>Simplify copyin&#x2F;copyinstr (hard)</h2><p>这部分就是在刚刚给进程添加的内核页表中添加用户地址空间的映射。那么在内核中就可以直接使用用户空间地址，使用硬件 MMU 进行寻址，相比于用软件模拟 MMU 寻址效率更高。目标就是将 kernel&#x2F;vm.c#copyin 和 kernel&#x2F;vm.c#copyinstr 分别替换成 kernel&#x2F;vmcopyin.c#copyin_new 和 kernel&#x2F;vmcopyin.c#copyinstr_new。所以我们要在修改用户页表的每一处也对进程的内核页表都进行同步才能做到这一点。</p><p>首先仿照 kernel&#x2F;vm.c#uvmcopy 实现 kernel&#x2F;vm.c#uvmcopypg 用以拷贝页表，因为 uvmcopy 是在 fork 的时候把父进程的内存拷贝给子进程，所以它新分配了物理内存给子进程，所以我们不能直接用，因为<strong>内核页表仅仅只是拷贝映射</strong>，而拷贝映射的空间在 allocproc 时就已经分配了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopypg</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">pagetable_t</span> kpagetable, uint64 sz, uint64 start)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = PGROUNDUP(start); i &lt; sz; i+=PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopypg: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopypg: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte) &amp; ~PTE_U; <span class="comment">// 一定要设置 U 标识符，否则内核无法访问这个 PTE</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mappages(kpagetable, i, PGSIZE, pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  err:</span><br><span class="line">  uvmunmap(kpagetable, PGROUNDUP(start), (i - PGROUNDUP(start)) / PGSIZE, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来按照提示，分别在 kernel&#x2F;proc.c#userinit、kernel&#x2F;proc.c#fork、kernel&#x2F;exec.c#exec、kernel&#x2F;proc.c#growproc 中添加同步内核页表的代码。</p><p><strong>userinit</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 在进程页表初始化完成之后拷贝页表</span></span><br><span class="line"><span class="comment">// copy pagetable&#x27;s mappings to kpagetable, but don&#x27;t copy pa.</span></span><br><span class="line"><span class="keyword">if</span> (uvmcopypg(p-&gt;pagetable, p-&gt;kpagetable, p-&gt;sz, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  panic(<span class="string">&quot;uvmcopypg: fail to copy pagetable to kpagetable!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fork</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 在子进程拷贝完父进程的用户页表后，再将子进程的用户页表拷贝给内核页表</span></span><br><span class="line"><span class="keyword">if</span>(uvmcopypg(np-&gt;pagetable, np-&gt;kpagetable, p-&gt;sz, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  freeproc(np);</span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exec</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在成功生成 user image 后，先清除原本的内核页表，再将新的用户页表拷贝到内核页表</span></span><br><span class="line">uvmunmap(p-&gt;kpagetable, <span class="number">0</span>, PGROUNDUP(oldsz) / PGSIZE, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (uvmcopypg(pagetable, p-&gt;kpagetable, sz, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">goto</span> bad;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Commit to the user image.</span></span><br><span class="line">oldpagetable = p-&gt;pagetable;</span><br><span class="line">p-&gt;pagetable = pagetable;</span><br></pre></td></tr></table></figure><p><strong>growproc</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在进程空间扩容并且进程用户页表扩容之后，将扩容的那部分数据拷贝到内核页表</span></span><br><span class="line">    <span class="keyword">if</span> (uvmcopypg(p-&gt;pagetable, p-&gt;kpagetable, sz, sz-n)&lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果拷贝失败了，那么进程就要缩回到原本的容量</span></span><br><span class="line">      sz = uvmdealloc(p-&gt;pagetable, sz, sz-n);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">    <span class="comment">// 在进程空间缩小后并且进程页表页表也缩小之后，将缩小的那部分映射给去掉</span></span><br><span class="line">    <span class="type">int</span> npages = (PGROUNDUP(sz-n) - PGROUNDUP(sz)) / PGSIZE;</span><br><span class="line">    uvmunmap(p-&gt;kpagetable, PGROUNDUP(sz), npages, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于操作系统最低的虚拟地址在 0xC000000，也就是 PLIC 寄存器的地址，如果用户地址空间范围到了 0xC000000 之上，那么就会覆盖掉内核的数据。我们要限制用户地址空间不能超过这个地址。所以我们在 growproc 中判断，如果新的 sz 大于等于 PLIC 了，那么就直接返回 -1 而不执行扩容。</p><p>最后就是一个很大的坑，也就是上述全部实现之后会报 remap 的错误，返回去看 xv6 book 之后才发现，在 PLIC 之下还有一段数据是 CLINT，所以如果映射到了这一段，而这里是我们在初始化内核页表的时候就进行映射了的，所以会报 remap 错误。</p><p>查看 start.c 后发现 CLINT 仅在内核启动的时候需要，也就是说用户进程在内核中并不需要使用到这一段，所以干脆直接在初始化内核页表的时候不进行这部分的映射了。</p><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/170f9ee70f9e4ff59711e06f0c10a916~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个 lab3 确实难度不低，首先要对 xv6 的页表机制有一个比较深入的理解，然后 DEBUG 也比较难，我除了用 gdb 调试之外，还用了很多 panic 来尽早的发现是在哪里错了。如果不仔细读 xv6 book 把他理解清除的话大抵是做不出来了吧。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab2: System Calls</title>
      <link href="/post/ef0d189.html"/>
      <url>/post/ef0d189.html</url>
      
        <content type="html"><![CDATA[<p>这个 lab 是让我们在 xv6 中添加两个新的系统调用，来熟悉系统调用是怎么工作的，还有阅读内核代码，后续的 lab 中会添加更多的系统调用。</p><h2 id="System-call-tracing-moderate"><a href="#System-call-tracing-moderate" class="headerlink" title="System call tracing (moderate)"></a>System call tracing (moderate)</h2><p>trace 系统调用用于追踪程序执行的过程中的系统调用。trace 的使用方法是 trace + mask + 用户程序及参数，比如：</p><p>控制台输入 trace 32 grep hello README，就会出现以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ trace 32 grep hello README</span><br><span class="line">3: syscall read -&gt; 1023</span><br><span class="line">3: syscall read -&gt; 966</span><br><span class="line">3: syscall read -&gt; 70</span><br><span class="line">3: syscall read -&gt; 0</span><br></pre></td></tr></table></figure><p>为什么只 trace 了 read 呢？是因为参数 mask 为 32，二进制为 100000，从 0 开始第 5 位为 1，对应着read 系统调用号 5，所以 mask 用 bitmap 的方式来标识要追踪哪些系统调用。</p><p>根据任务提示，在 user&#x2F;user.h 中添加系统调用的 prototype，在 user&#x2F;usys.pl 中添加 stub，在 kernel&#x2F;syscall.h 中添加新的 syscall number，仿照原有的系统调用来写即可。</p><p>接下来是 trace 的实现逻辑，其实就是在进程的数据结构 struct proc 中添加一个新的成员变量 trace_mask 来记录要对哪些系统调用进行 trace。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="type">int</span> trace_mask;              <span class="comment">// To remember trace mask</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统调用的入口处在 kernel&#x2F;syscall.c#syscall 函数中，在这里根据寄存器 a7 中存储的系统调用号，从 syscalls 数组中取出对应的系统调用进行执行，所以我们要在上面的声明中加入我们在 sysproc.c 中新实现的 sys_trace 函数。其实它干的事情就仅仅是在进程中设置 trace_mask 而已。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    myproc()-&gt;trace_mask = mask;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 syscalls 取出一个系统调用函数并执行完毕后，我们就可以通过存储在 proc 中的 trace_mask 来判断这个系统调用是否需要进行 trace 了，也就是判断 trace_mask 中这个系统调用号这一位是不是 1。如果是的话就按照 lab 的格式需要打印 trace 信息。我们需要一个数组来存储系统调用号和系统调用名的对应关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="type">int</span> pid = p-&gt;pid;</span><br><span class="line">    <span class="type">int</span> trace_mask = p-&gt;trace_mask;</span><br><span class="line">    <span class="keyword">if</span> (trace_mask != <span class="number">0</span> &amp;&amp; ((trace_mask &gt;&gt; (num)) &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %s -&gt; %d\n&quot;</span>, pid, syscall_name[num<span class="number">-1</span>],p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要 trace 的系统调用使用了 fork 创建了子进程，我们也需要能够 trace 子进程进行的系统调用，所以要在 kernel&#x2F;proc.c#fork 中将 trace_mask 复制给子进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np-&gt;trace_mask = p-&gt;trace_mask;</span><br></pre></td></tr></table></figure><p>trace 的用户程序，xv6 中已经给出，接下来只要将 $U&#x2F;_trace 添加到 Makefile 中就可以运行了。</p><h2 id="Sysinfo-moderate"><a href="#Sysinfo-moderate" class="headerlink" title="Sysinfo (moderate)"></a>Sysinfo (moderate)</h2><p>sysinfo 系统调用用于打印剩余的内存还有多少和打印当前有多少进程处于运行状态，它接受一个 struct sysinfo 结构体参数，然后内核会将信息填入到这个参数中。</p><p>添加 prototype、stub、syscall number、系统调用声明这里就省略了，和上面的操作是一样的。重点说一下 kernel&#x2F;sysproc.c#sys_sysinfo 函数的实现。</p><p>想要获得有多少空余的内存，需要在 kernel&#x2F;kalloc.c 中添加函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">free_mem_size</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    r = kmem.freelist;</span><br><span class="line">    <span class="type">int</span> page_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r) &#123;</span><br><span class="line">        page_num++;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">    <span class="keyword">return</span> page_num * PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 kmem 结构体中存储了一个 freelist 来记录空闲的页数，freelist 中每一个节点都是一个 run 结构体的指针，所以遍历 freelist 并统计剩余的空闲页数即可。</p><p>想要获取有多少进程正在运行，需要在 kernel&#x2F;proc.c 中添加函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">used_proc_num</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">    uint64 proc_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p -&gt; state != UNUSED) &#123;</span><br><span class="line">            proc_num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程都被保存在 proc 数组中，遍历这个数组并判断进程状态再统计数量即可。</p><p>然后我们在 kernel&#x2F;sysproc.c#sys_sysinfo 中调用这两个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    uint64 fm = free_mem_size();</span><br><span class="line">    uint64 np = used_proc_num();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span> =</span> &#123;</span><br><span class="line">        fm,np</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    uint64 addr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;info, <span class="keyword">sizeof</span>(info)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据提示，参考 kernel&#x2F;sysfile.c#sys_fstat 和 kernel&#x2F;file.c#filestat 是如何使用 copyout 来讲数据拷贝回用户空间的。</p><p>最后把 $U&#x2F;_sysinfotest 加入到 Makefile 的 UPROGS 中即可运行。</p><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a739fc6c9d6e4c8d9ceb9f4ee3e922ad~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个 lab 乍一看比较难，但是把整个相关的源码看过一遍之后就还好了，第一个 trace 系统调用，将在进程中保存 trace_mask 和系统调用入口是怎么调用系统调用的关联起来其实就知道怎么实现了。第二个也是阅读 kalloc.c 和 proc.c 的相关代码，就知道怎么操作 kmem 和 proc 了。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab1: Xv6 and Unix utilities</title>
      <link href="/post/f71bd04b.html"/>
      <url>/post/f71bd04b.html</url>
      
        <content type="html"><![CDATA[<p>这个 lab 是用来熟悉 xv6 和它的系统调用的，就是用它的系统调用来实现一些小工具。在实现之后要将程序加入 Makefile 里的 UPROGS 中才能执行。</p><h2 id="sleep-eazy"><a href="#sleep-eazy" class="headerlink" title="sleep (eazy)"></a>sleep (eazy)</h2><p>就是调用已经实现的系统调用 sleep （具体实现在 sysproc.c#sys_sleep 中 ） 来实现即可，非常简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有指定参数提示错误信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;must enter a sleep time!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> time = atoi(argv[<span class="number">0</span>]); <span class="comment">// 使用工具函数 atoi 将字符串转化成数字</span></span><br><span class="line">  sleep(time); <span class="comment">// 调用系统调用</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pingpong-eazy"><a href="#pingpong-eazy" class="headerlink" title="pingpong (eazy)"></a>pingpong (eazy)</h2><p>使用 pipe 系统调用创建管道，用 fork 系统调用创建子进程，然后两个进程使用这个管道进行通信，使用 read&#x2F;write 系统调用对 pipe 进行读写即可；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 创建两个管道</span></span><br><span class="line">  <span class="type">int</span> send[<span class="number">2</span>], recv[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">if</span> (pipe(send) &lt; <span class="number">0</span> || pipe(recv) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;there is a problem when create a pipe!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">    <span class="comment">// pid 为 0，即是子进程  </span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    read(send[<span class="number">0</span>], &amp;c, <span class="number">1</span>); <span class="comment">// 阻塞在这里直到父进程向管道中写入</span></span><br><span class="line">    <span class="type">int</span> pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, pid);</span><br><span class="line">    write(recv[<span class="number">1</span>], <span class="string">&quot;a&quot;</span>, <span class="number">1</span>); <span class="comment">// 向父进程发送消息，阻塞直到父进程读取消息</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    write(send[<span class="number">1</span>], <span class="string">&quot;a&quot;</span>, <span class="number">1</span>); <span class="comment">// 向子进程发送消息</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    read(recv[<span class="number">0</span>], &amp;c, <span class="number">1</span>); <span class="comment">// 阻塞，直到收到子进程的消息</span></span><br><span class="line">    <span class="type">int</span> pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, pid);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="primes-moderate-x2F-hard"><a href="#primes-moderate-x2F-hard" class="headerlink" title="primes (moderate&#x2F;hard)"></a>primes (moderate&#x2F;hard)</h2><p>这个是利用 fork 和 pipe 来实现并发的处理质数（除了 1 和 它本身，不能被整除的数）。一开始我还没有懂什么意思，看了这张图之后还是没有搞懂：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e359d7633b124b3c87f734b3d57d2e5b~tplv-k3u1fbpfcp-zoom-1.image"></p><p>后来看到一个 golang 版本的实现才明白是什么意思，也就是 root 父进程向一个通道中发送 2-35，并且 fork 出一个子进程，将这个通道传递给子进程，子进程从管道中读取出一个数，比如当前情况下这个数就是 2，它是一个质数（<strong>通道中的第一个数一定是质数，因为它没有被任何比它小的数给过滤掉</strong>），那么就打印。</p><p>接着这个子进程，再创建一个通道并 fork 一个子进程，然后将父进程通道中剩下的 3-35 都对刚刚取出来的质数 2 取模，如果不等于 0，表示起码不能被 2 整除，就将它放到新创建的通道中给它的子进程处理（看看它能不能被剩下的数整除）。</p><p>循环往复直到有一个子进程在通道里读不出东西了，这个时候表示 2-35 的所有质数都被找到了，就返回。要注意的是，每个进程都要等待它的子进程退出之后才能退出，所以要调用 wait 等待子进程退出。并且<strong>对于不再使用的通道要及时将其关闭</strong>，否则程序算不到 35 就会使 xv6 资源不足。关闭通道分关闭读端和写端，父进程对自己创建的通道只需要写而不需要读，所以它可以将读端先关闭，写完之后再将写端关闭，而子进程对于收到的通道只需要读不需要写，所以在收到之后，它可以先关闭写端，读完后再关闭读端。<strong>父进程不能再创建完后就关闭，而要在 fork 之后再关闭</strong>，因为如果先关闭了，那么子进程再持有到这个通道的文件描述符后，会发现通道的读端是关闭，无法读取数据，会被阻塞（卡了我好久）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">processor</span><span class="params">(<span class="type">int</span> *pipeline)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    close(pipeline[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> prime;</span><br><span class="line">    <span class="type">int</span> read_len = read(pipeline[<span class="number">0</span>], &amp;prime, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (read_len == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipeline[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line">    <span class="type">int</span> out[<span class="number">2</span>];</span><br><span class="line">    pipe(out);</span><br><span class="line">    <span class="keyword">if</span> (!fork())</span><br><span class="line">    &#123;</span><br><span class="line">        processor(out);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(out[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="keyword">while</span> (read(pipeline[<span class="number">0</span>], &amp;num, <span class="keyword">sizeof</span>(<span class="type">int</span>)) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % prime != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                write(out[<span class="number">1</span>], &amp;num, <span class="keyword">sizeof</span>(num));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(out[<span class="number">1</span>]);</span><br><span class="line">        close(pipeline[<span class="number">0</span>]);</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> pipeline[<span class="number">2</span>];</span><br><span class="line">    pipe(pipeline);</span><br><span class="line">    <span class="keyword">if</span> (!fork())</span><br><span class="line">    &#123;</span><br><span class="line">        processor(pipeline);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(pipeline[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> num = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            write(pipeline[<span class="number">1</span>], &amp;num, <span class="keyword">sizeof</span>(num));</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">35</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                close(pipeline[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="find-moderate"><a href="#find-moderate" class="headerlink" title="find (moderate)"></a>find (moderate)</h2><p>find 是用来找出在文件夹中所有的指定名称的文件。</p><p>可以参考 user&#x2F;ls.c 来看如何读取文件夹，并且使用递归来读取子文件夹（不用递归 “.” 和 “..” ，否则会爆栈）。使用 strcmp() 来比较字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件路径中将文件名解析出来，对 ls 中的版本做了修改，去掉了填充</span></span><br><span class="line"><span class="type">char</span> *</span><br><span class="line"><span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="keyword">for</span> (p = path + <span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">        ;</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *filename)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ls: path too long\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">    p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">    *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (de.inum == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        memmove(p, de.name, DIRSIZ);</span><br><span class="line">        p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (stat(buf, &amp;st) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ls: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// st.type 为 2 就是文件，使用 strcmp 作比较</span></span><br><span class="line">        <span class="keyword">if</span> (st.type == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(fmtname(buf), filename))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// st.type 为 1 就是文件夹，判断是否需要递归</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (st.type == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) || !<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            find(buf, filename);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将路径和文件名传入</span></span><br><span class="line">    find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="xargs-moderate"><a href="#xargs-moderate" class="headerlink" title="xargs (moderate)"></a>xargs (moderate)</h2><p>xargs 从标准输入中读取数据，将每一行当作参数添加到 xargs 后面的程序中当作参数，比如：</p><p>echo hello too | xargs echo bye -&gt; echo bye hello too.</p><p>| 符号表示通过管道将数据发送到程序中，所以我们读数据的时候只要使用 read 系统调用在标准输出中读取就可以了，标准输出的 fd 编号为 0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGS 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> buf_idx, read_len;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="type">char</span>* args[MAXARGS];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        args[i<span class="number">-1</span>] = argv[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比如 find . b | xargs grep hello 就有可能传入多行数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buf_idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从标准输出中读取数据到 buf 里，一次读取一个字符</span></span><br><span class="line">            read_len = read(<span class="number">0</span>, &amp;buf[buf_idx], <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">            <span class="comment">// 如果读到了 &#x27;\n&#x27; 或者已经没有数据了，就停止</span></span><br><span class="line">            <span class="keyword">if</span> (read_len &lt;= <span class="number">0</span> || buf[buf_idx] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buf_idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (read_len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加入字符串结束的标识</span></span><br><span class="line">        buf[buf_idx] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        args[argc<span class="number">-1</span>] = buf;</span><br><span class="line">        <span class="comment">// fork 出一条子进程来执行</span></span><br><span class="line">        <span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">            exec(args[<span class="number">0</span>], args);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43b467766b674fc0b1e77ebf0184b67d~tplv-k3u1fbpfcp-zoom-1.image"></p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 2021 Fall Project4 Concureency Control</title>
      <link href="/post/12f55eb9.html"/>
      <url>/post/12f55eb9.html</url>
      
        <content type="html"><![CDATA[<p>项目 4 我们需要为 DBMS 实现一个<strong>锁管理器</strong>，并且利用锁管理器来实现并发的执行查询计划。锁管理器负责追踪事务涉及到的<strong>元组级的锁（行锁）</strong>，并且基于隔离级别来授予&#x2F;释放<strong>共享锁（Shared Lock）和排它锁（Exclusive Lock）</strong>。</p><p>任务如下：</p><ol><li>Task #1 - Lock Manager</li><li>Task #2 - DeadLock Prevention</li><li>Task #3 - Concurrent Query Execution</li></ol><p>本次项目的难度集中在 Task #1 和 Task #2，如果一些概念不清楚的话很容易到处出现问题，所以在写之前先把隔离级别、两段式锁还有 Wound-Wait 等概念理清楚再来动手写代码。并且一定一定听项目说明中说的先把 <code>transaction.h</code>和 <code>lock_manager.h</code> 中的 API 了解清楚。</p><p><a href="https://juejin.cn/post/7208793045479505980">https://juejin.cn/post/7208793045479505980</a></p><h2 id="TASK-1-LOCK-MANAGER-AND-TASK-2-DEADLOCK-PREVENTION"><a href="#TASK-1-LOCK-MANAGER-AND-TASK-2-DEADLOCK-PREVENTION" class="headerlink" title="TASK #1 - LOCK MANAGER AND TASK #2 - DEADLOCK PREVENTION"></a>TASK #1 - LOCK MANAGER AND TASK #2 - DEADLOCK PREVENTION</h2><p>任务 1 中我们要实现一个全局的锁管理器，每次有事务要访问&#x2F;修改某个元组时，我们就用锁管理器对这个元组上锁，并且锁管理器要根据事务的隔离级别来授予或者释放锁。任务 2 需要使用 <strong>WOUND-WAIT</strong> 算法实现死锁预防</p><p>在 2PL 下各个隔离级别的行为：</p><ul><li><strong>Read Uncommitted：</strong>读取不需要获取锁，但是<strong>写需要获取排他锁</strong>，用完直接释放，不需要等待提交。</li><li><strong>Read Committed：读取需要共享锁，写需要排他锁</strong>，用完直接释放，不需要等待提交。</li><li><strong>Repeatable Read：读取需要共享锁，写需要排他锁</strong>，不能直接释放，必须等到事务提交或者中止时才能释放。</li></ul><p>清楚了在 2PL 下各个隔离级别下的不同行为，再来实现 Lock Manager。</p><h3 id="NeedWait"><a href="#NeedWait" class="headerlink" title="NeedWait"></a>NeedWait</h3><p>我实现了一个 NeedWait 函数来判断事务是否需要阻塞等待，并且使用 <strong>WOUND-WAIT</strong> 来实现死锁预防，基本的使用方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">NeedWait</span>(txn, rid, LockMode::EXCLUSIVE)) &#123;</span><br><span class="line">lock_table_[rid].cv_.<span class="built_in">wait</span>(guard);</span><br><span class="line">    <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetState</span>() == TransactionState::ABORTED) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NeedWait 函数传入事务想要获取的锁的类型，根据锁类型来判断是否需要阻塞等待：</p><ol><li>事务想要获取共享锁：如果等待队列中有已经授予的排他锁，那么事务阻塞等待。</li><li>事务想要获取排他锁：如果等待队列中有已经授予的锁，那么事务阻塞等待。</li></ol><p>初步判断过后，如果不需要阻塞等待，直接能拿到锁，就返回 false，没有必要再进行死锁预防了（现在并不会产生竞态）。但是如果需要阻塞等待，这时再进行死锁预防，进行死锁预防前将返回值置为 false。</p><p>Wound-Wait 概念如下：</p><ol><li><strong>Timestamp(T**<strong>n</strong></strong>) &lt; Timestamp(T<strong><strong>k</strong></strong>)<em>*, then Tn forces Tk to be killed − that is Tn “wounds” Tk. *T**k</em> <em>is restarted later with a random delay but with the same timestamp(k).</em></li><li><strong>Timestamp(T**<strong>n</strong></strong>) &gt; Timestamp(T<strong><strong>k</strong></strong>)**, then Tn is forced to “wait” until the resource is available.</li></ol><p>将返回值置为 false，遍历等待队列：</p><ul><li>当遇到一个事务的 id 比自己大（这个事务比自己年轻）并且这个事务与自己冲突时，就将其强制中止，接着跳过这轮循环；</li><li>当遇到一个事务的 id 比自己小并且这个事务与自己冲突时，就需要阻塞等待；</li><li>遍历结束后，如果发生了中止，就进行一次通知，唤醒那些被中止的事务返回；</li><li><strong>及时清理掉等待队列中被中止的事务</strong>，否则会出现一个 younger 在等待一个被中止的 older 释放锁。</li></ul><p>最后返回最终的判断结果。</p><h3 id="NeedWaitUpgrade"><a href="#NeedWaitUpgrade" class="headerlink" title="NeedWaitUpgrade"></a>NeedWaitUpgrade</h3><p>这个函数用作 LockUpgrade，<strong>由于 LockUpgrade 是在持有共享锁的情况下升级，所以不需要初步判断是否需要等待</strong>，直接进行死锁预防即可，并且需要获取的锁类型固定是排他锁。</p><p>同样将返回值置为 false，遍历等待队列：</p><ul><li>当遇到一个事务的 id 比自己大并且这个事务与自己冲突时，就将其强制中止，接着跳过这轮循环；</li><li><strong>否则是肯定要等待的</strong>，因为要获取的是排他锁。</li><li>遍历结束后，如果发生了中止，就进行一次通知，唤醒那些被中止的事务返回；</li><li><strong>及时清理掉等待队列中被中止的事务。</strong></li></ul><p>最后返回最终的判断结果。</p><h3 id="LockShared"><a href="#LockShared" class="headerlink" title="LockShared"></a>LockShared</h3><p>这个函数用于获取某个元组的共享锁，<strong>调用该函数的线程会阻塞到成功获取锁或者该事务中止</strong>。在尝试获取锁之前，先根据 2PL 和  事务的隔离级别，来提前做一些判断：</p><ol><li>如果该事务已经中断，直接返回 false。</li><li>如果该事务处于 Shrinking 阶段，就意味着不能再获取锁了，直接中止事务，并抛出异常。</li><li>如果该事务的隔离级别是 Read UnCommitted，就意味着该事务进行读的时候不需要获取锁，直接中止事务，并抛出异常。</li><li>如果事务已经获取了共享锁，那么就直接返回 true。</li></ol><p>然后新建一个 LockRequest，并将其插入到对应的等待队列中去，开始调用 <strong>NeedWait</strong> 进行判断，如果该事务在等待时中止了，就返回 false。当成功获取了共享锁时，把该线程在等待队列中的 LockRequest 的 granted 属性设置为 true，该事务进入 Growing 阶段，将获取到的共享锁放入事务的 <strong>SharedLockSet</strong> 中并返回 true。</p><h3 id="LockExclusive"><a href="#LockExclusive" class="headerlink" title="LockExclusive"></a>LockExclusive</h3><p>该函数的实现跟 LockShared 非常类似，需要注意的就是即使事务的隔离级别是 Read Uncommitted 它也是要获取排他锁来进行写操作的，这时候不能直接中止。</p><h3 id="LockUpgrade"><a href="#LockUpgrade" class="headerlink" title="LockUpgrade"></a>LockUpgrade</h3><p>之前对锁升级的概念存在误区，写成了先将共享锁释放掉，再去尝试获取排他锁，后来在一篇帖子中看到了这样一段话：</p><p>Upgrade: A S(A) can be upgraded to X(A) if Ti is the only transaction holding the S-lock on element A.</p><p><a href="https://www.geeksforgeeks.org/lock-based-concurrency-control-protocol-in-dbms">https://www.geeksforgeeks.org/lock-based-concurrency-control-protocol-in-dbms</a></p><p>即一个元组的共享锁在只有一个事务持有时，就可以将其升级成排他锁，<strong>所以锁升级是在该事务持有共享锁的情况下进行的，</strong>否则锁升级好像就没有什么意义了，就是直接获取排他锁。</p><p>同样，在等待升级锁之前，也可以先进行一系列判断：</p><ol><li>如果事务已经中断、事务没有持有该元组的共享锁或已经有事务（<code>lock_table_[rid].upgrading_ != INVALID_TXN_ID</code>）在等待升级时直接返回 false。</li><li>如果事务已经持有排他锁则直接返回 true。</li><li>如果事务处在 Shrinking 阶段，直接中断事务并抛出异常。</li></ol><p>接下来调用 NeedWaitUpgrade 去尝试升级锁。如果升级成功，把该线程在等待队列中的 LockRequest 的 lock_mode_ 属性设置为排他锁，并将该等待队列的 upgrading_ 设置为 INVALID_TXN_ID，然后把排他锁放进 ExclusiveLockSet 中，将之前的共享锁从 SharedLockSet 中移除，并返回 true。</p><h3 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock"></a>Unlock</h3><ol><li>先判断事务有没有占用该元组的锁，如果没有直接返回。</li><li>开始遍历等待队列，如果找到了自己，就将对应的 LockRequest 移除，并发起一次通知。</li><li>如果没有找到直接返回 false。</li><li>如果事务的隔离级别是 Repeatable Read，并且处于 Growing 阶段，那么事务此时进入 Shrinking 阶段。</li><li>将锁从事务的 LockSet 中移除。</li></ol><h2 id="TASK-3-CONCURRENT-QUERY-EXECUTION"><a href="#TASK-3-CONCURRENT-QUERY-EXECUTION" class="headerlink" title="TASK #3 - CONCURRENT QUERY EXECUTION"></a>TASK #3 - CONCURRENT QUERY EXECUTION</h2><p>任务 3 要将我们实现的锁管理器应用起来，去修改以下 Executor：</p><h3 id="SeqScanExecutor"><a href="#SeqScanExecutor" class="headerlink" title="SeqScanExecutor"></a>SeqScanExecutor</h3><p>在所确定访问的元组后，即遍历到了那个位置的时候（这个时候 rid 才能确定，函数参数是用作返回值的，遍历时还是空值）去获取共享锁。在将参数的值设置好后再将锁释放（<strong>Read Uncommitted、Read Committed</strong> 隔离级别下直接释放，如果是 <strong>Repeatable Read</strong> 则不需要自己编写代码）。</p><h3 id="InsertExecutor"><a href="#InsertExecutor" class="headerlink" title="InsertExecutor"></a>InsertExecutor</h3><p>在所确定访问的元组后获取排他锁（如果已有排他锁就不需要获取，如果已有共享锁就进行升级，否则再获取排他锁）。更新完索引还要往 <strong>index_write_set_</strong> 中插入一条记录，注意 tuple 字段填的是插入表的那个元组。最后释放锁。</p><h3 id="UpdateExecutor"><a href="#UpdateExecutor" class="headerlink" title="UpdateExecutor"></a>UpdateExecutor</h3><p>总体跟 InsertExecutor 类似，但是 UpdateExecutor 在将元组更新后，还需要插入一条记录到 <strong>table_write_set_</strong> 中，tuple 字段是更新前的元组。并且再往 <strong>index_write_set_</strong> 中插入记录时，还需要将记录的 old_tuple_ 字段也附上，即更新前的元组。最后释放锁。</p><h3 id="DeleteExecutor"><a href="#DeleteExecutor" class="headerlink" title="DeleteExecutor"></a>DeleteExecutor</h3><p>跟 InsertExecutor 几乎完全一致。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>四个项目终于都完成了，虽然 Project 4 实现起来没有 Project 2 这么困难，但是感觉理解的并没有那么清晰，还需要阅读更多的资料再结合项目代码好好读一遍，而且这次提交了连 leaderboard 都没有，还有很大的优化空间。 </p>]]></content>
      
      
      <categories>
          
          <category> CMU 15-445 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab 文档 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 2021 Fall Project3 Query Execution</title>
      <link href="/post/be781c2c.html"/>
      <url>/post/be781c2c.html</url>
      
        <content type="html"><![CDATA[<p>项目 3 我们需要实现一些 <strong>Executor</strong> 来执行 <strong>Query Plan</strong>：</p><ul><li><strong>Sequential Scan</strong></li><li><strong>Insert (Raw)</strong></li><li><strong>Insert (Select)</strong></li><li><strong>Update</strong></li><li><strong>Delete</strong></li><li><strong>Nested Loop Join</strong></li><li><strong>Hash Join</strong></li><li><strong>Aggregation</strong></li><li><strong>Limit</strong></li><li><strong>Distinct</strong></li></ul><p>我们会使用的 <strong>Iterator query processing model</strong> 来实现，即 <strong>Volcano</strong> 模型。在这个模型中每个 Executor 都实现了一个 Next 函数，每次执行 Next 函数时，Executor 要么返回一个元组要么返回一个表示没有更多元组的标志。</p><p>项目说明书：<a href="https://15445.courses.cs.cmu.edu/fall2021/project3/">https://15445.courses.cs.cmu.edu/fall2021/project3/</a></p><h2 id="TASK-1-EXECUTORS"><a href="#TASK-1-EXECUTORS" class="headerlink" title="TASK #1 - EXECUTORS"></a>TASK #1 - EXECUTORS</h2><p>这是本项目的唯一一个任务，实现项目说明中指出的 Executor 即可。项目 3 相比于项目 2 的难度系数下降很多，一开始可能会由于 API 不熟悉导致无从下手，但实际上思路都是很简单的，<strong>在写每一个 Executor 之前，先把对应的 Plan 的源码看一下</strong>，碰到不懂的地方可以从测试文件看起，看如何手写一个查询计划，思路就会清晰很多。下文中会将常用的 API 简单的给出。</p><p>而且本项目中有很多工具都是已经写好的，我们<strong>只需要实现 Next 函数和 Init 函数就可以了</strong>，所以通过 Autograder 后最好还是将整个代码全部都过一遍，可以理解的更加深入。</p><h3 id="Sequential-Scan"><a href="#Sequential-Scan" class="headerlink" title="Sequential Scan"></a>Sequential Scan</h3><p>根据 Hint，可以知道需要借助 <strong>TableIterator</strong> 来遍历一张表，查看源码可以发现 <strong>TableHeap</strong> 类中有 <strong>Begin</strong> 和 <strong>End</strong> 函数可以获取对应的<strong>迭代器</strong>，<strong>所以我们可以在初始化的时候将 Executor 中迭代器设置为 Begin 的位置</strong>，接着在执行 Next 函数的时候遍历整张表即可。跟表或索引有关的信息都在 <strong>ExecutorContext</strong> 中。</p><p>注意我们遍历时需要判断是否满足 Predicate 条件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (table_iterator_ != table_info_-&gt;table_-&gt;<span class="built_in">End</span>() &amp;&amp; plan_-&gt;<span class="built_in">GetPredicate</span>() != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">!plan_-&gt;<span class="built_in">GetPredicate</span>()-&gt;<span class="built_in">Evaluate</span>(&amp;(*table_iterator_), plan_-&gt;<span class="built_in">OutputSchema</span>()).<span class="built_in">GetAs</span>&lt;<span class="type">bool</span>&gt;()) &#123;</span><br><span class="line">    table_iterator_++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当满足条件的时候，要根据执行计划的 OutputSchema 来生成元组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Value&gt; values;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;column : plan_-&gt;<span class="built_in">OutputSchema</span>()-&gt;<span class="built_in">GetColumns</span>()) &#123;</span><br><span class="line">values.<span class="built_in">push_back</span>(column.<span class="built_in">GetExpr</span>()-&gt;<span class="built_in">Evaluate</span>(&amp;(*table_iterator_), &amp;table_info_-&gt;schema_));</span><br><span class="line">&#125;</span><br><span class="line">*tuple = <span class="built_in">Tuple</span>(values, plan_-&gt;<span class="built_in">OutputSchema</span>());</span><br></pre></td></tr></table></figure><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p>这里需要实现两种 Insert：</p><ol><li><strong>RawInsert</strong></li><li><strong>SelectInsert</strong></li></ol><p>在 Insert Plan 中有一个函数 IsRawInsert 用来判断是哪种 Insert，如果是 RawInsert 表明不需要执行 <strong>Chlid Executor</strong>，<strong>直接调用 TableHeap 的插入函数将查询计划中的数据插入到表中即可</strong>，而如果是 SelectInsert，那么就要<strong>先初始化</strong> <strong>Chlid Executor，再从 Chlid Exceutor 取出元组并插入。</strong></p><p>在表中成功插入元组后，还需要在索引中插入一个 Index Tuple：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> indexes = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>()-&gt;<span class="built_in">GetTableIndexes</span>(table_info_-&gt;name_);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;index : indexes) &#123;</span><br><span class="line">Tuple index_tuple = tuple-&gt;<span class="built_in">KeyFromTuple</span>(table_info_-&gt;schema_, index-&gt;key_schema_, index-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>());</span><br><span class="line">index-&gt;index_-&gt;<span class="built_in">InsertEntry</span>(index_tuple, *rid, exec_ctx_-&gt;<span class="built_in">GetTransaction</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Insert 中有一个很大的坑，就是虽然测试文件中没有写Insert Executor 不能修改 result_set，而且测试文件中 insert_plan 中的 result_set 也是 nullptr，但是在 Autograder 中有几个测试的 insert_plan 中的 result_set 并不是 nullptr，这个时候就会出现错误。<strong>所以需要一次性将所有数据插入元组再直接返回一个 False 给 Exceutor Engine，避免将数据插入到 result_set 中。</strong></p><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><p><strong>Update Executor 必定会有 Chlid Executor</strong>，所以在初始化时也要将 <strong>Chlid Executor 初始化。</strong>每从 Chlid Executor 中拿出一个元组都调用 <strong>GenerateUpdatedTuple</strong> 函数来生成更新后的元组，再使用 TableHeap 的更新函数即可。<strong>如果更新成功，要将索引中更新前的元组删除，再插入更新后的元组，所以需要记录更新前的那个元组。</strong>Update Executor 同样也<strong>不能修改 result_set</strong>。</p><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>跟 Update Executor 非常类似，每从 Chlid Executor 中拿出一个元组都调用 TableHeap 的 <strong>MarkDelete</strong> 函数（真正的删除在事务提交时执行）。再将索引中对应的元组删除即可。</p><h3 id="Nested-Loop-Join"><a href="#Nested-Loop-Join" class="headerlink" title="Nested Loop Join"></a>Nested Loop Join</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/23042800/1665113369456-cdfb41ce-5da6-4fdd-8d23-a47593f584a8.png" alt="img"></p><p>嵌套两个循环将外表的每一个元组分别跟内表中的每一个元组进行比较，如果满足条件就将其返回（我选择用一个 List 来存储结果，再依次返回）。</p><p>判断是否满足 Join 条件的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plan_-&gt;<span class="built_in">Predicate</span>()-&gt;<span class="built_in">EvaluateJoin</span>(&amp;left_tuple, left_executor_-&gt;<span class="built_in">GetOutputSchema</span>(), right_tuple, right_executor_-&gt;<span class="built_in">GetOutputSchema</span>()).<span class="built_in">GetAs</span>&lt;<span class="type">bool</span>&gt;();</span><br></pre></td></tr></table></figure><p>如果满足条件，组合 Tuple 的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Value&gt; values;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;columns : plan_-&gt;<span class="built_in">OutputSchema</span>()-&gt;<span class="built_in">GetColumns</span>()) &#123;</span><br><span class="line">values.<span class="built_in">emplace_back</span>(columns.<span class="built_in">GetExpr</span>()-&gt;<span class="built_in">EvaluateJoin</span>(&amp;left_tuple, left_executor_-&gt;<span class="built_in">GetOutputSchema</span>(),&amp;right_tuple, right_executor_-&gt;<span class="built_in">GetOutputSchema</span>()));</span><br><span class="line">&#125;</span><br><span class="line">result_.<span class="built_in">emplace_back</span>(<span class="built_in">Tuple</span>(values, plan_-&gt;<span class="built_in">OutputSchema</span>()));</span><br></pre></td></tr></table></figure><h3 id="Hash-Join"><a href="#Hash-Join" class="headerlink" title="Hash Join"></a>Hash Join</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/23042800/1665113888897-2ea9728b-f9f2-4418-8d91-109eab0ca5db.png" alt="img"></p><p>Hint 中让仿照 <strong>SimpleAggregationHashTable</strong> 实现一个 Hash Table，但是感觉好像没有什么必要，我使用了项目中提供的 HashUtil 加上一个 unordered_map 来完成。我们可以在<strong>初始化阶段</strong>将 HashTable 建立好。</p><p>注意，Hint 中提到我们需要处理多个元组的 key 是一样的情况，所以 HashTable 的声明应该是：<code>std::unordered_map&lt;hash_t, std::vector&lt;Tuple&gt;&gt; hash_table_;</code>，将外表中所有 join key 相同的元组存储到一起，在 Probe 时将这些元组统一跟内表中对应的元组进行比较，如果满足条件则拼装起来放入 result 中，方法跟 nested loop join 一样。</p><p>获取 join key 的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> left_join_key = left_expression-&gt;<span class="built_in">Evaluate</span>(&amp;tuple, left_child_-&gt;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line"><span class="keyword">auto</span> hash_key = HashUtil::<span class="built_in">HashValue</span>(&amp;left_join_key);</span><br><span class="line">hash_table_[hash_key].<span class="built_in">emplace_back</span>(tuple);</span><br></pre></td></tr></table></figure><h3 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h3><p>聚合的实现需要的东西很多，但是项目都已经给出来了，在写之前先看一下 SimpleAggregationHashTable 这个类。对于每一个元组，我们只需要调用 MakeAggregateKey、MakeAggregateValue 函数，生成 aggregate_key 和 aggregate_value 然后调用 InsertCombine 函数即可，这样聚合的结果就已经计算好了，存放在 SimpleAggregationHashTable 中，可以用它的迭代器对其中每一条结果进行操作。</p><p>对于有 Having 语句的情况，使用类似的做法判断条件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plan_-&gt;<span class="built_in">GetHaving</span>()-&gt;<span class="built_in">EvaluateAggregate</span>(aht_iterator_.<span class="built_in">Key</span>().group_bys_, aht_iterator_.<span class="built_in">Val</span>().aggregates_).<span class="built_in">GetAs</span>&lt;<span class="type">bool</span>&gt;();</span><br></pre></td></tr></table></figure><p>同样，生成元组的方式也是类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Value&gt; values;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;column : plan_-&gt;<span class="built_in">OutputSchema</span>()-&gt;<span class="built_in">GetColumns</span>()) &#123;</span><br><span class="line">    values.<span class="built_in">emplace_back</span>(</span><br><span class="line">    column.<span class="built_in">GetExpr</span>()-&gt;<span class="built_in">EvaluateAggregate</span>(aht_iterator_.<span class="built_in">Key</span>().group_bys_, aht_iterator_.<span class="built_in">Val</span>().aggregates_));</span><br><span class="line">&#125;</span><br><span class="line">*tuple = <span class="built_in">Tuple</span>(values, plan_-&gt;<span class="built_in">OutputSchema</span>());</span><br></pre></td></tr></table></figure><h3 id="Limit"><a href="#Limit" class="headerlink" title="Limit"></a>Limit</h3><p>Limit 就非常简单了，限制一下调用 Chlid_Executor 的次数就可以了。</p><h3 id="Distinct"><a href="#Distinct" class="headerlink" title="Distinct"></a>Distinct</h3><p>跟 Hash Join 类似，这里也用到了 HashUtil 加上一个 unordered_map 来实现，但现在是为了去重，所以 HashTable 中存储的东西就跟刚刚不一样了，我们将 key 相同的元组的 values 存储在其中，方便进行比较：<code>std::unordered_map&lt;hash_t, std::vector&lt;std::vector&lt;Value&gt;&gt;&gt; distinct_map_&#123;&#125;;</code>。当从 Chlid Executor 中取出一个元组后，用 HashTable 进行去重即可，如果不是重复的就将其放入 result 中，最后依次返回。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>在开始写 Query Execution 之前本来觉得应该非常的费时费脑，但是项目中大部分东西都已经给出，大大降低了难度。但是在自己查看 API 的过程中，发现依旧对这一块内容的理解变深了不少。在降低难度的同时还能加深理解，感谢 Andy。最后 leaderboard 还是不意外的在 100 名开外。</p>]]></content>
      
      
      <categories>
          
          <category> CMU 15-445 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab 文档 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 2021 Fall Project2 Extendible Hash Index</title>
      <link href="/post/ae72c972.html"/>
      <url>/post/ae72c972.html</url>
      
        <content type="html"><![CDATA[<p>项目 2 是实现一个可拓展的哈希索引，它包含一个 directory_page，其中存储了指向 bucket_page 的指针，而数据就存储在 bucket_page 中。这些 page 都会存储在之前写的缓存池中。</p><p>该哈希索引要支持满&#x2F;空桶的拆分&#x2F;合并，并且也要支持目录的拓展和收缩（<strong>Extendible</strong>）。</p><p>本次项目有三个任务，分别是：</p><ul><li>Page Layouts</li><li>Extendible Hashing Implementation</li><li>Concurrency Control</li></ul><h2 id="Extendible-Hash-Index"><a href="#Extendible-Hash-Index" class="headerlink" title="Extendible Hash Index"></a>Extendible Hash Index</h2><p>要完成这个项目首先一定要把 Extendible Hash Index 的流程弄清楚，否则写起来会缺胳膊少腿。可以阅读这篇文章了解先算法流程：</p><p><a href="https://www.geeksforgeeks.org/extendible-hashing-dynamic-approach-to-dbms/">https://www.geeksforgeeks.org/extendible-hashing-dynamic-approach-to-dbms/</a></p><p>，后文的内容默认读者都是已经看过这篇教程，这篇图文教程写的非常清楚，但是并没有写如何收缩，剩下的细节在后面实现中提到。</p><h2 id="TASK-1-PAGE-LAYOUTS"><a href="#TASK-1-PAGE-LAYOUTS" class="headerlink" title="TASK #1 - PAGE LAYOUTS"></a>TASK #1 - PAGE LAYOUTS</h2><p>这个任务就是要实现 directory_page 和 bucket_page，分别来存储哈希表的目录和数据。</p><p>要通过 <strong>Task #1</strong> ，两种页都只需要实现部分方法即可：</p><ul><li><strong>Bucket Page:</strong> - Insert - Remove - IsOccupied - IsReadable - KeyAt - ValueAt</li><li><strong>Directory Page:</strong> - GetGlobalDepth - IncrGlobalDepth - SetLocalDepth - SetBucketPageId - GetBucketPageId</li></ul><p>但为了看起来更有整体性，所以在写的时候就将整个 Extendible Hash Index 所需要的东西全部写上了。</p><h3 id="HASH-TABLE-DIRECTORY-PAGE"><a href="#HASH-TABLE-DIRECTORY-PAGE" class="headerlink" title="HASH TABLE DIRECTORY PAGE"></a>HASH TABLE DIRECTORY PAGE</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>GlobalDepth：</strong></p><p>当 Extendible Hash Index 进行 GetValue、Insert、Remove 时，GlobalDepth 用于确定这个 key 对应的 directory_index 在哪，具体来说就是取这个 key 经过哈希之后的 <strong>低 GlobalDepth 位</strong>来确定 directory_index。比如当前要插入的 key 哈希之后得到的结果是 00110，GlobalDepth 是 3，那么取低 3 位也就是 110，那么 directory_index 就等于 6。但项目中给出的公式是：<code>DirectoryIndex = Hash(key) &amp; GLOBAL_DEPTH_MASK</code>， GLOBAL_DEPTH_MASK 得求出来，其实它就等于 GloablDepth 这么多个 1，所以 GetGlobalDepthMask 函数就很好实现了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; global_depth_) - <span class="number">1</span>; <span class="comment">// 得到 GlobalDepth 这么多个 1.</span></span><br></pre></td></tr></table></figure><p><strong>LocalDepth：</strong></p><p>LocalDepth 并不与 directory_index 相关，而是与 bucket 相关。我们会根据LocalDepth 和 GlobalDepth 的关系来决定当发生 bucket_page 溢出，或者 bucket_page 为空时需要干的事情（具体要到 Extendible Hash Table 的实现）。GetLocalDepthMask 的实现方式跟 GetGlobalDepthMask 一样。</p><p><strong>SplitImageIndex：</strong></p><p>这个指的是 bucket_page 分裂之后，它分裂出来的那个 bucket_page 的 directory_index，只要将当前 bucket的  directory_index 中 LocalDepth 对应的那个位取反即可。比如说 directory_index 是 001，LocalDepth 为 2，那么它的 split_image_index 就是 011，可以通过异或运算来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> bucket_idx ^ (<span class="number">1</span> &lt;&lt; (local_depth - <span class="number">1</span>));</span><br></pre></td></tr></table></figure><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>Mask 和 SplitImageIndex 如何求上面已经写了，还剩下就是 <strong>IncrGlobalDepth、DecrGlobalDepth、Size</strong>。</p><p><strong>IncrGlobalDepth：</strong>当 GlobalDepth 增加时，就是目录需要扩容了，<strong>GlobalDepth 增加 1，目录的容量就增加一倍</strong>，所以实现这个函数时，<strong>我们要把目录扩容前的 bucket 分布情况拷贝一份到扩容后的位置</strong>，也就是此时一个 bucket_page 是有多指针指向它的。注意此时数据还并未进行迁移，因为新的 bucket_page 还没插进来，只是先把目录拓展。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/23042800/1664702021939-5a3b9083-12ee-475a-a6f1-ed52fd9818fc.png" alt="img"></p><p><strong>DecrGlobalDepth：</strong>当 GlobalDepth 减少时，就是目录需要缩小了，<strong>GlobalDepth 减少 1，目录的容量就减少一倍</strong>，但注意只有当所有的 LocalDepth 都小于 GlobalDepth 时，才能减少 GlobalDepth，如果能够减少，<strong>我们只需要 global_depth_–</strong> <strong>即可</strong>，因为 GlobalDepth 减少了，后面的无用位置其实已经访问不到了。</p><p><strong>Size：</strong>返回当前目录的长度，<strong>GlobalDepth 有多少位，目录长度就是 2 的多少次方</strong>，即 1&lt;&lt;global_depth_。</p><h3 id="HASH-TABLE-BUCKET-PAGE"><a href="#HASH-TABLE-BUCKET-PAGE" class="headerlink" title="HASH TABLE BUCKET PAGE"></a>HASH TABLE BUCKET PAGE</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>实现 bucket_page 同样也需要用到很多位运算，因为  occupied_ 数组和  readable_ 数组都是 char 类型的数组，而一个 char 是一个字节，即 8 比特，所以可以标识 bucket_page 中八个位置的情况，我们要用 bucket_index 在 char 数组中找到那个对应的比特。</p><p>occupied_ 数组的含义：<strong>如果 array 的第 i 个索引曾经有被占用过，那 occupied_ 数组的第 i 个比特位就是1。注意：一旦设置为 1，那么这个位置之后就不会再变成 0 了，除非 bucket_page 内容被清空。</strong></p><p>readable_ 数组的含义：<strong>如果 array 的第 i 个索引当前存储了可读的值，那 readable_ 数组的第 i 个比特就是 1 。</strong></p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>首先要实现的是 <strong>IsOccupied、SetOccupied、IsReadable、SetReadable</strong> 函数。我选择的是用除法的方式来确定索引对应的比特位：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> [char_pos, bit_pos] = std::<span class="built_in">div</span>(bucket_idx, CHAR_BIT_SIZE);</span><br></pre></td></tr></table></figure><p>char_pos 即 char 数组中的第几个字符，bit_pos 则是该字符中的第几位是我们要找的位。假设 ch 为一个字符。</p><p>判断找出来的位是否为 1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((ch &gt;&gt; bit_pos) &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>将某一位设置为 1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch |= (<span class="number">1U</span> &lt;&lt; bit_pos);</span><br></pre></td></tr></table></figure><p>将某一位设置为 0：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &amp;= ~(<span class="number">1U</span> &lt;&lt; bit_pos);</span><br></pre></td></tr></table></figure><p>接下来就可以实现 GetValue、Insert、Remove 了：</p><p><strong>Insert：</strong></p><p>插入是可以插入 key 重复，<strong>但不能插入 key 和 value 同时重复的值的，所以不能找到一个空位就插进去，因为后面可能还有 KV 都重复的条目</strong>，要全都检查一遍。</p><p><strong>Remove：</strong></p><p>找到 KV 都符合的那个条目，将 readable_ 数组的这个位置设置为 0 即可。</p><p><strong>GetValue：</strong></p><p>将所有符合 key 的条目都放进 result 数组中，再返回 result 是否为空即可。</p><p><strong>Remove 和 GetValue 有个可以优化的点就是一旦到了一个位置的 occupied 为 0，那么就可以停止遍历了</strong>，因为后面已经没有数据。</p><h2 id="TASK-2-HASH-TABLE-IMPLEMENTATION"><a href="#TASK-2-HASH-TABLE-IMPLEMENTATION" class="headerlink" title="TASK #2 - HASH TABLE IMPLEMENTATION"></a>TASK #2 - HASH TABLE IMPLEMENTATION</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>现在开始可以着手实现可拓展哈希表了，我们要在刚刚之前实现的 bucket_page 和 directory_page 的基础上实现 GetValue、Insert、Remove。如果看了前文提到的博客，应该大致流程都已经了解了，本文再对具体的实现步骤和细节做一个总结。</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p><strong>构造函数：</strong></p><p>我在构造函数中新建了一个 directory_page 和两个 bucket_page，并将 GlobalDepth 设置为 1，再将这两个 bucket_page 的 id 放进目录中，再测试中将所有数据删除后就会恢复到现在的状态，GlobalDepth 和 LocalDepth 最小为 1。<strong>记得 pin 过的页一定要及时的 unpin。</strong></p><p>将 新创建的 Page 对象转成 directory_page 或 bucket_page 可以用下面这种方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> dir_page = <span class="built_in">reinterpret_cast</span>&lt;HashTableDirectoryPage *&gt;(buffer_pool_manager_-&gt;<span class="built_in">NewPage</span>(&amp;<span class="keyword">this</span>-&gt;directory_page_id_)-&gt;<span class="built_in">GetData</span>());</span><br></pre></td></tr></table></figure><p>在实现 FetchDirectoryPage 和 FetchBucketPage 时可以用同样的方法。</p><p><strong>GetValue：</strong></p><p>这个函数的实现没有什么好说，将 directory_page 和 key 所在的 bucket_page 拉出来调用查询方法即可。</p><p><strong>Insert：</strong></p><p>Insert 的实现细节很多，有非常多需要注意的地方，具体的实现步骤如下：</p><ol><li>将 directory_page 和 key 所在的 bucket_page 拉取出来。</li><li>尝试进行插入，若插入成功则直接返回 true，否则进行步骤 3 。</li><li>判断 bucket_page 是否已满，如果未满还是插入失败那么只能是已经重复，返回 false，否则进行步骤 4 。</li><li>如果 bucket_page 已满，<strong>但是这时候不能直接进行分裂</strong>，因为就算是满了的情况，也有可能已经重复，如果这时候分裂就会导致插入错误（我因为这个错误卡了很久），<strong>还要再检查一遍是否重复</strong>。</li><li>这个时候将刚刚用到的页 unpin，进入 split insert 阶段。</li><li>将需要分裂的 bucket_page 的 LocalDepth 加 1，判断 LocalDepth 是否大于 GlobalDepth，如果大于则将 directory 进行扩容，即调用之前实现的 IncrGlobalDepth 函数。</li><li>获取到需要分裂的 bucket_page 的 SplitImageIndex，并为这个兄弟 bucket 创建一个新的页（<strong>注意创建了页之后就不要再 Fetch 了</strong>），取出原 bucket_page 中的所有数据，<strong>再将数据重新散列到这两个页中。</strong></li><li>这里有一个需要注意的地方，一个 bucket 分裂之后，仍然有可能有多个指针指向它，如下图所示。当我们往第五个 bucket_page 里再插入一个数据时，它进行分裂后，它自身和分裂出来的那个页仍然各自都有两个指针指向它，<strong>所以我们不止要设置</strong> <strong>SplitImageIndex 那个位置的指向新分裂出来的页，和它同级的另一个指针也需要指向这个页，并且 LocalDepth 也要更新成一样的。</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/23042800/1664805475296-670e19f5-0a2c-4420-be46-eff1f8d87191.png" alt="img"></p><ol><li>最后再次尝试插入需要插入的那个值，<strong>这里要重新通过哈希和 mask 来获取应该插入的地方</strong>。</li><li>将使用到的页 unpin 并返回。</li></ol><p>Remove：</p><ol><li>将 directory_page 和 key 所在的 bucket_page 拉取出来。</li><li>尝试进行删除，如果删除失败则直接返回 false，否则将使用到的页 unpin 并进行步骤 3，调用 Merge 函数 。</li><li>再次拉取 directory_page 和 key 所在的 bucket_page，检查 bucket_page 是否为空，如果不为空则 unpin 并返回，否则进行步骤 4 。</li><li>如果该 bucket_page 的 LocalDepth 小于等于 1，或 它不等于它 <strong>SplitImage</strong> 的 LocalDepth，则 unpin 并返回，否则进行步骤 5 。</li><li><strong>将该 bucket_page 的 SplitImage 的 LocalDepth 减 1，并将 LocalDepth 减 1 后的所有同级 bucket 的 LocalDepth 和指向的 bucket_page 都设置为 SplitImage 。</strong>这一步跟 <strong>Insert 的步骤 8</strong> 类似。</li><li><strong>一定要先 unpin 该 bucket_page</strong> ，然后再将这个页删除。</li><li>将使用到的页 unpin 并返回。</li></ol><p>Extendible Hash Table 到这里就已经可以通过<strong>除了并发控制测试之外</strong>的所有测试了。</p><h2 id="TASK-3-CONCURRENCY-CONTROL"><a href="#TASK-3-CONCURRENCY-CONTROL" class="headerlink" title="TASK #3 - CONCURRENCY CONTROL"></a>TASK #3 - CONCURRENCY CONTROL</h2><p>最后我们要进行并发控制，给页上锁的方式项目说明中已经详细写到了，这里就不再多做说明，只说一下加锁的思路。</p><p><strong>GetValue：</strong></p><p>table_latch_ 和 bucket_page 的锁均上读锁即可。</p><p><strong>Insert：</strong></p><p>插入阶段，table_latch_ 只需要上读锁即可，但是对 bucket_page 要上写锁，因为此时只对一个 bucket_page 进行修改。</p><p><strong>SplitInsert：</strong></p><p>这个阶段因为目录也有可能被修改，所以两个都需要上写锁。</p><p><strong>Remove：</strong></p><p>跟 Insert 同理。</p><p><strong>Merge：</strong></p><p>跟 SplitInsert 同理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>项目二整体还是非常难的，首先一定要认真搞清楚 Extendible Hash Table 到底是什么再来动手，否则从一开始就会理解不了。然后用到了很多位运算，如果之前没什么经验的话也需要琢磨一下。现在这个版本等整个项目写完了再考虑优化一下吧，提交上去发现发现花了三十几秒。</p>]]></content>
      
      
      <categories>
          
          <category> CMU 15-445 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab 文档 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 2021 Fall Project1 Buffer Pool</title>
      <link href="/post/bd7291a8.html"/>
      <url>/post/bd7291a8.html</url>
      
        <content type="html"><![CDATA[<p>CMU 15-445 的配套项目 BusTub 是一个面向磁盘的 DBMS，所以首先要做的事就是写一个缓存池来<strong>管理从磁盘上拉取的页</strong>，<strong>因为 DBMS 是不能直接在磁盘上的进行修改的</strong>，需要通过缓存池。</p><p>缓存池负责将磁盘上的页放入内存或反之。缓存池可以让 DBMS 感觉可用内存比实际的内存要大（有点像虚拟内存的概念）。</p><p>本次项目有三个任务，分别是：</p><ol><li>LRU Replacement Policy：实现 LRU 替换机制。</li><li>Buffer Pool Manager Instance：实现缓存池管理器的实例。</li><li>Parallel Buffer Pool Manager：实现并行的缓存池管理器。</li></ol><p>项目说明书链接：<a href="https://15445.courses.cs.cmu.edu/fall2021/project1/">https://15445.courses.cs.cmu.edu/fall2021/project1/</a></p><h2 id="TASK-1-LRU-REPLACEMENT-POLICY"><a href="#TASK-1-LRU-REPLACEMENT-POLICY" class="headerlink" title="TASK #1 - LRU REPLACEMENT POLICY"></a>TASK #1 - LRU REPLACEMENT POLICY</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>实现一个 <strong>LRUReplacer</strong> 来进行页的调度，需要实现以下方法：</p><ul><li><strong>Victim(frame_id_t*)：</strong>将最近最少使用的页的帧号从 Replacer 中移除并返回。</li><li><strong>Pin(frame_id_t)：</strong>将指定页的帧从 Replacer 中移除。</li><li><strong>Unpin(frame_id_t)：</strong>将指定页的帧添加到 Replacer 中，BufferPoolManager 在调用该方法时，<strong>页</strong>的 pin_count 必须是 0，即当前没有线程在使用这个页。</li><li><strong>Size()：</strong>返回 Replacer 的长度。</li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>首先要区分<strong>帧号和页号</strong>的概念，<strong>页号指的是磁盘中页存储位置，而帧号是该页的拷贝在缓存池中的位置。</strong>所以上述方法实际上操作的都是帧号，<strong>BufferPoolManagerInstance</strong> 在这些方法返回帧号后，再根据帧号，在缓存池的 pages_ 数组中将真正的页取出来。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/23042800/1664617275859-eabc6904-e4b0-4fb2-9187-db0d784d9525.png" alt="img"></p><p>然后就是 <strong>pin 和 unpin</strong> 的概念，pin 了某个帧指的是当前有线程在使用这个帧中的页，每有一个线程使用了该页，就会将其 pin_count 加 1，所以 Pin 函数的作用是将其从 Replacer 中移除，这样当有其他线程调用 Victim 函数时，这个被 Pin 的页就不会被替换算法踢出内存。unpin 就是相反的，当线程使用完了该页时，就会将 pin_count 减 1，当 pin_count 变成 0 时，就调用 Unpin 函数将其重新放进 Replacer 中，等待被替换出去。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>LRU 的实现有一个很常见的想法就是使用一个<strong>队列</strong>来实现，最近刚用过的帧会被插到队尾，那么队首就是最近最少使用的帧，所以 <strong>Victim 函数就直接将队首元素出队即可，Unpin 函数也只需要将 unpin 的那个帧插入队尾即可。</strong></p><p>但问题在于 Pin 函数，因为如果要将一个元素直接移除出队列的话，都需要遍历一遍整个队列，这样就造成了性能的损失。所以我们可以使用一个 <strong>unordered_map</strong> 来存储每个元素在队列中的位置，C++ 的话可以存储该元素的迭代器，那么就可以直接通过 erase 函数来将该元素移除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;<span class="type">frame_id_t</span>&gt; frame_id_list_;</span><br><span class="line">std::unordered_map&lt;<span class="type">frame_id_t</span>, std::list&lt;<span class="type">frame_id_t</span>&gt;::iterator&gt; location_map_;</span><br></pre></td></tr></table></figure><p>其他需要注意的点就是尽量使用 <strong>count 函数代替 find 函数</strong>，用 <strong>emplace_back 函数取代 push_back函数</strong>，可以提高性能。还有就是移除的时候需要判断一下 Replacer 是不是已经空了。</p><h2 id="Task-2-BUFFER-POOL-MANAGER-INSTANCE"><a href="#Task-2-BUFFER-POOL-MANAGER-INSTANCE" class="headerlink" title="Task #2 - BUFFER POOL MANAGER INSTANCE"></a>Task #2 - BUFFER POOL MANAGER INSTANCE</h2><h3 id="任务："><a href="#任务：" class="headerlink" title="任务："></a>任务：</h3><ul><li><strong>FetchPgImp(page_id)：</strong>根据 page_id 从磁盘中拉取页并放入缓存池中。</li><li><strong>UnpinPgImp(page_id, is_dirty)：</strong>将指定页的 pin_count 减 1，如果 pin_count 等于 0 了就调用 Unpin 函数将这个帧放入 Replacer 中。</li><li><strong>FlushPgImp(page_id)：</strong>将对应的页刷入磁盘中。</li><li><strong>NewPgImp(page_id)：</strong>创建一个新的页。</li><li><strong>DeletePgImp(page_id)：</strong>删除一个页。</li><li><strong>FlushAllPagesImpl()：</strong>将所有页刷入磁盘中。</li></ul><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>操作磁盘的 DiskManager 此次实验已经提供了，不需要自己实现。关于 Page 对象的介绍一定要仔细看项目说明里的内容。</p><p>系统中的所有内存页面都由 Page 对象表示。 <strong>BufferPoolManagerInstance 不需要了解这些页面的内容。</strong> 但是对于系统开发人员来说，重要的是要了解 Page 对象只是缓冲池中的<strong>内存容器</strong>，因此并<strong>不特定于唯一页面</strong>。 也就是说，每个 Page 对象都包含一块内存，DiskManager 只是使用它作为一个内存中的位置来复制它从磁盘读取的物理页面的内容。 <strong>BufferPoolManagerInstance 将重用相同的 Page 对象来存储数据</strong>，因为它来回移动到磁盘，即如果该 Page 写入了或重新拉取了都有可能是不同的内容。 <strong>这意味着在系统的整个生命周期中，同一个 Page 对象可能包含不同的物理页面。</strong> Page 对象的标识符 (page_id) 跟踪它包含的物理页面； 如果 Page 对象不包含物理页面，则其 page_id 必须设置为 INVALID_PAGE_ID。</p><p>每个 Page 对象还维护一个计数器，用于 “pinned” 该页面的线程数。BufferPoolManagerInstance 不允许释放pinned 的页面。 每个 Page 对象还跟踪它是否是 dirty 状态。如果一个页被修改了，那应该将其设置为 dirty 状态。 <strong>BufferPoolManagerInstance 必须将脏页的内容写回磁盘，然后才能重用该对象。</strong></p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>这几个函数实现起来还是相对简单的，基本上都给出了详细的步骤，并且可以结合头文件中的注释来写，这里只记录一下碰到的一些坑。</p><ol><li><p>在 <strong>FlushPgImp</strong> 函数中，<strong>不要去做多余的判断</strong>，因为文档注释中已经明确指出<strong>只有在页表中找不到该页的时候才返回 false，否则返回 true。</strong>并且不管这个页是否是脏页都将其写回磁盘，否则有些测试是无法通过的。</p></li><li><p>在 <strong>NewPgImp</strong> 函数和 <strong>FetchPgImp</strong> 函数中，需要判断缓存池是否已满和缓存池中的页是否都是 pinned 状态：If all the pages in the buffer pool are pinned, return nullptr。但很容易由于这句话而去循环遍历所有的页来判断，其实并不需要，我的做法是判断空闲列表是否为空且 <strong>Replacer</strong> 的长度是否为 0。如果空闲列表不为空，那肯定是可以拉取页的；如果空闲列表为空，但是 Replacer 的长度不为 0，就代表可以将 Replacer 中标记的页替换出去，仍旧可以拉取页。<code>if (free_list_.empty() &amp;&amp; replacer_-&gt;Size() == 0) &#123; return nullptr; &#125;</code></p></li><li><p>使用 <strong>NewPgImp</strong> 函数创建新页时，一定要先确定是可以创建时再调用 <strong>AllocatePage</strong> 函数。</p></li><li><p><strong>UnpinPgImp</strong> 函数中，不能直接将 is_dirty 参数设置到属性中，需要判断一下 is_dirty 是否为 true。如果参数是 false，而实际上该页是脏页，那么就可能会丢失数据。</p></li><li><p>使用<code>std::lock_guard&lt;std::mutex&gt; guard(latch_)</code>来给函数上锁，在 return 的时候会自动释放锁。</p></li></ol><h2 id="TASK-3-PARALLEL-BUFFER-POOL-MANAGER"><a href="#TASK-3-PARALLEL-BUFFER-POOL-MANAGER" class="headerlink" title="TASK #3 - PARALLEL BUFFER POOL MANAGER"></a>TASK #3 - PARALLEL BUFFER POOL MANAGER</h2><h3 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h3><ul><li><strong>ParallelBufferPoolManager(num_instances, pool_size, disk_manager, log_manager)</strong></li><li><strong>~ParallelBufferPoolManager()</strong></li><li><strong>GetPoolSize()</strong></li><li><strong>GetBufferPoolManager(page_id)：</strong>根据 page_id 获取对应的 <strong>BufferPoolManagerInstance</strong>。</li><li><strong>FetchPgImp(page_id)</strong></li><li><strong>UnpinPgImp(page_id, is_dirty)</strong></li><li><strong>FlushPgImp(page_id)</strong></li><li><strong>NewPgImp(page_id)</strong></li><li><strong>DeletePgImp(page_id)</strong></li><li><strong>FlushAllPagesImpl()</strong></li></ul><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>单个 <strong>BufferPoolManagerInstance</strong> 需要使用锁以保证线程安全，在线程多的情况下会造成大量的竞争，所以该任务的意图就是使用多个 <strong>BufferPoolManagerInstance</strong> 来解决大量竞争的问题。</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>Task 3 的实现就比较简单了，基本上方法就是两行代码，首先使用 <strong>GetBufferPoolManager</strong> 获取 <strong>BufferPoolManagerInstance</strong>，再调用对应方法即可。可以使用一个数组来存储这些 <strong>BufferPoolManagerInstance</strong>，在构造函数中对其进行初始化。参数中的 <strong>num_instances</strong> 是 <strong>BufferPoolManagerInstance</strong> 的数量，instance_index 是每个 <strong>BufferPoolManagerInstance</strong> 对应的索引，初始化的时候要注意一下不要写反。</p><p>唯一一个不是两行搞定的就是 NewPgImp 函数，该函数的时候使用 <strong>round robin</strong> 的方式从一个起始位置（一开始设置为 0 ）开始遍历，直到成功返回 page 或者索引又回到了起始位置返回 nullptr，遍历结束后将起始索引顺序移动一位（需要用模运算，因为相当于在一个环中移动）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Page *<span class="title">ParallelBufferPoolManager::NewPgImp</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(latch_)</span></span>; <span class="comment">// 只在该函数中加了锁</span></span><br><span class="line">  <span class="type">size_t</span> index = next_index_;</span><br><span class="line">  Page *page;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    page = buffer_pool_manager_instances_[index]-&gt;<span class="built_in">NewPage</span>(page_id);</span><br><span class="line">    <span class="keyword">if</span> (page != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index = (index + <span class="number">1</span>) % num_instances_;</span><br><span class="line">  &#125; <span class="keyword">while</span> (index != next_index_);</span><br><span class="line">  next_index_ = (next_index_ + <span class="number">1</span>) % num_instances_;</span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Project 1 虽然比较简单，但通过本次项目对缓存池有了一个更深的理解，代码提交之后 leaderboard 排到 80 多名，等再学一段时间 C++ 尝试优化一下，现在这门语言对我的心智负担太重了。往后有时间的话也可以看一下 <strong>DiskManager</strong> 具体是怎么实现的，</p>]]></content>
      
      
      <categories>
          
          <category> CMU 15-445 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab 文档 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to my blog!</p><p>I am a second-year graduate student majoring in computer science. I am very interested in system programming and database kernel, and I hope to work in this field in the future.</p><p>The reason I am called “bigboss” is that I am a big fan of the Metal Gear Solid game series.</p><p>I will upload some of my notes or project summaries during the learning process.</p><p>If there are any errors found or if you have any good suggestions, please contact me.</p><p>I am very willing to discuss these issues.</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>search</title>
      <link href="/search/index.html"/>
      <url>/search/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
