<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Golang 类型系统实现</title>
      <link href="/post/f6e74448.html"/>
      <url>/post/f6e74448.html</url>
      
        <content type="html"><![CDATA[<p>Golang 类型系统都离不开一个东西，那就是类型元数据。每个类型都有自己对应的类型元数据，正是这些类型元数据构成了 Golang 的类型系统。</p><h2 id="内置类型元数据"><a href="#内置类型元数据" class="headerlink" title="内置类型元数据"></a>内置类型元数据</h2><p>类型元数据的 header：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">    size       <span class="type">uintptr</span></span><br><span class="line">    ptrdata    <span class="type">uintptr</span></span><br><span class="line">    hash       <span class="type">uint32</span></span><br><span class="line">    tflag      tflag</span><br><span class="line">    align      <span class="type">uint8</span></span><br><span class="line">    fieldalign <span class="type">uint8</span></span><br><span class="line">    kind       <span class="type">uint8</span></span><br><span class="line">    alg        *typeAlg</span><br><span class="line">    gcdata     *<span class="type">byte</span></span><br><span class="line">    str        nameOff</span><br><span class="line">    ptrToThis  typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而除了 header 之外，还需要额外存储一些描述信息，比如 slice 的类型元数据则还有一个类型元数据的指针，指向 slice 中元素类型的类型元数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slicetype <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ   _type</span><br><span class="line">    elem  *_type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内置的类型，类型元数据都类似是这样</p><h2 id="自定类型元数据"><a href="#自定类型元数据" class="headerlink" title="自定类型元数据"></a>自定类型元数据</h2><p>如果是自定类型元数据，则还会有一个 uncommontype 结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> uncommontype <span class="keyword">struct</span> &#123;</span><br><span class="line">    pkgpath nameOff</span><br><span class="line">    mcount  <span class="type">uint16</span> </span><br><span class="line">    _       <span class="type">uint16</span> <span class="comment">// unused</span></span><br><span class="line">    moff    <span class="type">uint32</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>pkgpath：用于记录该类型所在的包路径；</li><li>mcount：该类型关联了多少种方法；</li><li>moff：表明从 uncommontype 结构体开始，偏移 moff 就能找到 method 数组，从而调用对应的方法。</li></ul><h2 id="别名-alias"><a href="#别名-alias" class="headerlink" title="别名 alias"></a>别名 alias</h2><p>我们知道根据现有类型创造新的类型有两种方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyType1 = <span class="type">int32</span></span><br><span class="line"><span class="keyword">type</span> MyType2 <span class="type">int32</span></span><br></pre></td></tr></table></figure><p>而第一种方法，就称作起别名，它们会关联到同一个类型元数据，属于同一种类型。而第二种写法则是创建了新的类型，拥有自己的类型元数据。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Golang map 底层原理</title>
      <link href="/post/8f1e902e.html"/>
      <url>/post/8f1e902e.html</url>
      
        <content type="html"><![CDATA[<h2 id="map-数据结构"><a href="#map-数据结构" class="headerlink" title="map 数据结构"></a>map 数据结构</h2><p>在平常使用的 map 其实是一个语法糖，在底层实现中是一个 hmap 结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="type">int</span></span><br><span class="line">    flags     <span class="type">uint8</span></span><br><span class="line">    B         <span class="type">uint8</span></span><br><span class="line">    noverflow <span class="type">uint16</span></span><br><span class="line">    hash0     <span class="type">uint32</span></span><br><span class="line">    buckets    unsafe.Pointer</span><br><span class="line">    oldbuckets unsafe.Pointer</span><br><span class="line">    nevacuate  <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">    extra *mapextra</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>count：已经存储的键值对个数；</li><li>B：常规桶的个数为 2^B 个；</li><li>noverflow：溢出桶的个数；</li><li>hash0：hash seed，用于计算 key 的哈希值；</li><li>buckets：常规桶 bmap 的起始地址；</li><li>oldbuckets：在扩容时，保存原来常规桶的地址；</li><li>nevacuate：在渐进式扩容时，指明下一个要迁移的旧桶编号。</li></ul><p>map 中一个 bucket 由结构体 bmap 表示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    values   [<span class="number">8</span>]valuetype</span><br><span class="line">    pad      <span class="type">uintptr</span></span><br><span class="line">    overflow <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 bucket 内最多装 8 个键值对，并且为了使得内存使用更加紧凑，以减少内存使用，将 8 个 key 放一起，8个 value 放一起，对每个 key 只保存其哈希值的高 8 位。</p><p>还有一个字段没有介绍，那就是 extra：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">    overflow     *[]*bmap <span class="comment">//把已经用到的溢出桶链起来</span></span><br><span class="line">    oldoverflow  *[]*bmap <span class="comment">//渐进式扩容时，保存旧桶用到的溢出桶</span></span><br><span class="line">    nextOverflow *bmap   <span class="comment">//下一个尚未使用的溢出桶</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面存储了溢出桶相关的信息。由于一个桶中只能存储 8 个键值对，当有新的键值对来了时，不可能马上发起扩容，因为扩容操作的代价是比较大的。所以这里引入了溢出桶。</p><p>当当前桶满了之后，检查 nextOverflow 看是否还有可用的溢出桶，如果有则将新的键值对放入溢出桶中，并将 bmap 的 overflow 设置为溢出桶的地址。</p><h2 id="map-使用的哈希函数"><a href="#map-使用的哈希函数" class="headerlink" title="map 使用的哈希函数"></a>map 使用的哈希函数</h2><p>在程序启动的时候，会检测 CPU 是否支持 AES，如果支持则会使用 AES Hash，否则将使用 memhash。</p><h2 id="map-key"><a href="#map-key" class="headerlink" title="map key"></a>map key</h2><p>在 Golang 中，所有能够用 &#x3D;&#x3D; 比较的类型都可以作为 map 的key。这是因为可以用 &#x3D;&#x3D; 比较的类型，它的类型元数据中都提供了 hash 和 equal 用来比较。</p><p>所以比如 slice，它的类型元数据中是没有提供可用的 equal 方法的，所以不能当做 map 的 key。</p><p>map 可以用 float64 作为 key 吗？理论上来说是可以的，因为 float64 是可以通过 &#x3D;&#x3D; 来比较的。但是用 float64 作为 key 会由于精度的问题出现一些诡异的现象，对 map 来说，可能几个不一样的 float64 值会是同样的 key。</p><p>这是因为 float64 作为 key 时，先要通过 math.Float64frombits 将 float64 转成 uint64，再插入 key 中。所以在将 float64 转换的过程中可能就会丢失精度了。</p><p>所以尽量不要使用 float64 作为 map 的 key。</p><h2 id="key-的定位过程"><a href="#key-的定位过程" class="headerlink" title="key 的定位过程"></a>key 的定位过程</h2><p>在 64 位机器上，key 通过哈希函数计算后，会得到 64 位的哈希值。如何计算这个 key 应该落在哪个桶中呢？要根据桶的数量来计算，如果 B 等于 5，则表明现在有 2^5 个桶。所以这时候会取哈希值的最低 5 位值来得到桶的编号。接着再用哈希值的最高 8 位（tophash），来判断应该放在哪个位置。</p><p>如果在常规桶中没有找到并且溢出桶不为空，则还要去溢出桶中寻找，直到找对应的 key，或者找遍所有的位置。</p><p>所以可以看出来，在哈希桶与哈希桶之间使用的是链地址法，而在哈希桶内部则使用的是开放定址法。</p><h2 id="map-扩容"><a href="#map-扩容" class="headerlink" title="map 扩容"></a>map 扩容</h2><h3 id="翻倍扩容"><a href="#翻倍扩容" class="headerlink" title="翻倍扩容"></a>翻倍扩容</h3><p>判断哈希表是否需要扩容的指标称作负载因子，即键值对的数量和桶数量的比值，Golang 中默认为 6.5。当超过负载因子的时候就出发翻倍扩容，分配新桶数目是旧桶的两倍，将 hmap.oldbuckets 指向旧桶，hmap.buckets 再指向新桶，并把 hmap.nevacuate 置为 0，表示接下来要迁移的桶为 0 号旧桶。</p><p>并且为了防止扩容占用的时间太长而导致性能抖动，所以选择了渐进式扩容，即把旧桶中的值分多次挪到新桶里。在触发扩容后，先分配新桶，并且标记该 map 正在扩容。在后续的读写操作中，如果发现 map 在扩容中，则迁移一部分键值到新桶里，这样可以把扩容消耗的时间分散到多次操作中。</p><p>直到所有旧桶迁移完毕后，hmap.oldbuckets 将会被设置为 nil 等待被 GC，一次翻倍扩容就结束了。</p><h3 id="等量扩容"><a href="#等量扩容" class="headerlink" title="等量扩容"></a>等量扩容</h3><p>与翻倍扩容不同的是，等量扩容的触发是由于使用的溢出桶过多了。</p><p>那用多少溢出桶算多呢？</p><ol><li>如果常规桶数量不大于 2^15，那么溢出桶比常规桶数量还多，就算多了；</li><li>如果常规桶数量大于 2^15，那么溢出桶的数量也大于 2^15 次方，就算多了。</li></ol><p>那等量扩容的作用是什么呢？反正桶的数量也没有变化。当 map 的负载因子没有超过上限，就表明其中其实没有那么多键值对，却还是用到了这么多溢出桶，说明该 map 中有很多键值对已经被删除了。</p><p>所以使用等量扩容可以将这些稀疏存储的键值对变得更加紧凑，可以减少对溢出桶的使用。</p><h2 id="map-的元素是可寻址的吗？"><a href="#map-的元素是可寻址的吗？" class="headerlink" title="map 的元素是可寻址的吗？"></a>map 的元素是可寻址的吗？</h2><p>由于扩容过程中，会发生键值对迁移，所以键值对的地址也会发生变化，从而导致 map 的元素是不可寻址的。如果要取一个 value 的地址则不能通过编译。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang GMP 调度模型</title>
      <link href="/post/67b9b504.html"/>
      <url>/post/67b9b504.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-GMP"><a href="#什么是-GMP" class="headerlink" title="什么是 GMP"></a>什么是 GMP</h2><p>GMP 是 goroutine 调度器的调度模型。</p><ul><li>G：goroutine 协程；</li><li>M：thread 线程；</li><li>P：processor 处理器&#x2F;调度器。</li></ul><p>M 是运行 G 的实体，P 的功能是把可运行的 G 分配到 M 上。</p><p>在 GMP 模型中，G 被放在队列中等待被调度，而队列又分为两种：全局队列和本地队列，正是因为本地队列的加入才有了 GMP 模型，否则只是 GM 模型，所以每个 P 都有自己的本地队列。这样做的好处是，避免了所有的处理器都需要去全局队列中获取 G，产生竞争降低性能。</p><p>在创建 G 的时候，首先将 G 放入本地队列中，如果本地队列已经满了，则将本地队列中的一半移动到全局队列中。</p><p>如果线程想要运行任务，则要先获取到 P，在 P 中的本地队列中获取 G，当本地队列为空时，M 就会尝试去全局队列中拿一批 G 放到本地队列，或者也可以从其它 P 的本地队列中偷取一半到自己获取的 P 的本地队列。</p><h2 id="有关-M-和-P-的个数问题"><a href="#有关-M-和-P-的个数问题" class="headerlink" title="有关 M 和 P 的个数问题"></a>有关 M 和 P 的个数问题</h2><ol><li><p>P 的数量：P 的数量由环境变量 $GOMAXPROCS 来决定，也可以通过 runtim.GOMAXPROCS() 来设置。</p></li><li><p>M 的数量：go 程序启动时，默认设置的线程数量为 10000。当一个 M 阻塞时，会创建新的 M。</p></li></ol><p>P 和 M 的数量并没有绝对的关系，当一个 M 阻塞了，P 就会去创建或切换到另一个 M。所以即使只有 1 个 P 也可能会有很多个 M。</p><p>当 P 的最大数量已经决定后，runtime 就会根据这个数量去创建 P。而 M 是在没有足够的 M 关联 P 并运行 P 中的 G 时会创建新的 M。</p><h2 id="调度器的设计策略"><a href="#调度器的设计策略" class="headerlink" title="调度器的设计策略"></a>调度器的设计策略</h2><p>核心思想：复用线程，避免频繁创建、销毁线程的开销，尽量的复用线程。</p><ol><li>work stealing 机制：当 M 关联的 P 上没有可以运行的 G 时，去其它 P 那里窃取 G 来继续运行，而不会销毁线程 G；</li><li>hand off 机制：当 M 进行系统调用陷入内核前，该 M 会让出 P，解除于当前 P 的强关联。让其它 M 使用，但会在 M 中记录这个让出的 P，当该 M 从系统调用中被恢复时，会去找让出来的这个 P，如果没被占用就继续使用，否则将自己 G 放到全局队列中去，进入休眠。</li></ol><p>并且，在 Golang 中，协程实现了抢占式调度，所以一个 goroutine 最多能占用 CPU 10 ms，防止其它 goroutine 被饿死。</p><p>在 go1.13 之前的抢占式调度都依赖于栈增长检测代码，但如果不进行函数调用，就没有机会触发栈增长检测，如陷入了一个死循环，这样就无法让出 CPU 了，所以在 go1.13 之前的抢占式调度都不算真正意义上的抢占式调度。</p><p>在 go1.14 中实现了真正的异步抢占。在 Unix 系统中，会向需要让出的线程发起 SIGPREEMPT 信号，收到该信号的线程会进入中断，去执行相应的信号处理函数，检测到信号为 SIGPREEMPT 时，会向当前线程的上下文中注入一个异步抢占函数，在线程从内核返回时，会去执行异步抢占函数。   </p><h2 id="M0-和-G0"><a href="#M0-和-G0" class="headerlink" title="M0 和 G0"></a>M0 和 G0</h2><p>M0 是程序启动之后编号为 0 的主线程，这个 M 对应的实例在 runtime.m0 中，它负责初始化操作和启动第一个 G，在这之后 M0 就和其他 M 没区别了。</p><p>G0 则是每次启动一个 M 都会创建的第一个 goroutine，G0 仅仅用于调度和协调其它 goroutine，而不负责运行函数。在系统调用或调度时会使用 G0 的栈空间。</p><h2 id="GMP-中有哪些状态？"><a href="#GMP-中有哪些状态？" class="headerlink" title="GMP 中有哪些状态？"></a>GMP 中有哪些状态？</h2><ul><li>G 的状态：<ol><li>_Gidle：刚刚分配还没有被初始化；</li><li>_Grunnable：处在就绪态的 goroutine，没有执行代码，还在本地队列或全局队列中等待被调度；</li><li>_Grunning：正在执行代码的 goroutine；</li><li>_Gsyscall：正在执行系统调用，与某个 M 绑定，但和该 M 一起与 P 脱离；</li><li>_Gwaiting：被阻塞的 goroutine，可能阻塞在某个 chan 上；</li><li>_Gdead：表示当前 goroutine 已经结束执行或已被垃圾回收，不再具有实际的执行意义。</li><li>_Gcopystack：栈正在被复制。</li><li>_Gscan：GC 正在扫描栈空间，没有执行代码，可以和其他状态同时存在。</li></ol></li><li>P 的状态：<ol><li>_Pidle：当前 P 没有运行用户代码，且运行队列为空；</li><li>_Prunning：当前 P 被 M 持有，并且正在运行用户代码；</li><li>_Psyscall：当前 P 没有执行用户代码，并且绑定的 M 陷入系统调用；</li><li>_Pgcstop：当前 P 由于 GC 而进入 STW；</li><li>_Pdead：当前 P 已经不再使用。</li></ol></li><li>M 的状态：<ol><li>自旋线程：处于运行状态但没有可执行的 goroutine 的线程，数量最多为 GOMAXPROC 个，大于这个数量的 M 会进入休眠；</li><li>非自旋线程：处于运行状态并且有可执行 goroutine 的线程。</li></ol></li></ul><h2 id="G-状态的转换"><a href="#G-状态的转换" class="headerlink" title="G 状态的转换"></a>G 状态的转换</h2><p>![G 状态转变图](..&#x2F;images&#x2F;G 状态转变图.png)</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang Mutex 的原理</title>
      <link href="/post/a34ceac6.html"/>
      <url>/post/a34ceac6.html</url>
      
        <content type="html"><![CDATA[<p>sync.Mutex 是 Golang 提供的互斥锁，使用起来非常简单，只需要 Lock() 加锁，Unlock() 解锁就可以了。但其内部实现却不算简单。</p><h2 id="Mutex-结构体"><a href="#Mutex-结构体" class="headerlink" title="Mutex 结构体"></a>Mutex 结构体</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">state <span class="type">int32</span></span><br><span class="line">sema  <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>state：表示该互斥锁的状态；</li><li>sema：信号量，协程就在这个信号量上排队等待。</li></ul><p>state 是一个 32 位整数，但它会被拆成四份来使用，从低到高位：</p><ul><li>最低位 Locked：表示该互斥锁是否被锁定；</li><li>第二位 Woken：表示是否有协程已被唤醒，用于决定释放锁的协程是否需要释放信号量；</li><li>第三位 Starving：该互斥锁是否处于饥饿状态，饥饿状态意为有协程阻塞超过了 1ms；</li><li>剩下的 29 位 Waiter：表示阻塞等待该互斥锁的协程数量；</li></ul><p>所以我们可以知道所谓加锁就是在争抢给最低位 Locked 赋值的权利，抢到了就获取锁成功，否则只能去信号量上排队等待了，一旦持有锁的协程释放锁，等待锁的协程会被依次唤醒。</p><h3 id="协程如何在信号量上排队等待？"><a href="#协程如何在信号量上排队等待？" class="headerlink" title="协程如何在信号量上排队等待？"></a>协程如何在信号量上排队等待？</h3><p>要通过 runtime.semaphore 来实现，这是可供协程使用的信号量，runtime 内部会通过一个大小为 251 的 semaTable 来管理所有的 semaphore。semaTable 中存储了 251 棵平衡树的根。</p><p>要使用信号量时，就比如 Mutex 中的 sema，会先用这个 sema 映射到 sematable 中的某棵平衡树上，找到对应的节点，就找到了该信号量的等待队列。</p><h2 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h2><p>加锁过程可以分为简单加锁和加锁时被阻塞的情况。</p><h3 id="简单加锁"><a href="#简单加锁" class="headerlink" title="简单加锁"></a>简单加锁</h3><p>当前只有一个协程想要加锁，那么直接判断 Locked 是否为 0，如果是 0 则把 Locked 置为 1，加锁成功，其它位不会有变化。</p><h3 id="加锁被阻塞"><a href="#加锁被阻塞" class="headerlink" title="加锁被阻塞"></a>加锁被阻塞</h3><p>当加锁时，发现 Locked 位为 1，那么 Waiter 就会加 1，该协程被阻塞，直到 Locked 值变为 0 后才被唤醒。</p><h2 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h2><p>解锁过程可以分为简单解锁和解锁并唤醒正在排队等待的协程。</p><h3 id="简单解锁"><a href="#简单解锁" class="headerlink" title="简单解锁"></a>简单解锁</h3><p>解锁时，没有其他协程阻塞等待，只要将 Locked 位置为 0 即可，不需要释放信号量。</p><h3 id="解锁并唤醒协程"><a href="#解锁并唤醒协程" class="headerlink" title="解锁并唤醒协程"></a>解锁并唤醒协程</h3><p>解锁时，由于有其他协程在阻塞等待，所以除了将 Locked 位置为 0 之外，还要释放信号量，唤醒正在排队等待的协程。</p><h2 id="Mutex-的模式"><a href="#Mutex-的模式" class="headerlink" title="Mutex 的模式"></a>Mutex 的模式</h2><p>Mutex 有两种模式，由 Starving 位决定。</p><h3 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h3><p>在正常模式下，协程加锁不成功不会立刻进入阻塞排队，而会先判断是否符合自旋的条件，如果条件满足会先尝试自旋抢锁。</p><h3 id="饥饿模式"><a href="#饥饿模式" class="headerlink" title="饥饿模式"></a>饥饿模式</h3><p>如果一个协程自上一次阻塞到这一次阻塞超过 1ms 的时间，那么该互斥锁会进入饥饿状态。处于饥饿状态下的互斥锁，没有自旋过程，加锁失败的协程会直接进入阻塞排队。在持有锁的协程释放锁时，被唤醒的协程一定会获取锁成功。</p><h3 id="自旋的条件"><a href="#自旋的条件" class="headerlink" title="自旋的条件"></a>自旋的条件</h3><p>无限制的自旋将使得 CPU 利用率降低，所以需要有一定的条件来限制：</p><ol><li>自旋次数不能太多，最多为 4 次；</li><li>CPU 核数要大于 1，否则自旋没有意义；</li><li>runtime 设置的 Process 数量也要大于 1；</li><li>P 的可运行队列必须为空才能进行自旋，否则调度其它协程上来执行更好。</li></ol><h3 id="自旋的优势"><a href="#自旋的优势" class="headerlink" title="自旋的优势"></a>自旋的优势</h3><p>自旋可以尽量避免协程切换，不必进入阻塞状态，如果自旋获取锁之后可以继续运行。</p><h3 id="自旋的问题"><a href="#自旋的问题" class="headerlink" title="自旋的问题"></a>自旋的问题</h3><p>由于正在自旋的协程当前在 CPU 上运行，所以相比于刚被唤醒的协程更容易获取锁，那么之前被阻塞的锁将很难获得锁，从而进入饥饿状态。</p><p>为了解决这个问题，Go 1.8 以来增加了一个饥饿状态，在饥饿模式下，新来的协程直接去最后排队，这样避免了自旋。</p><h2 id="Woken-状态"><a href="#Woken-状态" class="headerlink" title="Woken 状态"></a>Woken 状态</h2><p>Woken 状态用于加锁和解锁过程的通信，两个协程一个在自旋加锁一个在解锁，自旋加锁的这个协程会把 Woken 标记为 1，也就是告诉解锁协程不必去释放信号量，因为这个自旋的协程就相当于是唤醒了。</p><h2 id="为什么重复-Unlock-会-panic？"><a href="#为什么重复-Unlock-会-panic？" class="headerlink" title="为什么重复 Unlock 会 panic？"></a>为什么重复 Unlock 会 panic？</h2><p>Unlock 的过程会先将 Locked 置为 0，然后判断 Waiter 值，如果值 &gt; 0 则释放信号量，如果多次 Unlock 而不 panic 的话，则会释放多个信号量，会唤醒多个协程，这多个协程会继续在 Lock() 逻辑里抢锁，增加了 Lock() 实现的难度，也引起了不必要的协程切换。</p><h2 id="Mutex-的使用技巧"><a href="#Mutex-的使用技巧" class="headerlink" title="Mutex 的使用技巧"></a>Mutex 的使用技巧</h2><ol><li>加锁后可以使用 defer 来解锁，防止死锁；</li><li>加锁、解锁最好出现在同一层的代码块中，如同一个函数；</li><li>避免重复的 Unlock，否则会出现 panic。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang GC 过程及原理</title>
      <link href="/post/4425c0d3.html"/>
      <url>/post/4425c0d3.html</url>
      
        <content type="html"><![CDATA[<p>所谓的 GC 就是回收掉不再需要使用的内存块，在 Java、Go 这样的带自动回收的语言中，会自动清理掉这样的垃圾内存，而在不支持垃圾回收的语言如 C++ 中，如果没有手动释放掉内存，那么这些内存就是内存泄漏。</p><h2 id="Golang-使用的垃圾回收算法"><a href="#Golang-使用的垃圾回收算法" class="headerlink" title="Golang 使用的垃圾回收算法"></a>Golang 使用的垃圾回收算法</h2><p>Golang 用到的垃圾回收算法是标记清扫算法，用<strong>三色抽象</strong>可以清晰的展现追踪过程中数据标记的变化：</p><ol><li>垃圾回收开始的时候将所有对象都标记为白色；</li><li>把直接追踪到的根节点标记为灰色，灰色就表示基于当前节点展开的追踪还未完成；</li><li>遍历根节点所有的子节点，并将子节点标记为灰色，当该根节点的子节点都遍历完成之后，将根节点标记为黑色；</li><li>继续将灰色节点的子节点拿出来进行标记，直到没有灰色节点了，那么剩下的白色节点都是垃圾。</li></ol><p>有点类似于层序遍历的过程。</p><p>在 Golang 中，着色为灰色意味着将 mspan 结构体中的 gcmarkBits 位图中对应的位设置为 1，并加入全局变量 work 中的工作队列；着色为黑色意味着将 gcmarkBits 对应的位设置为 1；而着色为白色则意味着 gcmarkBits 对应的位为 0。</p><p>在扫描时堆上写入的对象会直接被置为黑色。</p><h2 id="Golang-GC-的三种模式"><a href="#Golang-GC-的三种模式" class="headerlink" title="Golang GC 的三种模式"></a>Golang GC 的三种模式</h2><ol><li>gcBackgroundMode，默认模式，标清清扫都是并发执行（<strong>用户程序与垃圾回收程序并发执行</strong>）的；</li><li>gcForceMode，只在清扫阶段并发；</li><li>gcForceBlockMode，GC 全程 STW。</li></ol><p>我们只要重点了解默认模式即可。</p><h2 id="Golang-GC-过程中的两个全局变量"><a href="#Golang-GC-过程中的两个全局变量" class="headerlink" title="Golang GC 过程中的两个全局变量"></a>Golang GC 过程中的两个全局变量</h2><ol><li>gcController：用于在标记过程中记录一些信息，比如一个标记周期中，不同类型的 mark worker 是否还需要启动；是否需要辅助标记；已经执行了多少扫描工作等等；</li><li>work：用于存储全局工作信息，比如提供全局工作队列缓存，记录栈、数据段等需要扫描的 root 节点的相关信息。</li></ol><h2 id="gcBackgroundMode-执行流程"><a href="#gcBackgroundMode-执行流程" class="headerlink" title="gcBackgroundMode 执行流程"></a>gcBackgroundMode 执行流程</h2><ol><li>标记准备阶段：完成上一轮没有完成的清扫工作；为每个 P 创建自己的 mark worker，但暂时先进入休眠，等待到标记阶段被调度；</li><li>第一次 STW：进行一些同步工作。开启写屏障，GC 进入 _GCMark 阶段；在全局变量 work 中记录 bss 段、数据段和栈上的 root 节点信息。</li><li>结束 STW，进入并发标记阶段：mark worker 得到调度，进行扫描工作，直到没有灰色节点。</li><li>第二次 STW：GC 进入 GCMarkTermination 阶段，停止 mark worker 和 assist worker。GC 再进入 GCOff 阶段，并关闭写屏障。</li><li>进入清扫阶段：在清扫阶段 sweeper 协程会被放到工作队列中等待调度，等到它被调度时就进行清扫工作，而且申请内存的协程也会进行辅助清扫。</li></ol><h2 id="什么是写屏障？"><a href="#什么是写屏障？" class="headerlink" title="什么是写屏障？"></a>什么是写屏障？</h2><p>写屏障指的是会在写操作中插入指令，来通知垃圾回收器对象被修改了，并且要把修改记录到记录集中。</p><p>如果有了写屏障，那么就可以不用担心 GC 在扫描的过程中的内存变化，比如清扫掉了正在使用的内存，以为如果一个白色对象又有其它对象引用的话，垃圾回收器是可以知道的。是一种优化 GC 的手段。</p><h3 id="插入写屏障"><a href="#插入写屏障" class="headerlink" title="插入写屏障"></a>插入写屏障</h3><p>插入写屏障指的是给黑色对象增加引用时触发写屏障，比方说给黑色对象 A 增加到白色对象 C 的引用时，会将 C 着色为灰色，或者将 A 退回灰色。</p><h3 id="删除写屏障"><a href="#删除写屏障" class="headerlink" title="删除写屏障"></a>删除写屏障</h3><p>白色对象 C 是一个被黑色对象 A 引用的对象，删除灰色对象 B 到白色对象 C 的引用时，会把白色对象 C 着色为灰色。这样可以防止 C 被回收。</p><h3 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="混合写屏障"></a>混合写屏障</h3><p>混合写屏障就是 Golang 采用的方式，结合了插入写屏障和删除写屏障来最大化减小 STW 的时间。</p><h2 id="Golang-的标记清扫法具体是如何缩短-GC-暂停时间的？"><a href="#Golang-的标记清扫法具体是如何缩短-GC-暂停时间的？" class="headerlink" title="Golang 的标记清扫法具体是如何缩短 GC 暂停时间的？"></a>Golang 的标记清扫法具体是如何缩短 GC 暂停时间的？</h2><p>GC 只会在回收周期开始与标记结束时采用 STW 来进行必要的同步，标记和清扫工作都是并发执行的，而清扫则是 lazy 的，一部分开销也会分摊到内存分配过程中。</p><p>在引入混合写屏障之前，只有插入写屏障，这需要对所有堆栈的写操作都开启写屏障，代价太大。所以为了让这个开销变小，选择忽略协程栈上的写操作，在标记完所有对象后，再遍历一次那些被激活的栈帧。但由于 Go 程序通常会有大量的协程，重新扫描栈帧的代价也很大。</p><p>所以用这种方式，就需要在扫描栈帧的时候 STW，又导致 STW 时间过长。如果可以在忽略栈上的写操作的同时又能够保证写入栈上的数据不会让 mark worker 不知道，就可以不用 STW 了。</p><p>删除写屏障刚好符合这个要求。所以用到混合写屏障可以大大减少第二次 STW 的时间。</p><h2 id="Golang-GC-如何缓解内存分配压力"><a href="#Golang-GC-如何缓解内存分配压力" class="headerlink" title="Golang GC 如何缓解内存分配压力"></a>Golang GC 如何缓解内存分配压力</h2><p>golang 实现了辅助标记和辅助清扫工作，也就是在分配内存的时候，需要先协助进行标记或清扫才能获得内存。</p><p>或者可以用 gcController 那里窃取 credit，因为 mark worker 和 sweeper 进行的标记清扫工作的额度会存放在这里。</p><h2 id="Golang-GC-如何解决并发标记的分工问题？"><a href="#Golang-GC-如何解决并发标记的分工问题？" class="headerlink" title="Golang GC 如何解决并发标记的分工问题？"></a>Golang GC 如何解决并发标记的分工问题？</h2><p>每个 P 都有自己的工作队列 wbuf1 和 wbuf2，总是从 wbuf1 添加任务，如果 wbuf1 满了就将二者交换，如果还是满的就将当前的 wbuf 放到全局变量 work 中的全局工作队列中。</p><p>这样的话，如果自己的工作队列太满了，就可以分配一部分到全局工作队列中让本地工作队列为空的 P 获取任务，反之也可以从全局工作队列中获取其它 P 来不及处理的任务。</p><h2 id="Golang-GC-如何控制-GC-的-CPU-使用率？"><a href="#Golang-GC-如何控制-GC-的-CPU-使用率？" class="headerlink" title="Golang GC 如何控制 GC 的 CPU 使用率？"></a>Golang GC 如何控制 GC 的 CPU 使用率？</h2><p>GC 的目标 CPU 使用率为 25%，所以会以 CPU 核心数乘以 CPU 目标使用率来决定启动多少 mark worker，如果出现小数就 +0.5，但这样可能会与目标有所偏差，所以 mark worker 也有两种类型：</p><ul><li>Dedicated：一直执行标记任务直到被抢占；</li><li>Fractional：除了被抢占外还可以主动让出。</li></ul><p>在全局变量 gcController 中会记录启动了多少 Dedicated worker，也会记录 Fractional worker 需要完成多少任务。当调度器恢复 mark worker 的时候，要设置worker运行的模式，如果 Dedicated 模式的 worker 数量还没达到上限，就设置为 Dedicated，否则就看 Fractional worker 是否已经达到了工作量，没有达到就设置为 Fractional worker。</p><p>当 Fractional worker 达到工作量之后，就可以自行让出 CPU，来达到控制 CPU 使用率的效果。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang 堆内存管理和分配原理</title>
      <link href="/post/80a40d2a.html"/>
      <url>/post/80a40d2a.html</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Golang 的 runtime 将堆地址空间划分为 arena。在 Linux 环境下每个 arena 是 64 MB，每个 arena 中又有 8192 个 page，每个 page 为 8KB。</p><p>为了防止出现出现大量内存碎片，Golang 采用了类似于 Google 的 tcmalloc 的内存分配算法：将堆内存按一组预设大小规格划分成内存块，再把这些不同规格的内存块以链表的形式组织。</p><p>在申请内存时，会先找到最匹配的规格，去对应的空闲链表中获取一个内存块。这样可以降低外部内存碎片的概率。</p><p>Golang 中有 67 种预设规格，从 8B 到 32KB。所以 arena 中会按需划分出不同的 span，每个 span 包含一组连续的 page，并且按照特定规格划分成了等大的内存块。</p><h2 id="涉及堆内存管理的结构体"><a href="#涉及堆内存管理的结构体" class="headerlink" title="涉及堆内存管理的结构体"></a>涉及堆内存管理的结构体</h2><p>arena、span、page 和内存块组成了 Golang 堆内存的堆内存 heap，它们自然也有各自对应的结构体来管理堆内存。</p><h3 id="heapArena"><a href="#heapArena" class="headerlink" title="heapArena"></a>heapArena</h3><p>heapArena 结构体对应 arena：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> heapArena <span class="keyword">struct</span> &#123;</span><br><span class="line">  bitmap       [heapArenaBitmapBytes]<span class="type">byte</span></span><br><span class="line">  spans        [pagesPerArena]*mspan</span><br><span class="line">  pageInUse    [pagesPerArena / <span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">  pageMarks    [pagesPerArena / <span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">  pageSpecials [pagesPerArena / <span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">  checkmarks   *checkmarksMap</span><br><span class="line">  zeroedBase   <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中存储着 arena 的元数据，有很多位图标记：</p><ul><li>bitmap：用一位标记这个 arena 中，一个指针大小的内存单元是指针还是标量，再用一位标记这块内存空间的后续单元是否包含指针。用于 GC 扫描阶段。</li><li>pageInUse：用于标记处于使用状态的 span 的第一个 page。</li><li>pageMarks：用于标记每个 span 的第一个 page，在 GC 标记阶段会修改这个位图，标记哪些 span 中存在被标记的对象，在 GC 清扫阶段根据这个位图来释放不含标记对象的 span。</li><li>spans：用来标记某个 page 对应哪一个 span。</li></ul><h3 id="mspan"><a href="#mspan" class="headerlink" title="mspan"></a>mspan</h3><p>mspan 中管理 span 中一组连续的 page：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">  next           *mspan</span><br><span class="line">  prev           *mspan</span><br><span class="line">  list           *mSpanList</span><br><span class="line">  startAddr      <span class="type">uintptr</span></span><br><span class="line">  npages         <span class="type">uintptr</span></span><br><span class="line">  manualFreeList gclinkptr</span><br><span class="line">  freeindex      <span class="type">uintptr</span></span><br><span class="line">  nelems         <span class="type">uintptr</span></span><br><span class="line">  allocCache     <span class="type">uint64</span></span><br><span class="line">  allocBits      *gcBits</span><br><span class="line">  gcmarkBits     *gcBits</span><br><span class="line">  sweepgen       <span class="type">uint32</span></span><br><span class="line">  divMul         <span class="type">uint16</span></span><br><span class="line">  baseMask       <span class="type">uint16</span></span><br><span class="line">  allocCount     <span class="type">uint16</span></span><br><span class="line">  spanclass      spanClass</span><br><span class="line">  state          mSpanStateBox</span><br><span class="line">  needzero       <span class="type">uint8</span></span><br><span class="line">  divShift       <span class="type">uint8</span></span><br><span class="line">  divShift2      <span class="type">uint8</span></span><br><span class="line">  elemsize       <span class="type">uintptr</span></span><br><span class="line">  limit          <span class="type">uintptr</span></span><br><span class="line">  speciallock    mutex</span><br><span class="line">  specials       *special</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该 span 具体被划分成了什么规格大小跟 spanclass 有关，spanclass 的高 7 位用于标记内存规格的编号，对应 1-67，编号 0 被留出来表示大于 32KB 的内存，一共 68 中。</p><p>而 spanclass 的最低位用于标记这个 span 是否需要进行 GC 扫描，所以 span 又可以分为 scannable 和 non-scannable 两种，总共就是 136 种。</p><p>span 中的 nelems 记录该 span 被划分成多少内存块，而 freeIndex 记录这下一个空闲内存块的索引。</p><p>span 中也有一些位图：</p><ul><li>allocBits：标记哪些内存块被分配了；</li><li>gcmarkBits：用于在 GC 扫描阶段标记内存块。</li></ul><p>在 GC 清扫阶段会释放掉旧的 allocBits，把标记好的 gcmarkBits 用作 allocBits，因为没有在 gcmarkBits 标记下的内存块都被回收了，接着再重新分配一段清零的内存给 gcmarkBits。</p><h3 id="mcentral"><a href="#mcentral" class="headerlink" title="mcentral"></a>mcentral</h3><p>mcentral 是一个全局的 mspan 管理中心。每一种 span 对应一个 mcentral，所以 mcentral 也有 136 种。mcentral 将 mspan 按照用尽与未用尽的分别管理，而用尽的或未用尽的又会分成已清扫和未清扫的进行管理。</p><h3 id="mcache"><a href="#mcache" class="headerlink" title="mcache"></a>mcache</h3><p>由于使用全局的 mspan 管理中心会导致多个 P 之间对锁产生竞争，所以每个 P 也设置了自己的本地缓存，即 mcache。</p><p>当 P 想要获取特定规格的 mspan 时，先从本地的 mcache 中尝试获取，如果没有或用完了就去 mcentral 中找一个放到本地，把已经用尽的归还到 mcentral 中对应的 full set 中。</p><h2 id="堆内存分配过程"><a href="#堆内存分配过程" class="headerlink" title="堆内存分配过程"></a>堆内存分配过程</h2><p>堆内存分配的主要逻辑可以分为四个部分：</p><ol><li>辅助 GC；</li><li>空间分配；</li><li>位图标记；</li></ol><h3 id="辅助-GC"><a href="#辅助-GC" class="headerlink" title="辅助 GC"></a>辅助 GC</h3><p>考虑一种情况：当内存申请的速度超过了 GC 标记的速度，内存就分配不过来了。所以需要申请内存的协程参与到 GC 中来，即辅助 GC。要帮助扫描或清扫一部分内存之后，才可以得到内存。</p><p>每次参与辅助 GC 最少需要扫描 64KB，所有如果要申请的内存并没有到达 64KB，则多干的活可以留到下次再使用。</p><p>同时 mark worker 在进行清扫的时候，也会在全局 gcController 中的 bgScanCredit 中累积信用，这个信用是可以交由辅助 GC 的协程使用的。</p><h3 id="空间分配"><a href="#空间分配" class="headerlink" title="空间分配"></a>空间分配</h3><p>在辅助 GC 完成后就可以进行空间分配了。要根据需要分配的空间大小以及是否为 non-scannable 型的空间来使用不同的分配策略：</p><ul><li>当需要的空间小于 16B，并且为 non-scannable 空间的申请，就是用 tiny-allocator；</li><li>如果大于 32KB 则会直接分配到堆上；</li><li>大于等于 16B 且小于等于 32KB 的 non-scannable 空间和小于等于 32KB 的 scannable 空间的申请则按照预设大小规格来进行合适的分配。</li></ul><p>由于最小的预设规格为 8B，所以即使只需要 1B 的空间，按预设规格来分配也会分配出去 8B，所以每个 P 都有一个 16B 大小的 tiny 内存空间，可以将小的内存分配请求统一分到 tiny 内存空间来提高内存利用率。</p><h3 id="位图标记"><a href="#位图标记" class="headerlink" title="位图标记"></a>位图标记</h3><p>将 heapArena、mspan 中对应的位图进行标记。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang 基础知识</title>
      <link href="/post/53c12c48.html"/>
      <url>/post/53c12c48.html</url>
      
        <content type="html"><![CDATA[<h3 id="x3D-和-x3D-有什么区别？"><a href="#x3D-和-x3D-有什么区别？" class="headerlink" title="&#x3D; 和 :&#x3D; 有什么区别？"></a>&#x3D; 和 :&#x3D; 有什么区别？</h3><p>&#x3D; 用于给变量或常量赋值，而 :&#x3D; 用于定义并给变量赋值。</p><h3 id="new-和-make-的区别是什么？"><a href="#new-和-make-的区别是什么？" class="headerlink" title="new 和 make 的区别是什么？"></a>new 和 make 的区别是什么？</h3><ul><li>new 和 make 都用来分配内存，但 make 即分配内存也初始化内存，new 只将内存清 0，并不初始化内存；</li><li>make 返回的是引用类型本身，而 new 返回的是指向类型的指针；</li><li>make 只能用于分配并初始化 slice、map、chan 类型的数据，而 slice 可以给任何类型的数据分配内存。</li></ul><h3 id="Go-面向对象是如何实现的？"><a href="#Go-面向对象是如何实现的？" class="headerlink" title="Go 面向对象是如何实现的？"></a>Go 面向对象是如何实现的？</h3><p>面向对象即封装、继承、多态。</p><p>封装：对于同一个包，对象等对包内可见，而要对包外可见则需要将对象以大写开头；</p><p>继承：Go 以嵌套来实现继承，也就是在 struct 中加入需要继承的类；</p><p>多态：Go 的多态通过接口来实现，某个类型的实例可以赋给它所实现的任意接口类型的变量。</p><h3 id="二维切片如何初始化？"><a href="#二维切片如何初始化？" class="headerlink" title="二维切片如何初始化？"></a>二维切片如何初始化？</h3><p>先用 make 初始化一个二维数组，再遍历这个二维数组使用 make 初始化里面的一维数组。</p><h3 id="uint-类型变量分别为-1，2，它们相减的结果是多少？"><a href="#uint-类型变量分别为-1，2，它们相减的结果是多少？" class="headerlink" title="uint 类型变量分别为 1，2，它们相减的结果是多少？"></a>uint 类型变量分别为 1，2，它们相减的结果是多少？</h3><p>由于 uint 类型不能为复制，所以会溢出，在 32 位系统上结果为 2^32-1，在 64 位系统上为 2^64-1。</p><h3 id="go-有没有函数在-main-函数之前执行？怎么用？"><a href="#go-有没有函数在-main-函数之前执行？怎么用？" class="headerlink" title="go 有没有函数在 main 函数之前执行？怎么用？"></a>go 有没有函数在 main 函数之前执行？怎么用？</h3><p>init 函数会在 main 函数之前执行。</p><p>init 函数一个包中可以有多个，一个文件中也可以有多个。</p><p>在同一个包中执行顺序并不确定，不应该依赖 init 函数的执行顺序。</p><p>在不同包中，按照依赖关系来决定执行顺序。</p><p>init 函数在 runtime 导入包后，并初始化全局常量和全局变量之后，在 main 函数之前执行。</p><h3 id="如何知道一个对象是分配在栈上还是堆上？"><a href="#如何知道一个对象是分配在栈上还是堆上？" class="headerlink" title="如何知道一个对象是分配在栈上还是堆上？"></a>如何知道一个对象是分配在栈上还是堆上？</h3><p>即是否会发生逃逸。如果一个对象的大小无法在分配的时候确定，或它的作用域在函数结束了还没结束，那么它会被分配到堆上，否则分配到站上。</p><h3 id="有什么有时候要定义一个空值？"><a href="#有什么有时候要定义一个空值？" class="headerlink" title="有什么有时候要定义一个空值？"></a>有什么有时候要定义一个空值？</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ Codec = (*GobCodec)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>将 nil 转化成一个具体类型，再转化为一个接口类型，如果失败了说明该具体类型没有实现该接口类型的所有方法。</p><h3 id="什么是-rune-类型？"><a href="#什么是-rune-类型？" class="headerlink" title="什么是 rune 类型？"></a>什么是 rune 类型？</h3><p>Go 中的 rune 其实就是 int32 的别名，用于表示 Unicode 中的字符。但是 Go 的字符串底层表示是字节序列，而不是 rune 类型。</p><h3 id="如何判断-map-中是否包含某个-key？"><a href="#如何判断-map-中是否包含某个-key？" class="headerlink" title="如何判断 map 中是否包含某个 key？"></a>如何判断 map 中是否包含某个 key？</h3><p>map 会返回两个参数，第二个参数就是这个 key 是否存在。</p><h3 id="什么是-Go-协程（Goroutine）？"><a href="#什么是-Go-协程（Goroutine）？" class="headerlink" title="什么是 Go 协程（Goroutine）？"></a>什么是 Go 协程（Goroutine）？</h3><p>协程即用户态轻量级协程，是线程的基本调度单位，在函数前加上 go 关键字就能实现并发。一个 go 协程的大小很小，因此可以轻易实现成千上万个协程同时启动。</p><h3 id="如何高效拼接字符串？"><a href="#如何高效拼接字符串？" class="headerlink" title="如何高效拼接字符串？"></a>如何高效拼接字符串？</h3><ul><li>“+” 会对字符进行遍历，并开辟新的空间；</li><li>fmt.Sprintf 额外存在反射的性能损耗；</li><li>strings.Builder 底层使用 unsafe 直接把字节数组强制转为 string，避免了拷贝和分配新空间的开销；</li><li>bytes.Buffer 和 strings.Builder 类似，但是在将字节数组转化为 string 时使用了标准类型，多了内存分配的开销；</li><li>strings.Join 是基于 strings.Builder 实现的，但在内部调用了 b.Grow(n)，提前进行了分配，避免了后续扩容的开销。</li></ul><p>得出结论：strings.Join ≈ strings.Builder &gt; bytes.Buffer &gt; + &gt; fmt.Sprintf。</p><h3 id="defer-的执行顺序"><a href="#defer-的执行顺序" class="headerlink" title="defer 的执行顺序"></a>defer 的执行顺序</h3><p>defer 按照声明的顺序逆序执行，因为 defer 是注册在 Goroutine 上的结构体，以头插法维护一个链表，所以顺序遍历这个 defer 链表时自然就和插入顺序相反。</p><h3 id="Go-有异常类型吗？"><a href="#Go-有异常类型吗？" class="headerlink" title="Go 有异常类型吗？"></a>Go 有异常类型吗？</h3><p>没有，只有错误类型 Error。</p><h3 id="Go-允许多个返回值吗？"><a href="#Go-允许多个返回值吗？" class="headerlink" title="Go 允许多个返回值吗？"></a>Go 允许多个返回值吗？</h3><p>允许。</p><h3 id="如何判断两个字符串切片是相等的？"><a href="#如何判断两个字符串切片是相等的？" class="headerlink" title="如何判断两个字符串切片是相等的？"></a>如何判断两个字符串切片是相等的？</h3><p>使用反射包中的 reflect.DeepEqual(a, b) 来判断，但是性能非常差。</p><p>推荐使用遍历切片中的元素来比较。</p><h3 id="打印字符串时，-v-和-v-的区别？"><a href="#打印字符串时，-v-和-v-的区别？" class="headerlink" title="打印字符串时，%v 和 %+v 的区别？"></a>打印字符串时，%v 和 %+v 的区别？</h3><p>%v 打印 struct 的值，而 %+v 还会打印出 struct 字段的名称。</p><h3 id="Go-语言如何表示枚举？"><a href="#Go-语言如何表示枚举？" class="headerlink" title="Go 语言如何表示枚举？"></a>Go 语言如何表示枚举？</h3><p>iota。</p><h3 id="空结构体的作用是什么？"><a href="#空结构体的作用是什么？" class="headerlink" title="空结构体的作用是什么？"></a>空结构体的作用是什么？</h3><p>Go 语言对空结构体做了特别的优化，使得它完全不占用内存，可以用于作占位符。</p><p>比如可以用空结构体实现 Set 数据结构，再或者使用空结构体类型的 chan，来节省空间，也可以用于申明仅包含方法的结构体。</p><h3 id="Go-语言中-int-和-int32-是一个概念吗？"><a href="#Go-语言中-int-和-int32-是一个概念吗？" class="headerlink" title="Go 语言中 int 和 int32 是一个概念吗？"></a>Go 语言中 int 和 int32 是一个概念吗？</h3><p>不是，跟操作系统是多少位有关。</p><h3 id="Go-语言中-interface-可以比较吗？"><a href="#Go-语言中-interface-可以比较吗？" class="headerlink" title="Go 语言中 interface 可以比较吗？"></a>Go 语言中 interface 可以比较吗？</h3><p>可以。interface 内部实现中包含了 2 个字段，类型 T 和值 V，可以直接使用 &#x3D;&#x3D; 或 !&#x3D; 比较。interface 相等有两种情况：</p><ol><li>都为 nil；</li><li>T 和 V 都相等。</li></ol><h3 id="Go-语言中-nil-可以比较吗？"><a href="#Go-语言中-nil-可以比较吗？" class="headerlink" title="Go 语言中 nil 可以比较吗？"></a>Go 语言中 nil 可以比较吗？</h3><p>可以，只有同样类型的 nil 才相等。</p><h3 id="Go-语言函数返回局部变量的指针是否安全？"><a href="#Go-语言函数返回局部变量的指针是否安全？" class="headerlink" title="Go 语言函数返回局部变量的指针是否安全？"></a>Go 语言函数返回局部变量的指针是否安全？</h3><p>安全，因为 Go 会进行逃逸分析，如果局部变量的指针被返回，即作用域超出函数，则会把它分配到堆上。</p><h3 id="非接口的任意类型-T-都能够调用-T-的方法吗？反过来呢？"><a href="#非接口的任意类型-T-都能够调用-T-的方法吗？反过来呢？" class="headerlink" title="非接口的任意类型 T 都能够调用 *T 的方法吗？反过来呢？"></a>非接口的任意类型 T 都能够调用 *T 的方法吗？反过来呢？</h3><p>一个 T 类型的值想要调用 *T 类型声明的方法，当且仅当 T 是可寻址的。而由于 *T 是可以解引用的，所以它可以调用 T 类型声明的方法。</p><h3 id="Go-slice-是如何扩容的？"><a href="#Go-slice-是如何扩容的？" class="headerlink" title="Go slice 是如何扩容的？"></a>Go slice 是如何扩容的？</h3><p>在 go 1.18 之前当 slice 的容量小于 1024 的时候，成倍增长，而当 slice 容量大于 1024 的时候以 1.25 的倍率增长。</p><p>但是在 go 1.18 时，这个阈值变成了 256。扩容的逻辑也有所变化：</p><ol><li>如果期望的容量比原容量的两倍还大，那么新容量直接等于期望的容量；</li><li>否则如果原容量小于 256，那么新容量就等于两倍的原容量；</li><li>如果原来大于等于 256，那么循环增加 1.25 倍加上 192，直到满足新容量。</li></ol><p>接着会通过 growslice 函数传入的切片的类型元数据来进行内存对齐。</p><h3 id="无缓冲的-chan-和有缓冲的-chan-有什么区别？"><a href="#无缓冲的-chan-和有缓冲的-chan-有什么区别？" class="headerlink" title="无缓冲的 chan 和有缓冲的 chan 有什么区别？"></a>无缓冲的 chan 和有缓冲的 chan 有什么区别？</h3><p>是否有缓冲区决定了是否会阻塞。</p><h3 id="为什么有协程泄露？"><a href="#为什么有协程泄露？" class="headerlink" title="为什么有协程泄露？"></a>为什么有协程泄露？</h3><p>可能有以下几种原因：</p><ul><li>goroutine 被 chan 阻塞，无法退出；</li><li>goroutine 进入死循环。</li></ul><p>要避免协程泄露，就要在创建协程的时候就考虑如何终止协程，可以为协程添加一个 for select 来通知协程退出。可以添加一个空结构体类型的 chan 来发送通知，也可以直接关闭发送消息的 chan。</p><h3 id="常见的-Goroutine-操作函数有哪些？"><a href="#常见的-Goroutine-操作函数有哪些？" class="headerlink" title="常见的 Goroutine 操作函数有哪些？"></a>常见的 Goroutine 操作函数有哪些？</h3><ul><li>runtime.GOMAXPROCS(num int)：可以用于设置线程数目，默认值为 CPU 逻辑核数，如果设置的过大会引起频繁的性能切换，降低性能；</li><li>runtime.Gosched()：让当前 goroutine 让出 CPU 时间片；</li><li>runtime.Goexit()：让当前 goroutine 运行终止，并且会执行 defer，在主协程中调用该函数会引起 panic。</li></ul><h3 id="什么是-Go-竞态？"><a href="#什么是-Go-竞态？" class="headerlink" title="什么是 Go 竞态？"></a>什么是 Go 竞态？</h3><p>所谓的竞态（race condition）就是多个 goroutine 同时访问相同的资源，我们可以对临界区加锁或使用原子操作来解决竞态，原子操作的开销比加锁要小。</p><h3 id="defer-可以捕获-goroutine-的子-goroutine-吗？"><a href="#defer-可以捕获-goroutine-的子-goroutine-吗？" class="headerlink" title="defer 可以捕获 goroutine 的子 goroutine 吗？"></a>defer 可以捕获 goroutine 的子 goroutine 吗？</h3><p>不可以，defer 仅在当前的 goroutine 中生效，不会跨 goroutine 影响其它 goroutine 的执行。</p><h3 id="如果若干个goroutine，有一个panic会怎么做？"><a href="#如果若干个goroutine，有一个panic会怎么做？" class="headerlink" title="如果若干个goroutine，有一个panic会怎么做？"></a>如果若干个goroutine，有一个panic会怎么做？</h3><p>一个 goroutine 发生了 panic 只会终止自己，不会影响其它 goroutine，但如果该发生 panic 的协程没有 recover，整个程序都会退出，所以子 goroutine 中最好使用 recover 来处理 panic。</p><h3 id="gRPC-是什么？"><a href="#gRPC-是什么？" class="headerlink" title="gRPC 是什么？"></a>gRPC 是什么？</h3><p>gRPC 并不是指的 golang rpc，而是 google rpc，是谷歌开源的强大的远程调用库。rpc 也就是远程过程调用，可以调用远程函数就像调用本地函数一样。</p><p>grpc 使用 protobuf 作为接口定义语言，同时底层的消息交换格式也是 protobuf。</p><p>grpc 通信基本流程：</p><ol><li>先定义 IDL，即后缀为 .proto 的接口文档；</li><li>编译 proto 文件，得到存根文件；</li><li>服务端定义接口并启动，这些接口定义在存根文件里；</li><li>客户端借助存根文件调用服务端的函数。</li></ol><p>grpc 是跨平台跨语言的。</p><h3 id="Go-是如何解析-Tag-的？"><a href="#Go-是如何解析-Tag-的？" class="headerlink" title="Go 是如何解析 Tag 的？"></a>Go 是如何解析 Tag 的？</h3><p>要采用反射的方式来解析 Tag，通过 reflect.ValueOf 方法获取反射值，获取 Type 属性，再用 Field(i) 获取需要解析 tag 的 field，通过.Tag() 来获取 tag。</p><h3 id="Go-项目如何优雅的启停？"><a href="#Go-项目如何优雅的启停？" class="headerlink" title="Go 项目如何优雅的启停？"></a>Go 项目如何优雅的启停？</h3><p>所谓优雅的启停要符合以下几个条件：</p><ul><li>不可以关闭现有连接；</li><li>启动新的进程来接管旧进程；</li><li>继续响应用户请求，不能出现拒绝请求的情况；</li><li>旧进程处理完旧请求之后再退出，新的请求由新的进程来处理。</li></ul><p>通过监听信号来实现：</p><p>启动：</p><ul><li>监听 SIGHUP 信号；</li><li>收到信号后将服务监听的文件描述符传递给新的子进程，新老进程同时接受请求。</li></ul><p>退出：</p><ul><li>监听 SIGINT，SIGSTP，SIGQUIT 等信号；</li><li>接收到信号后，父进程停止接收新请求，等待旧请求完成或超时；</li><li>父进程退出。</li></ul><h3 id="channel-死锁的场景"><a href="#channel-死锁的场景" class="headerlink" title="channel 死锁的场景"></a>channel 死锁的场景</h3><ul><li>channel 中没有数据，直接读取会死锁。通过用 select 语句，加上 default 来处理没有数据的情况；</li><li>channel 缓冲区已满，再次写入会死锁。通过 select 语句，加上 default 来处理缓冲区满的情况；</li><li>向一个已经关闭的 channel 中写数据会造成 panic，但如果 channel 里还有未读取的数据是可以正常读取的，第二个返回值为 true，没数据了会返回空值，第二个返回值为 false。</li></ul><h3 id="atomic-底层是怎么实现的？"><a href="#atomic-底层是怎么实现的？" class="headerlink" title="atomic 底层是怎么实现的？"></a>atomic 底层是怎么实现的？</h3><p>atomic 采用 CAS 指令实现，CAS 指令是 CPU 提供的原子性操作指令。CAS 操作不需要加锁，总是假设被操作的值未曾改变，一旦这个假设成立就立即进行替换，即 Compare and Swap。CAS 需要不断占用 CPU 资源来避免加锁的开销。</p><h3 id="Go-的调试-x2F-分析工具用过哪些？"><a href="#Go-的调试-x2F-分析工具用过哪些？" class="headerlink" title="Go 的调试&#x2F;分析工具用过哪些？"></a>Go 的调试&#x2F;分析工具用过哪些？</h3><ul><li>go cover：测试代码覆盖率；</li><li>godoc：用于生成 go 文档；</li><li>pprof：用于性能调优，针对 cpu、内存和并发；</li><li>-race：用于检测竞态；</li></ul><h3 id="进程被-kill，如何保证所有-goroutine-顺利退出？"><a href="#进程被-kill，如何保证所有-goroutine-顺利退出？" class="headerlink" title="进程被 kill，如何保证所有 goroutine 顺利退出？"></a>进程被 kill，如何保证所有 goroutine 顺利退出？</h3><p>goroutine 需要监听 SIGKILL 信号，接收到该信号之后就退出，可以用 select 语句。</p><h3 id="说说-context-包的作用？"><a href="#说说-context-包的作用？" class="headerlink" title="说说 context 包的作用？"></a>说说 context 包的作用？</h3><p>context 用于在 goroutine 之间传递上下文，可以同步特定的数据、取消信号以及处理请求的截止时间等。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LSM-Tree 概述</title>
      <link href="/post/73f6d0aa.html"/>
      <url>/post/73f6d0aa.html</url>
      
        <content type="html"><![CDATA[<h1 id="LSM-Tree-概述"><a href="#LSM-Tree-概述" class="headerlink" title="LSM-Tree 概述"></a>LSM-Tree 概述</h1><h2 id="为什么要有-LSM-Tree"><a href="#为什么要有-LSM-Tree" class="headerlink" title="为什么要有 LSM-Tree"></a>为什么要有 LSM-Tree</h2><p>在传统的树形结构索引中，大量写入操作会带来额外的 IO 开销，要花费两倍的 IO 成本来维护<strong>实时索引</strong>，并且每次写入都会有两次 IO 操作，一次读 page，一次将 page 写回，所以要引入一种新的算法来应对这种场景，这正是 LSM-Tree 诞生的理由。</p><p>LSM-Tree 的核心思想就是<strong>写入延迟</strong>、采用<strong>批量写入</strong>，并且消除了随机的就地更新。LSM-Tree 首先将数据缓存在内存当中，当内存中的数据达到一个阈值时，将它们批量写入磁盘中。</p><p>当然，有得有失，LSM-Tree 在读取的时候会存在短板，所以 LSM-Tree 适用于<strong>写多读少</strong>的场景。</p><h2 id="基础的-LSM-Tree-算法"><a href="#基础的-LSM-Tree-算法" class="headerlink" title="基础的 LSM-Tree 算法"></a>基础的 LSM-Tree 算法</h2><p>在 LSM-Tree 中，数据首先被添加到 MemTable 中，这个 MemTable 是一个<strong>有序的内存数据结构</strong>，但并没有规定具体是哪一种，可以是红黑树也可以是跳表等。这样可以起到使数据先排好序的作用。当 MemTable 被写入的量达到阈值的时候，会被刷入到磁盘的一个新的 SST 文件中。</p><p>SST 这种文件格式有许多好处：</p><ul><li>可以做到高效的数据文件合并，即使文件大于可用内存，<strong>合并段的操作仍然简单高效</strong>。</li><li>不需要在内存中保存所有键的索引，可以使用<strong>稀疏索引</strong>，因为 SST 文件是有序的。</li><li>由于读取请求无论如何都需要扫描所请求范围内的多个键值对，因此可以将这些记录分组为块（block），并在将其写入硬盘之前对其进行<strong>压缩</strong>。</li></ul><p>显然这种仅追加的方式，会产生越来越多的不可变的有序文件，但并不会去更新旧文件中的重复条目（或被删除的记录），所以会产生冗余（空间放大）。系统需要定期的执行<strong>合并操作（Compact）</strong>，来把文件合并，消除其中重复的更新或删除操作。</p><p>合并并不仅仅是为了节省磁盘资源的浪费，更多的是要<strong>通过减少文件数量的增长，来保证读操作的性能。</strong>由于 LSM-Tree 文件有序的特性，合并操作是非常高效的。</p><p>LSM-Tree 的读取操作首先在内存中读取 MemTable，如果没有读到，再去磁盘中读取，从新的文件开始往旧的文件读取。所以 LSM-Tree 的读取性能自然要比采用就地修改的其它结构要低了。当然，可以在内存中建立索引来提高读取的速度。同时可以通过布隆过滤器来进行优化，可以大概率避免读完所有 SST 文件发现某个 Key 并不在数据库中。</p><p>所以从整体来上来 LSM-Tree，其实就是牺牲读取性能来换得写入性能，避免随机写，但带来了随机读。</p><h2 id="Compact"><a href="#Compact" class="headerlink" title="Compact"></a>Compact</h2><h3 id="基础的-Compact-方法"><a href="#基础的-Compact-方法" class="headerlink" title="基础的 Compact 方法"></a>基础的 Compact 方法</h3><p>基本的合并方法非常简单：当创建一定数量的小文件后，将它们合并成一个单独的中等大小的文件，在这些中等大小的文件又到达一定数量后，再将它们合并为更大的文件。</p><p>这种方法带来的结果就是大量的文件会被创建，这样和我们去控制文件数量保证读取性能的思路就背道而驰了。</p><h3 id="LevelDB-中的-Compact-方法"><a href="#LevelDB-中的-Compact-方法" class="headerlink" title="LevelDB 中的 Compact 方法"></a>LevelDB 中的 Compact 方法</h3><p>在 LevelDB 等数据库中，通过实现<strong>分级（Leveled）</strong>而不是大小，来将 SST 文件进行分组。这减少了最差情况下大量文件的读取，同样减少了单个压缩的（对整个数据集的）相对冲击。</p><p>这种方法跟基本方法有两个不同的关键点：</p><ul><li>每一层的键不会重复，所以在某层寻找一个关键字的时候只需要查询一个文件。</li><li>文件一次被合并成高层级的一个文件。当一层满了，一个文件会从这一层抽离，并且合并进入上一级来创建加入更多数据的空间。这比起基本方法中，把相似大小的文件合并成一个单独的较大文件，略有些不同。</li></ul><p>由于低层次的文件会被合并到高层次的文件中去，<strong>相比于基本方法需要的整体空间会更少，读性能也会更高，但会带来更大的 IO 负载</strong>，对于单纯以写为目的的情况，并没有帮助。</p><h2 id="LSM-Tree-更多的一些优势"><a href="#LSM-Tree-更多的一些优势" class="headerlink" title="LSM-Tree 更多的一些优势"></a>LSM-Tree 更多的一些优势</h2><p>LSM-Tree 除去更好的写性能之外还有一些优势：</p><ul><li>SST 文件是仅追加的，所以锁定语义的实现相比于树结构更加简单。</li><li>在同样硬件的情况，硬件的提升对读性能的提升更大，所以在不选择提升硬件的情况下想要提升写性能可以选择 LSM-Tree。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>LSM-Tree 在 B+ 树和哈希索引之间取得了均衡，通过管理一组而不是单独一个索引文件，LSM-Tree 把 B+ 树或哈希索引中开销较大的随机写入 IO 替换为了快速的顺序 IO。</p><p>而读操作则不得不处理大量的随机 IO。并且 LSM-Tree 将带来额外的合并开销。</p>]]></content>
      
      
      <categories>
          
          <category> LSM-Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 存储引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为 nutsdb 添加文件锁的过程记录及 gofrs/flock 详解</title>
      <link href="/post/e2e532c8.html"/>
      <url>/post/e2e532c8.html</url>
      
        <content type="html"><![CDATA[<p>最近在 <a href="https://github.com/nutsdb/nutsdb">nutsdb</a> v0.12.5 的发布计划中，有要实现 file lock 这一条，来保证只让开启 DB 的这个进程访问数据库文件夹，而其它的进程无法对该文件夹进行操作。</p><p>在 <a href="https://github.com/elliotchenzichang">Elliot Chen</a> 的建议下接下了这个任务，一开始觉得可能是要自己实现一个 file lock，但是在考察了其它的项目实现文件锁的方式后，发现了一个库：<a href="https://github.com/gofrs/flock">gofrs&#x2F;flock</a>，虽然 star 并不是很多，只有 400+，并且已经好几年没有更新过了，但是看了一眼有足足将近 1.2w 的使用者后，当即决定直接用这个库实现。</p><h2 id="在-nutsdb-中使用-gofrs-x2F-flock"><a href="#在-nutsdb-中使用-gofrs-x2F-flock" class="headerlink" title="在 nutsdb 中使用 gofrs&#x2F;flock"></a>在 nutsdb 中使用 gofrs&#x2F;flock</h2><p>接下来我会详细介绍一下在 nutsdb 中是如何使用 gofrs&#x2F;flock 的。</p><h3 id="gofrs-x2F-flock-的接口介绍"><a href="#gofrs-x2F-flock-的接口介绍" class="headerlink" title="gofrs&#x2F;flock 的接口介绍"></a>gofrs&#x2F;flock 的接口介绍</h3><p>这个库提供的接口相当简单易懂。 首先，通过<code>flock</code>包下的<code>New</code>函数创建一个<code>*Flock</code>，注意传进去的是需要上锁的文件路径，并且<strong>这个文件一定要是存在的</strong>，否则就会报错。</p><p>然后，可以调用<code>Lock</code>或<code>TryLock</code>方法进行上锁，在<code>TryLock</code>的注释中有些到：</p><blockquote><p>TryLock is the preferred function for taking an exclusive file lock.</p></blockquote><p><code>TryLock</code>方法是一个<strong>非阻塞</strong>方法，如果获取锁失败了会返回 false 而不会一直等待 file lock 被释放，所以我采用了<code>TryLock</code>来获取锁。</p><h3 id="实际代码实现"><a href="#实际代码实现" class="headerlink" title="实际代码实现"></a>实际代码实现</h3><p>在 nutsdb 打开的时候，获取文件锁即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flock := flock.New(filepath.Join(opt.Dir, FLockName))</span><br><span class="line"><span class="keyword">if</span> ok, err := flock.TryLock(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, ErrDirLocked</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.flock = flock</span><br></pre></td></tr></table></figure><p>释放锁也只需要在 nutsdb 关闭的时候调用 <code>Unlock</code>就可以了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !db.flock.Locked() &#123;</span><br><span class="line">    <span class="keyword">return</span> ErrDirUnlocked</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = db.flock.Unlock()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助这个库来实现 file lock 还是很简单的，但是中间遇到了一些小问题。在 v0.12.4 的发布计划中提到了 nutsdb 当前的所有测试用例都是公用一个 DB 实例，所以有一些测试用例在打开 DB 实例后并没有调用关闭方法，所以会导致下一个测试用例执行失败，因为无法再次获取到文件锁了。</p><p>暂时是通过给所有测试用例都调用关闭方法来解决的，后续要通过重构测试用例彻底解决这个问题。</p><h2 id="gofrs-x2F-flock-源码解析"><a href="#gofrs-x2F-flock-源码解析" class="headerlink" title="gofrs&#x2F;flock 源码解析"></a>gofrs&#x2F;flock 源码解析</h2><p>仅仅会调接口当然是不行的 🤣，于是我详细看了一下源码来了解实现原理。这个库的代码非常精简，兼容了多个平台也就 1200+ 行代码，看起来也是不怎么费劲。</p><h3 id="Windows-系统上的实现"><a href="#Windows-系统上的实现" class="headerlink" title="Windows 系统上的实现"></a>Windows 系统上的实现</h3><p>在 Windows 上，<code>gofrs/flock</code> 使用了 <code>kernel32.dll</code> 中的 <code>LockFileEx</code> 和 <code>UnlockFileEx</code> 函数来实现文件锁定：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    kernel32, _         = syscall.LoadLibrary(<span class="string">&quot;kernel32.dll&quot;</span>)</span><br><span class="line">    procLockFileEx, _   = syscall.GetProcAddress(kernel32, <span class="string">&quot;LockFileEx&quot;</span>)</span><br><span class="line">    procUnlockFileEx, _ = syscall.GetProcAddress(kernel32, <span class="string">&quot;UnlockFileEx&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>procLockFileEx</code>和<code>procUnlockFileEx</code>这两个变量是 <code>LockFileEx</code> 和 <code>UnlockFileEx</code> 系统调用函数的地址，这两个地址要通过使用<code>syscall.GetProcAddress</code>从<code>kernel32.dll</code>中获取，因为在 Windows 系统上，<code>LockFileEx</code>和<code>UnlockFileEx</code>并不能直接通过<code>syscall</code>包下定义的函数来调用，而要先获取到地址，再使用<code>syscall.syscall6</code>来调用（这个 6 指的是系统调用的参数个数，不过类似于这样的函数已经全部过时了，应该统一使用 <code>syscall.syscallN</code> 来调用）。</p><p>那么在 Windows 系统上，是如何实现的共享锁和独占锁呢？是通过一些标志来确定的，在<code>procLockFileEx</code>函数的参数中需要填入这个文件锁对应的锁类型标志，这些标志也定义在<code>flock_winapi.go</code>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    winLockfileFailImmediately = <span class="number">0x00000001</span></span><br><span class="line">    winLockfileExclusiveLock   = <span class="number">0x00000002</span></span><br><span class="line">    winLockfileSharedLock      = <span class="number">0x00000000</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>winLockfileExclusiveLock</code> 和 <code>winLockfileSharedLock</code>分别表示要获取共享文件锁还是独占文件锁。只需要在获取锁时根据需要的类型将对应的<code>flag</code>传入系统调用中就可以了。</p><p>解锁也是一样，只需要调用<code>procUnlockFileEx</code>系统调用，只是少传一个<code>flag</code>参数，其余的使用跟<code>procLockFileEx</code>都是一样的。</p><p>gofrs&#x2F;flock 分别为这两个系统调用封装成了<code>lockFileEx</code>和<code>unlockFileEx</code>函数来方便的加锁解锁。</p><h3 id="类-Unix-系统上的实现"><a href="#类-Unix-系统上的实现" class="headerlink" title="类 Unix 系统上的实现"></a>类 Unix 系统上的实现</h3><p>在 Unix 系统上，file lock 的实现就相对更加简单一点了，因为是可以直接通过<code>syscall</code>包下定义的<code>Flock</code>函数，根据给这个函数传入的第二个参数<code>flag</code>，来决定这个系统调用的具体行为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscall.Flock(<span class="type">int</span>(f.fh.Fd()), flag)</span><br></pre></td></tr></table></figure><p>使用到了这些<code>flag</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syscall.LOCK_EX <span class="comment">// 获取独占锁</span></span><br><span class="line">syscall.LOCK_SH <span class="comment">// 获取共享锁</span></span><br><span class="line">syscall.LOCK_UN <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure><p>需要注意的是，在某些类 UNIX 操作系统上，使用<code>Lock</code>方法可能会自动将共享锁替换为独占锁。在使用独占锁（Exclusive Locks）和共享锁（RLock()）时要小心，因为调用 Unlock() 可能会意外释放曾经是共享锁的独占锁。</p><h3 id="TryLock-的实现"><a href="#TryLock-的实现" class="headerlink" title="TryLock 的实现"></a>TryLock 的实现</h3><p>gofrs&#x2F;flock 有一个非常好的功能就是可以实现非阻塞的获取锁，一旦获取锁失败了就直接返回，那么这是怎么实现的呢？</p><p>在 Windows 上，<code>try</code>的实现要稍微简单一些，在调用<code>lockFileEx</code>方法的时候，多添加了一个之前列出来但没提到的标志：<code>winLockfileFailImmediately</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, errNo := lockFileEx(syscall.Handle(f.fh.Fd()), flag|winLockfileFailImmediately, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, &amp;syscall.Overlapped&#123;&#125;)</span><br></pre></td></tr></table></figure><p>有了这个标志就意味着非阻塞的尝试，如果 <code>lockFileEx</code> 返回特定的错误码，如 <code>ErrorLockViolation</code> 或 <code>syscall.ERROR_IO_PENDING</code>，则表示无法立即获得锁定，函数会立即返回，并返回 false 表示尝试失败。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> errNo &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> errNo == ErrorLockViolation || errNo == syscall.ERROR_IO_PENDING &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>, errNo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在类 UNIX 系统上，在调用<code>FLock</code>时，加上一个标志位<code>syscall.LOCK_NB</code>，如果 <code>syscall.Flock</code> 返回 <code>syscall.EWOULDBLOCK</code> 错误，则表示无法立即获得锁定，函数会立即返回，并返回 false 表示尝试失败。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := syscall.Flock(<span class="type">int</span>(f.fh.Fd()), flag|syscall.LOCK_NB)</span><br></pre></td></tr></table></figure><p>不过在类 Unix 系统上还实现了一个<code>reopenFDOnError</code>方法，如果<code>Flock</code>返回的错误是<code>syscall.EIO</code> 或 <code>syscall.EBADF</code>，那么该方法会尝试重新打开文件描述符，并再次进行尝试。这是因为在某些情况下，文件描述符可能会在错误发生后被关闭，所以我们尝试重新打开文件描述符，确保可以继续尝试获取锁定。</p><p>这样 gofrs&#x2F;flock 就实现了非阻塞的文件锁定。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>gofrs/flock</code> 是一个功能强大且易于使用的 Go 语言库，用于实现文件锁定。它通过封装底层的系统调用，在不同的操作系统上提供了一致的接口，使得开发者可以轻松地确保多个进程对同一个文件的并发访问是安全的。无论是在 Linux&#x2F;Unix 还是 Windows 等操作系统上，<code>gofrs/flock</code> 都为文件锁定提供了可靠的解决方案。</p><p>虽然不是自己从头开发的🤣，但也是为 nutsdb 完成了一个小目标，希望 nutsdb 可以越来越完善。</p>]]></content>
      
      
      <categories>
          
          <category> nutsdb 开发记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> nutsdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab11: networking</title>
      <link href="/post/15f71c04.html"/>
      <url>/post/15f71c04.html</url>
      
        <content type="html"><![CDATA[<p>本次 lab 要给 xv6 实现网卡（Qemu 模拟 E1000 网卡）驱动。任务说明书里给了一大段说明以及 E1000 的操作手册。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="xv6-发送和接收网络包的流程"><a href="#xv6-发送和接收网络包的流程" class="headerlink" title="xv6 发送和接收网络包的流程"></a>xv6 发送和接收网络包的流程</h3><p>发送数据包：</p><ol><li>用户程序调用 connect 系统调用创建 socket 并获取 socket 的文件描述符；</li><li>调用 write 系统调用往 socket 的文件描述符中写入数据；</li><li>进入内核，调用 filewrite 函数，由于要写入的文件类型是 FD_SOCK，所以调用 sockwrite 函数，创建一个 mbuf 并将数据从用户空间拷贝过来；</li><li>调用 net_tx_udp 函数进行 udp 头部封装；</li><li>进一步调用 net_tx_ip 函数进行 ip 头部封装；</li><li>调用 net_tx_eth 函数，并将 m 通过e1000_transmit 函数传递给网卡驱动；</li><li>由 e1000_transmit 函数将 mbuf 放到发送队列的尾部，等待网卡设备发送。</li></ol><p>接受数据包：</p><ol><li>网卡接收到新的数据包，产生中断，内核调用中断处理函数 e1000_intr；</li><li>调用 e1000_recv 函数，开始读取缓冲队列中的消息；</li><li>读到一条消息后，通过net_rx 函数向上层传递；</li><li>根据消息的类型，判断是调用 net_rx_ip 函数还是 net_rx_arp 函数；</li><li>如果是 ip 消息，还需要进一步调用net_rx_udp 函数进行拆解；</li><li>调用 sockrecvudp 函数，在其中找到对应的 socket，再通过 mbufq_pushtail 函数将消息放到队列中，待 sockread 函数读取；</li></ol><p>以上就是 xv6 收发网络包的大体流程，具体可以自己阅读源码。</p><h3 id="描述符和缓冲队列"><a href="#描述符和缓冲队列" class="headerlink" title="描述符和缓冲队列"></a>描述符和缓冲队列</h3><p>驱动中有两种缓冲队列，发送和接收的队列，分别有两种描述符对应这两种队列。描述中中记录了对应缓存的存储地址、数据长度，还有一些标志位来让网卡和网卡驱动进行一些判断：</p><ul><li>E1000_TXD_STAT_DD 标志位就是让网卡驱动在发送数据时判断当前拿到的描述符对应的缓存是否已经发送了；</li><li>E1000_RXD_STAT_DD 标志位就是在接受数据的时候判断是否是没有接收过的数据；</li><li>E1000_TXD_CMD_RS 表示 Report Status，当这个字段被设置时，表示在数据包发送完成后，e1000 网卡会自动填充传输描述符中的报告状态区域，可以用来检查数据包是否发送成功。</li><li>E1000_TXD_CMD_EOP 表示 End Of Packet，当这个字段被设置时，表示数据包已经到达了传输描述符中的缓冲区的末尾。当该字段被设置时，意味着这是一个完整的数据包，可以开始传输了。</li></ul><p>上面的这几个 status 或 cmd 位是我们需要用到的。</p><h3 id="环形缓冲队列的头尾"><a href="#环形缓冲队列的头尾" class="headerlink" title="环形缓冲队列的头尾"></a>环形缓冲队列的头尾</h3><p>regs 数组中存储着 e1000 的寄存器的值，完成 lab 来说，需要使用到 regs[E1000_TDT]，即下一个需要传输的环形缓冲队列的索引，还有 regs[E1000_RDT]，即当前已经读到并且读过的环形缓冲队列索引。根据 Hints 来增加索引即可。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>首先实现 e1000_transmit。根据刚刚的调用流程分析，可能会有多个进程同时调用该函数，所以为了防止发生竞态，需要对函数上锁。接下来的步骤就是按照 Hints 来就行：</p><ol><li>上锁；</li><li>获取 regs[E1000_TDT] 位置的描述符；</li><li>判断描述符 status 的 E1000_TXD_STAT_DD 是否被设置，没被设置说明之前数据还没发送，这个描述符对应的位置不能放入一个新的数据，返回 -1；</li><li>否则如果这个描述符对应的位置有数据则释放（调用 mbuffree）；</li><li>重新设置描述符的 addr、length、cmd；</li><li>更新 regs[E1000_TDT] 为 （regs[E1000_TDT]+1）% TX_RING_SIZE；</li><li>将参数 m 放入缓冲区中；</li><li>释放锁，返回 0；</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">e1000_transmit</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// the mbuf contains an ethernet frame; program it into</span></span><br><span class="line">  <span class="comment">// the TX descriptor ring so that the e1000 sends it. Stash</span></span><br><span class="line">  <span class="comment">// a pointer so that it can be freed after sending.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;e1000_lock);</span><br><span class="line"></span><br><span class="line">  uint32 txrid = regs[E1000_TDT];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span> *<span class="title">txdesc</span> =</span> &amp;tx_ring[txrid];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((txdesc-&gt;status &amp; E1000_TXD_STAT_DD) == <span class="number">0</span>) &#123;</span><br><span class="line">    release(&amp;e1000_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(txdesc-&gt;addr != <span class="number">0</span>) &#123;</span><br><span class="line">    mbuffree((<span class="keyword">struct</span> mbuf *) tx_mbufs[txrid]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  txdesc-&gt;addr = (uint64) m-&gt;head;</span><br><span class="line">  txdesc-&gt;length = m-&gt;len;</span><br><span class="line">  txdesc-&gt;cmd |= E1000_TXD_CMD_RS;</span><br><span class="line">  txdesc-&gt;cmd |= E1000_TXD_CMD_EOP;</span><br><span class="line"></span><br><span class="line">  regs[E1000_TDT] = (txrid + <span class="number">1</span>) % TX_RING_SIZE;</span><br><span class="line"></span><br><span class="line">  tx_mbufs[txrid] = m;</span><br><span class="line"></span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是 e1000_recv，注意它是不可以上锁的。第一是只有在处理中断的时候会调用该函数，不会发生竞态，第二是如果接收到的数据包是 ARP 数据包，那么在解包的时候就会调用 net_tx_arp 函数回复自己的 mac，会调用 e1000_transmit 再次获取锁，发生 panic。</p><p>根据 Hints：</p><ol><li>获取下一个要读的描述符；</li><li>判断描述符的 E1000_RXD_STAT_DD 位是否被设置，没被设置就返回。注意这里要用一个循环来读取，直到不满足条件：</li></ol><p>Your e1000_recv() code must scan the RX ring and deliver each new packet’s mbuf to the network stack (in net.c) by calling net_rx().</p><ol start="3"><li>将描述符指向的数据通过 net_rx 传递给上层；</li><li>创建一个新的 mbuf 放入该位置中；</li><li>更新 regs[E1000_RDT] 为当前位置；</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">e1000_recv</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Check for packets that have arrived from the e1000</span></span><br><span class="line">  <span class="comment">// Create and deliver an mbuf for each packet (using net_rx()).</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  uint32 rxrid = (regs[E1000_RDT] + <span class="number">1</span>) % RX_RING_SIZE;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rx_desc</span> *<span class="title">rxdesc</span> =</span> &amp;rx_ring[rxrid];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (rxdesc-&gt;status &amp; E1000_RXD_STAT_DD) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m</span> =</span> rx_mbufs[rxrid];</span><br><span class="line"></span><br><span class="line">    m-&gt;len = rxdesc-&gt;length;</span><br><span class="line">    net_rx(m);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">nm</span> =</span> mbufalloc(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    rxdesc-&gt;addr = (uint64) nm-&gt;head;</span><br><span class="line">    rxdesc-&gt;status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rx_mbufs[rxrid] = nm;</span><br><span class="line"></span><br><span class="line">    regs[E1000_RDT] = rxrid;</span><br><span class="line"></span><br><span class="line">    rxrid = (regs[E1000_RDT] + <span class="number">1</span>) % RX_RING_SIZE;</span><br><span class="line"></span><br><span class="line">    rxdesc = &amp;rx_ring[rxrid];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b539074750aa422aa18595066f9f3c56~tplv-k3u1fbpfcp-zoom-1.image"></p><p>这次不用跑 usertests，很快就跑完了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次实验给的材料太多了，还挺难看完的。建议选着看就行了，因为我感觉实际上只看 Hints 也能做个八九不离十。这次 lab 相对简单，有很多可以做的事情都在 Optional Challenges 中，感觉有时间可以做一做。</p><h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2><p>MIT 6.S081 Fall 2020 的 lab 算是全部做完了，如释重负，不过 Optional Challenges 是一个没做。后续计划再整体好好过一遍代码整理对应的知识。其实我感觉收益还是蛮大的，只要动手了，即使实现的版本是性能不高并且简单的，对相应知识的理解也能更加深刻，更别说后续再做 Optional Challenges。</p><p>并且我感觉这门课的 lab 比起 6.824 来说更加与课程内容强相关，上课没懂的地方看看代码或许就懂了，上手也会更加简单。</p><p>还剩了几堂 Lecture 没看完，希望五月份之前能搞定吧。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab10: mmap</title>
      <link href="/post/a1137fe6.html"/>
      <url>/post/a1137fe6.html</url>
      
        <content type="html"><![CDATA[<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>这次 lab 是要给 xv6 添加 mmap 和 munmap 系统调用。</p><p>mmap 的好处在于可以将一个文件直接映射到进程的地址空间中，从而避免了不必要的数据复制，提高了文件操作的效率。与使用 read 和 write 系统调用不同，mmap 操作不需要将文件数据从内核缓冲区复制到用户缓冲区，也不需要将用户缓冲区中的数据复制回内核缓冲区。相反，它通过映射文件的方式，将文件数据直接映射到了进程的地址空间中，因而可以提高文件操作的效率。</p><p>同时 mmap 也避免了由于使用 read 和 write 系统调用而造成的在用户空间和内核空间的上下文切换，节省了系统调用的开销。</p><h3 id="系统调用声明"><a href="#系统调用声明" class="headerlink" title="系统调用声明"></a>系统调用声明</h3><p>mmap 系统调用的函数声明为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, uint64 len, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, uint64 offset)</span>;</span><br></pre></td></tr></table></figure><ul><li>addr 为文件在用户地址空间的起始地址，一般传入 0，由内核设置；</li><li>len 为要映射的字节数量；</li><li>prot 为权限字段，指明该文件是可读（PROT_READ）、可写（PROT_WRITE）或可执行（PROT_EXEC）的；</li><li>flags 为标记位，标记映射的模式，MAP_SHARED 模式标识在 munmap 的时候需要把改动写回磁盘，MAP_PRIVATE 模式则不需要；</li><li>fd 是文件的描述符；</li><li>offset 为文件起始位置到开始映射的位置的偏移量。</li></ul><p>munmap 系统调用的函数声明为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, uint64 len)</span>;</span><br></pre></td></tr></table></figure><ul><li>addr 为从哪里开始解除映射；</li><li>len 为解除映射的字节数。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>添加 mmap 和 munmap 系统调用的过程这里就省略了。直接来看实现。</p><p>首先，为了能够让用户进程知道关于文件映射的信息，需要在 proc 结构体记录下。新增 vma 结构体，来存储文件映射的相关信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma</span> &#123;</span></span><br><span class="line">  <span class="type">int</span>    valid; <span class="comment">// 该 vma 是否有效</span></span><br><span class="line">  uint64 addr;  <span class="comment">// 文件在进程地址空间中的起始地址</span></span><br><span class="line">  uint64 len;   <span class="comment">// 文件映射了多少字节</span></span><br><span class="line">  <span class="type">int</span>    prot;  <span class="comment">// 文件权限</span></span><br><span class="line">  <span class="type">int</span>    flags; <span class="comment">// 映射模式标识</span></span><br><span class="line">  <span class="type">int</span>    fd;    <span class="comment">// 文件标识符</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span> <span class="comment">// 指向对应的文件结构体</span></span><br><span class="line">  uint64 offset; <span class="comment">// 文件映射的偏移</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>并且在 proc 结构体中添加一个 vma 数组，根据 hint，大小为 16 即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma</span> <span class="title">vmatable</span>[<span class="title">NVMA</span>];</span> <span class="comment">// NVMA 为定义在 kernel/param.h 中的宏</span></span><br></pre></td></tr></table></figure><p>接着在 kernel&#x2F;sysfile.c 中实现 sys_mmap 函数。大致流程如下：</p><ol><li>接收 mmap 系统调用传递的参数；</li><li>判断参数是否可以满足映射条件：</li></ol><!----><ol><li><ol><li>只读文件在 MAP_PRIVATE 模式下，是可写的；</li><li>只读文件在 MAP_SHARED 模式下，是不可写的。</li></ol></li></ol><!----><ol start="3"><li>从进程中记录的 vma 中找出一个空闲的 vma，并在进程的 heap 中找出一段可用的内存，将这段内存的起始地址作为系统调用的返回值。注意在这里是不进行内存分配的，只是标记，跟 lazy alloction 是一样的，这样可以让映射比内存空间更大的文件成为可能。为了和进程正在使用的地址空间区分开，选择从 heap 的高位置开始向下扩展来映射文件，即从 TRAPFRAME 开始。</li><li>设置 vma 的值；</li><li>filedup 对应文件；</li></ol><p>mmap should increase the file’s reference count so that the structure doesn’t disappear when the file is closed.</p><p>close 系统调用关闭是的一个打开的文件描述符，只是减少该文件的打开引用数，在这里增加一次引用后，就算调用了 close 也不会影响到对已经映射的内存。</p><ol start="6"><li>返回映射的起始地址；</li></ol><p>实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_mmap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  uint64 len, offset;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> prot, flags, fd;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">1</span>, &amp;len) &lt; <span class="number">0</span> || argint(<span class="number">2</span>, &amp;prot) &lt; <span class="number">0</span> || argint(<span class="number">3</span>, &amp;flags) &lt; <span class="number">0</span> || argint(<span class="number">4</span>, &amp;fd) &lt; <span class="number">0</span> || argaddr(<span class="number">5</span>, &amp;offset) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> =</span> p-&gt;ofile[fd];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ((file-&gt;readable &amp;&amp; !file-&gt;writable) &amp;&amp; (prot &amp; PROT_WRITE) &amp;&amp; (flags &amp; MAP_SHARED)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">vma</span> =</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">  uint64 addr = TRAPFRAME;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!p-&gt;vmatable[i].valid &amp;&amp; !found) &#123;</span><br><span class="line">      found = <span class="number">1</span>;</span><br><span class="line">      vma = &amp;p-&gt;vmatable[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;vmatable[i].valid &amp;&amp; p-&gt;vmatable[i].addr &lt; addr) &#123;</span><br><span class="line">      addr = p-&gt;vmatable[i].addr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  addr = addr - len;</span><br><span class="line"></span><br><span class="line">  vma-&gt;valid = <span class="number">1</span>;</span><br><span class="line">  vma-&gt;fd = fd;</span><br><span class="line">  vma-&gt;file = file;</span><br><span class="line">  vma-&gt;len = len;</span><br><span class="line">  vma-&gt;offset = offset;</span><br><span class="line">  vma-&gt;prot = prot;</span><br><span class="line">  vma-&gt;flags = flags;</span><br><span class="line">  vma-&gt;addr = addr;</span><br><span class="line"></span><br><span class="line">  filedup(vma-&gt;file);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成这一步后，在用户程序中调用 mmap 就会返回一个正确的映射后的起始地址了，但是当进行访问的时候，由于并没有分配内存，就会触发 page fault，所以跟 lazy alloction 一样，在 kernel&#x2F;trap.c#usertrap 中处理 page fault。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) &#123;</span><br><span class="line">  uint64 va = r_stval();</span><br><span class="line">  <span class="keyword">if</span> (mmaphandler(va) == <span class="number">-1</span>) &#123;</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>kernel&#x2F;vm.c#mmaphandler 函数接收一个虚拟内存地址（发生 page fault 的地址），来处理 pagefault。</p><p>在 mmaphandler 中，我们需要做以下事情：</p><ol><li>找出 va 是映射在哪个页中，也就是需要找出对应的 vma；</li><li>给 vma 正式分配内存；</li><li>根据 vma 中记录的 prot 来设置 PTE 的 flags；</li><li>将物理地址和虚拟地址进行映射；</li><li>使用 readi 将文件读到刚分配的内存中。在进行操作的时候要开启事务，并且对 inode 上锁。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mmaphandler</span><span class="params">(uint64 va)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">vma</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NVMA; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">v</span> =</span> &amp;p-&gt;vmatable[i];</span><br><span class="line">    <span class="keyword">if</span> (v-&gt;valid) &#123;</span><br><span class="line">      <span class="keyword">if</span> (va &gt;= v-&gt;addr &amp;&amp; va &lt; (v-&gt;addr + v-&gt;len * PGSIZE)) &#123;</span><br><span class="line">        vma = v;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vma == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  uint64 ka = (uint64)kalloc();</span><br><span class="line">  <span class="keyword">if</span> (ka == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>((<span class="type">void</span> *) ka, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  va = PGROUNDDOWN(va);</span><br><span class="line">  <span class="type">pte_t</span> * pte;</span><br><span class="line">  <span class="comment">// avoid remap panic.</span></span><br><span class="line">  <span class="keyword">if</span> ((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) != <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_V) != <span class="number">0</span>) &#123;</span><br><span class="line">    kfree((<span class="type">void</span> *) ka);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> flags = PTE_FLAGS(*pte);</span><br><span class="line">  <span class="keyword">if</span> (vma-&gt;prot &amp; PROT_READ) &#123;</span><br><span class="line">    flags |= PTE_R;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vma-&gt;prot &amp; PROT_WRITE) &#123;</span><br><span class="line">    flags |= PTE_W;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vma-&gt;prot &amp; PROT_EXEC) &#123;</span><br><span class="line">    flags |= PTE_X;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(mappages(p-&gt;pagetable, va, PGSIZE, ka, flags | PTE_U) != <span class="number">0</span>) &#123;</span><br><span class="line">    kfree((<span class="type">void</span> *) ka);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ip = vma-&gt;file-&gt;ip;</span><br><span class="line">  begin_op();</span><br><span class="line">  ilock(ip);</span><br><span class="line">  <span class="keyword">if</span> (readi(ip, <span class="number">0</span>, ka, PGROUNDDOWN(vma-&gt;offset + (va - vma-&gt;addr)), PGSIZE) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlock(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就可以访问我们映射到内存中的文件了。</p><p>接下来要实现 munmap 系统调用（kernel&#x2F;sysfile.c#sys_munmap），注意根据文档，munmap 可以是一部分，但是不会是在中间。</p><p>An munmap call might cover only a portion of an mmap-ed region, but you can assume that it will either unmap at the start, or at the end, or the whole region (but not punch a hole in the middle of a region).</p><p>在 sys_munmap 函数中我们要处理以下事情：</p><ol><li>接收 addr 和 len 参数；</li><li>找出 addr 对应的 vma；</li><li>判断 vma 是否是 MAP_SHARED 模式，如果是就调用 filewrite 将文件写回磁盘；</li><li>取消 munmap 部分的映射；</li><li>调整 vma 的长度和起始地址。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_munmap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  </span><br><span class="line">  uint64 addr, len;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span> || argaddr(<span class="number">1</span>, &amp;len) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">vma</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NVMA; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">v</span> =</span> &amp;p-&gt;vmatable[i];</span><br><span class="line">    <span class="keyword">if</span> (v-&gt;valid &amp;&amp; (v-&gt;addr &lt;= addr &amp;&amp; addr &lt; (v-&gt;addr + len))) &#123;</span><br><span class="line">      vma = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!vma) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (vma-&gt;flags &amp; MAP_SHARED &amp;&amp; vma-&gt;file-&gt;writable) &#123;</span><br><span class="line">    filewrite(vma-&gt;file, addr, len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  uvmunmap(p-&gt;pagetable, addr, len / PGSIZE, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  vma-&gt;len -= len;</span><br><span class="line">  <span class="keyword">if</span>(vma-&gt;len == <span class="number">0</span>) vma-&gt;valid = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;addr == addr) vma-&gt;addr += len;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意修改 uvmunmap，否则会报 panic。</p><p>当进程退出的时候，即调用 kernel&#x2F;proc.c#exit，我们需要将它映射的所有文件都 munmap 掉，就像调用 munmap 系统调用。由于我的实现是父子进程并不共享物理内存，所以直接释放掉即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... kernel/proc.c#exit</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NVMA; i++) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">v</span> =</span> &amp;p-&gt;vmatable[i];</span><br><span class="line">  <span class="keyword">if</span> (v-&gt;valid) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v-&gt;flags &amp; MAP_SHARED &amp;&amp; v-&gt;file-&gt;writable) &#123;</span><br><span class="line">      filewrite(v-&gt;file, v-&gt;addr, v-&gt;len);</span><br><span class="line">    &#125;</span><br><span class="line">    uvmunmap(p-&gt;pagetable, v-&gt;addr, v-&gt;len/PGSIZE, <span class="number">1</span>);</span><br><span class="line">    v-&gt;valid = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后修改 kernel&#x2F;proc.c#fork，在子进程复制父进程的内存时，可能会复制到没有映射或无效的条目，也要修改 uvmcopy 将 panic 去掉。在 fork 函数中只需要将 vma 复制一份给子进程就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...kernel/proc.c#fork</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NVMA; i++) &#123;</span><br><span class="line">  np-&gt;vmatable[i] = p-&gt;vmatable[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里 mmaptest 和 fork test 就都可以通过了。</p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16f785924bf3438694413adae57db01b~tplv-k3u1fbpfcp-zoom-1.image"></p><p>这次的 grader 倒是顺利跑过了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个 lab 是对 file system 的进一步深入，不过我感觉跟虚拟内存可能更加相关？难点主要是在 mmap 系统调用，要考虑如何给 vma 找到一块合适的内存空间，想清楚这里之后其它的就比较简单了。page fault 的处理跟 lazy alloction 是一样的。munmap 系统调用就相当于做了一次反操作。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab9: file system</title>
      <link href="/post/801fac79.html"/>
      <url>/post/801fac79.html</url>
      
        <content type="html"><![CDATA[<p>本次 lab 感觉就是对 xv6 文件系统代码进行熟悉，我们要扩充 xv6 支持的最大文件大小并且给 xv6 实现软链接。</p><h2 id="Large-files-moderate"><a href="#Large-files-moderate" class="headerlink" title="Large files (moderate)"></a>Large files (moderate)</h2><p>xv6 原本支持的最大文件大小只有 12 + 256 个 block，也就是 inode 结构体中 addr 数组的前 12 个元素指出的 12 个 block加上最后一个元素指出的一个 block 中指出了 256 个 block。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cea2a50d75964b9dbb762ddd2cb821e5~tplv-k3u1fbpfcp-zoom-1.image"></p><p>如上图所示，最后一位 singly-indirect block num 指出了一个 block，里面又存储了 256 个 direct block num。一个 block 是 1024B，一个 block num 为 4B，所以正好存储 256 个 direct block num。</p><p>我们要做的就是将文件容量扩充为 11 + 256 + 256*256。改为将 addr 数组前 11 位作为 direct block num，第 12 位作为 singly-indirect block num，将第 13 位作为 doubly-indirect block num。doubly-indirect block num 指向一个 block，这个 block 里面的每个条目都是一个 singly-indirect block num，也就是说还需要再定位一次，才能取到真正的 block num。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>修改 kernel&#x2F;fs.h 中的这几个宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLY_NINDIRECT (BSIZE / sizeof(uint))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DOUBLY_NINDIRECT SINGLY_NINDIRECT * SINGLY_NINDIRECT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE (NDIRECT + SINGLY_NINDIRECT + DOUBLY_NINDIRECT)</span></span><br></pre></td></tr></table></figure><p>并且记得将 struct inode 和 struct dinode 结构体中的 addrs 数组修改一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint addrs[NDIRECT+<span class="number">1</span>+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br></pre></td></tr></table></figure><p>核心就是修改 bmap，仿照原来的代码，对 doubly-indirect block num 进行搜索即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; SINGLY_NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  bn -= SINGLY_NINDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    现在的 bn / 256 的值用于在第一级索引中定位一个 block num，取出这个 block 作为二级索引。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    bn % 256 的值用于在第二级索引中定位一个 block num，这个 block num 就是 data block num。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    所有的 block 都是按需申请，没有的话就创建一个。</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; DOUBLY_NINDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT+<span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    uint idx = bn / (BSIZE / <span class="keyword">sizeof</span>(uint));</span><br><span class="line">    <span class="keyword">if</span>((addr = a[idx]) == <span class="number">0</span>) &#123;</span><br><span class="line">      a[idx] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    idx = bn % (BSIZE / <span class="keyword">sizeof</span>(uint));</span><br><span class="line">    <span class="keyword">if</span>((addr = a[idx]) == <span class="number">0</span>) &#123;</span><br><span class="line">      a[idx] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后修改 itrunc 来释放一个文件的所有 block，跟 bmap 是差不多的，doubly-indirect blocks 多遍历一层就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  uint *a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">      ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; SINGLY_NINDIRECT; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j])</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT+<span class="number">1</span>])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; SINGLY_NINDIRECT; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j]) &#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span> =</span> bread(ip-&gt;dev, a[j]);</span><br><span class="line">        uint *data = (uint*)b-&gt;data;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; SINGLY_NINDIRECT; k++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(data[k])</span><br><span class="line">            bfree(ip-&gt;dev, data[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(b);</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Symbolic-links-moderate"><a href="#Symbolic-links-moderate" class="headerlink" title="Symbolic links (moderate)"></a>Symbolic links (moderate)</h2><p>给 xv6 实现软连接（符号连接）。符号连接通过路径名连接到目标文件，也就是说在使用 open 系统调用的时候，如果打开的是一个符号连接，那么 file system 就会找到这个软连接指向的目标文件，再去打开目标文件（除非指定了 O_NOFOLLOW 标识，那么 fs 就会直接打开软连接，而不会去追踪到目标文件）。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>前面添加新的系统调用和这里就跳过了。</p><p>在 kernel&#x2F;stat.h 中添加 T_SYMLINK 来标识一个 inode 类型是软连接，在 kernle&#x2F;fcntl.h 中添加一个新的标识符 O_NOFOLLOW，以让 open 系统调用判断是要打开一个软连接还是追踪软连接的目标文件。</p><p>首先实现 kernel&#x2F;sysfile.c#sys_symlink</p><p>这是一个系统调用函数，对应的用户空间的声明是 int symlink(char*, char*)；所以我们需要先将两个参数拿到。</p><p>接着开启一个事务，在事务中完成 inode 的创建和写入。调用 create 函数创建 inode，要注意 create 返回的时候已经持有了 inode 的锁，不需要再次获取锁了，并且在事务结束时要调用 iunlockput 函数来释放锁并且取消一次引用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_symlink</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">char</span> path[MAXPATH], target[MAXPATH];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, target, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, path, MAXPATH) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="keyword">if</span>((ip = create(path, T_SYMLINK, <span class="number">0</span>, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n = <span class="built_in">strlen</span>(target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(writei(ip, <span class="number">0</span>, (uint64)target, <span class="number">0</span>, n) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  iunlockput(ip); <span class="comment">// 释放在 create 中获取的锁</span></span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 kernel&#x2F;sysfile.c#sys_open 系统调用，新增判断当前 path 指向的 inode 是否是软连接，并且检查O_NOFOLLOW 标志位。Hints 中写到两点注意事项：</p><ol><li>如果一个软连接又指向一个软连接，那么要递归找出最终的目标文件；</li><li>软连接可能会成环，这个时候就返回错误，hints 中的解决策略是限制递归次数为 10 次。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(omode &amp; O_CREATE)&#123;</span><br><span class="line">  ip = create(path, T_FILE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(ip == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 新增的代码在此处</span></span><br><span class="line">  <span class="type">int</span> symlinkdepth = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    symlinkdepth++;</span><br><span class="line">    <span class="keyword">if</span> (symlinkdepth &gt; <span class="number">10</span>) &#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span> (ip-&gt;type == T_SYMLINK &amp;&amp; !(omode &amp; O_NOFOLLOW)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)path, <span class="number">0</span>, MAXPATH) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        iunlockput(ip);</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>不知道是代码写的太臭还是我这个台式捡垃圾捡的 CPU 太慢的原因，直接跑 make grade 是直接超时了，一会用笔记本跑一下。直接在 qemu 中跑 bigfile、symlinktest、usertests 都是没问题的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次 lab 比上一个简单得多，在 symlink 部分需要好好读一下接口。我一开始没看清 create 中就已经获取了 inode 锁，并且没有释放，将 unlock(dp) 看成了 unlock(ip)，也卡了不少时间。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab8: locks</title>
      <link href="/post/e613f387.html"/>
      <url>/post/e613f387.html</url>
      
        <content type="html"><![CDATA[<p>本次 lab 是要重新设计 xv6 的内存分配器和块缓存来获取更高的并行性。要增加并行性通常要设计到更改数据结构和上锁策略来减少竞态。</p><h2 id="Memory-allocator-moderate"><a href="#Memory-allocator-moderate" class="headerlink" title="Memory allocator (moderate)"></a>Memory allocator (moderate)</h2><p>原本的 allocator 中只有一个单独的 freelist，也就是说 page 的分配和释放都会频繁的产生竞争。所以给每个 CPU 设置一个单独的 freelist 和一个单独的锁。所以进程在不同的 CPU 上申请和分配 page 就可以并行运行了。如果当前 CPU 上 freelist 的为空的时候，就要去别的 CPU 那里偷取 page，这个时候依旧会产生竞争。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>首先修改 CPU 结构体，在每个 CPU 中加入一个之前的 kmem，让每个 CPU 可以单独的分配内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-CPU state.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kmem</span> <span class="title">kmem</span>;</span></span><br><span class="line">  <span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line">  <span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过 NCPU 参数可以知道，有 8 个 CPU，所以在初始化 alloctor 的时候将 freepage 分成 8 份，分别放入 8 个 CPU 的 kmem 中。其实也可以初始化的时候都放到一个 CPU 里，然后其它 CPU 去偷。但是我感觉这样会有一个冷启动的过程，不如在初始化的时候直接先分配了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 offset = (PHYSTOP - (uint64)end)/<span class="number">8</span>;</span><br><span class="line">  uint64 left, right;</span><br><span class="line">  left = (uint64) end;</span><br><span class="line">  right = left + offset;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> &amp;cpus[i];</span><br><span class="line">    initlock(&amp;c-&gt;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    p = (<span class="type">char</span>*)PGROUNDUP(left);</span><br><span class="line">    <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)right; p += PGSIZE) &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(((uint64)p % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)p &lt; end || (uint64)p &gt;= PHYSTOP)</span><br><span class="line">        panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">      <span class="built_in">memset</span>(p, <span class="number">1</span>, PGSIZE);</span><br><span class="line">      r = (<span class="keyword">struct</span> run*)p;</span><br><span class="line">      r-&gt;next = c-&gt;kmem.freelist;</span><br><span class="line">      c-&gt;kmem.freelist = r;</span><br><span class="line">    &#125;</span><br><span class="line">    left = right;</span><br><span class="line">    right = right + offset;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 kfree，在释放的时候申请当前 CPU 的 kmem 锁，将 page 释放到当前 CPU 的 freelist 中即可，注意开关中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  push_off();</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;c-&gt;kmem.lock);</span><br><span class="line">  r-&gt;next = c-&gt;kmem.freelist;</span><br><span class="line">  c-&gt;kmem.freelist = r;</span><br><span class="line">  release(&amp;c-&gt;kmem.lock);</span><br><span class="line"></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是 kalloc，在分配的时候由于当前 CPU 的 freelist 可能已经为空了，那么就需要去其它 CPU 那里偷。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  push_off();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  <span class="type">int</span> cid = cpuid();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> &amp;cpus[cid];</span><br><span class="line"></span><br><span class="line">  acquire(&amp;c-&gt;kmem.lock);</span><br><span class="line">  r = c-&gt;kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">    c-&gt;kmem.freelist = r-&gt;next;</span><br><span class="line">    release(&amp;c-&gt;kmem.lock);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    release(&amp;c-&gt;kmem.lock);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == cid) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">nc</span> =</span> &amp;cpus[i];</span><br><span class="line">      acquire(&amp;nc-&gt;kmem.lock);</span><br><span class="line">      r = nc-&gt;kmem.freelist;</span><br><span class="line">      <span class="keyword">if</span> (r) &#123;</span><br><span class="line">        acquire(&amp;c-&gt;kmem.lock);</span><br><span class="line">        nc-&gt;kmem.freelist = r-&gt;next;</span><br><span class="line">        release(&amp;c-&gt;kmem.lock);</span><br><span class="line">        release(&amp;nc-&gt;kmem.lock);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        release(&amp;nc-&gt;kmem.lock);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  pop_off();</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去其它 CPU 那里偷的时候，由于要获取其它 CPU 的锁，所以会产生竞争。还有一种情况就是当前进程持有当前 CPU 的锁去偷其它 CPU 的时候，那个被偷的 CPU 可能也正在尝试偷当前 CPU，这样就会产生死锁。</p><p>可以选择在去别的 CPU 那里偷之前把当前 CPU 的锁释放掉，这样就不会产生死锁，破坏了死锁的必要条件。我在大佬的博客上看到说如果这个时候释放了锁，就会导致重复偷取 page。我想了一下，如果说在释放当前 CPU 的 kmem 锁之后，该进程被调度走了，另外一个进程又过来执行 kalloc，也发现当前 CPU 的 freelist 是空的，也会进行偷取。但是我感觉当前已经是关中断了，那么时钟中断也会被屏蔽，当前进程就不会被调度了，所以应该不会产生这种情况吧。这一块没有太懂，不过能通过测试，暂时先这样。</p><h2 id="Buffer-cache-hard"><a href="#Buffer-cache-hard" class="headerlink" title="Buffer cache (hard)"></a>Buffer cache (hard)</h2><p>这部分要做的事情跟第一部分的目的是一样的，修改 bcache 结构体，并降低锁的粒度。将原本的用一个大锁锁住整个双向链表的设计，拆分成一个 Hash Table，每个 bucket 一个锁，那么就可以使得访问不同 bucket 的进程并行访问 buffer cache。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>根据 hints，最基本的思路是很容易想到的。将 buffer 以哈希表的形式组织，bucket 的数量为 13 个，每个 bucket 需要一把锁。并且把原本的双向链表设计去掉，原本的双向链表是为了实现 LRU，但现在我们通过给每个 buffer 记录时间戳来实现 LRU，时间戳就为 kernel&#x2F;trap.c 中的 ticks。</p><p>所以 bcache 结构改为以下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buckets</span>[<span class="title">NBUCKET</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">bucketlocks</span>[<span class="title">NBUCKET</span>];</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure><p>在 buf 结构体中去掉 prev 指针，并加入 timestamp 字段，用于实现 LRU：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> valid;   <span class="comment">// has data been read from disk?</span></span><br><span class="line">  <span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf?</span></span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">  uint refcnt;</span><br><span class="line">  uint timestamp;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样一来就不需要维护双向链表了，binit 的实现也很简单，只需要初始化锁并且将 bcache.buf 中的所有 buffer 都放进 bcache.buckets[0]，并初始化每个 buf 的 sleeplock 即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NBUCKET; i++) &#123;</span><br><span class="line">    initlock(&amp;bcache.bucketlocks[i], <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (b = bcache.buf; b &lt; bcache.buf+NBUF; b++) &#123;</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    b-&gt;next = bcache.buckets[<span class="number">0</span>].next;</span><br><span class="line">    bcache.buckets[<span class="number">0</span>].next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我最开始的实现中，bcache.lock 是用不上的（所以也没跑出正确答案）。但是根据 Hints：</p><p>Your solution might need to hold two locks in some cases; for example, during eviction you may need to hold the bcache lock and a lock per bucket. Make sure you avoid deadlock.</p><p>是需要上两把锁的，具体使用场景到后面再看。</p><p>由于我们现在不需要维护双向链表，在 brelse 的时候直接释放 buf 的 sleep 的 lock，然后再获取对应的 bucket 的 lock，将 refcnt– 即可，如果 refcnt &#x3D;&#x3D; 0，则将当前的 ticks 设置为 buf 的 timestamp。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> key = HASH_DEV_BLOCKNO(b-&gt;dev, b-&gt;blockno);</span><br><span class="line">  acquire(&amp;bcache.bucketlocks[key]);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">    b-&gt;timestamp = ticks;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  release(&amp;bcache.bucketlocks[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的修改 bpin 和 bunpin，这里就不贴出来了。</p><h3 id="bget"><a href="#bget" class="headerlink" title="bget"></a>bget</h3><p>整个 bget 是最折磨的地方，多线程场景下的问题还是太难发现了。</p><p>最开始我没有意识到问题的严重性，按照最初的思路，写了第一版代码，逻辑如下：</p><ol><li>获取 dev 和 blockno 对应的 bucket 的锁；</li><li>如果已经有缓存了就直接返回 buf，否则执行 3；</li><li>在所有的 bucket 中找出一个 refcnt 为 0，并且最近最久未使用的 buf。在这个过程中需要对 bucket 上锁，遍历完一个 bucket 之后，释放它的锁；</li><li>如果找到了这样的 buf，就申请它所在的 bucket 锁并进行 eviction，将它从原本的 bucket 中移除，否则直接 panic；</li><li>将找到的 buf 插入 dev 和 blockno 对应的 bucket 中，并设置 buf 的值；</li><li>释放 dev 和 blockno 对应的 bucket 的锁；</li><li>获取找到的 buf 的 sleeplock；</li><li>返回 buf；</li></ol><p>这样乍一看是没什么问题，但是事实并非如此。</p><p>首先一个容易注意到的点就是，会产生死锁。由于我们在发现没有缓存的时候，并没有释放刚刚获取的 bucket 的锁，然后就开始在所有 bucket 中找一个可以被 evict 的 buf，这时候要获取其它 bucket 的锁。那么如果一个进程 A 持有 bucket1 的锁，又去获取 bucket 2 的锁，但是进程 B 又持有 bucket2 的锁去获取 bucket1 的锁时，就产生了死锁。</p><p>所以在发现我们要找的 buf 并没有在缓存中时，要先释放当前持有的 bucket 的锁，再去进行 eviction。</p><p>第二个问题就是，当我们找到了那个可以被 evict 的 buf 时，将锁释放掉了，正式进行 evict 时，又去申请锁，但是在释放锁到重新申请锁的这个间隙，可能有其它进程又引用了刚刚找出来的那个 buf，使得它的 refcnt 不为 1，这个时候将其 evict 掉就会发生错误。</p><p>解决方案就是，在找出可以 evict 的 buf 后，不释放对应 bucket 的锁，而是直到 evict 之后再释放。那么其它进程在刚开始获取缓存的时候就会阻塞，因为它获取不到这个 bucket 的锁，待到 ecivt 结束后，它才能去查看 bucket，这时候它就看不到那个被 evict 的 buf 了。</p><p>完成以上两个修改之后，bcachetest 已经能够通过了。但是如果执行 usertests，第一个 manywrites 就无法通过，报的错误是 panic: freeing free block，即释放了一个原本已经释放的 block cache。而这种重复释放的原因，肯定就是同一个 block 被缓存了多次。</p><p>下面的思路来自于<a href="https://github.com/Miigon">Miigon</a>。</p><p>假设当前有两个进程同时访问同样缓存块，在第一个进程获取到对应的 bucket 锁后，发现不存在缓存，就释放了锁，进入寻找可 evict 的 buf 阶段。这时，第二个进程同样能够获取对应 bucket 的锁，并同样发现缓存不存在，也进入寻找可 evict 的 buf 阶段。</p><p>这个时候完全有可能发生的是，它们找到了两个不同的 buf，并且将它们 evict 掉之后都插入了它们要找的 block 对应的 bucket 中。这时就出现了同一块 block 有多个 cache 的情况。最后也就会触发 freeing free block。</p><p>这时候前文提到的那个 hint 就要回收了，再看一遍：</p><p>Your solution might need to hold two locks in some cases; for example, during eviction you may need to hold the bcache lock and a lock per bucket. Make sure you avoid deadlock.</p><p>再结合前一条：</p><p>It is OK to serialize eviction in bget (i.e., the part of bget that selects a buffer to re-use when a lookup misses in the cache).</p><p>现在想想其实就是暗示我们在寻找并 evict 可用 buf 的时候将整个流程串行化，保留最开始查看是否有缓存的并行。并且缓存丢失的概率一般来说都是非常低的，所以后面的串行化造成的性能损失其实是可以接受的。</p><p>所以现在利用上 bcache.lock，在发现缓存不存在释放掉对应 bucket 的锁之后，立刻获取 bcache.lock 这把大锁。由于在释放对应 bucket 锁到获取 bcache.lock 期间，可能有别的进程已经完成了对我们要找的 block 设置 cache，所以在获取完 bcache.lock 后，再进行一次查找缓存，如果发现已经存在了，就直接返回对应的 buf。</p><p>这样一来，就算有多个进程同时进入 bget，也只有第一个进程可以获取到 bcache.lock，并完成缓存的设置，后面的进程都会被获取完锁后的第二轮查找缓存给拦住。这样就避免了一个 block 被缓存多次。</p><p>下面是完整的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> key = HASH_DEV_BLOCKNO(dev, blockno);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.bucketlocks[key]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span> (b = bcache.buckets[key].next; b; b = b-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno) &#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;bcache.bucketlocks[key]);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;bcache.bucketlocks[key]);</span><br><span class="line">  <span class="comment">// 一定要先释放再去获取 bcache.lock</span></span><br><span class="line">  <span class="comment">// 否则如果另一个进程持有 bcache.lock，再在下面获取 bucketlocks[key] 就会死锁  </span></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (b = bcache.buckets[key].next; b; b = b-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno) &#123;</span><br><span class="line">      acquire(&amp;bcache.bucketlocks[key]);</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;bcache.bucketlocks[key]);</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached.</span></span><br><span class="line">  <span class="type">int</span> i, bidx = <span class="number">-1</span>, flag = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">tmp</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NBUCKET; i++) &#123;</span><br><span class="line">    acquire(&amp;bcache.bucketlocks[i]);</span><br><span class="line">    <span class="keyword">for</span> (b = &amp;bcache.buckets[i]; b-&gt;next; b = b-&gt;next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (b-&gt;next-&gt;refcnt == <span class="number">0</span> &amp;&amp; (!tmp || b-&gt;next-&gt;timestamp &gt; tmp-&gt;next-&gt;timestamp)) &#123;</span><br><span class="line">          tmp = b;</span><br><span class="line">          flag = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">      release(&amp;bcache.bucketlocks[i]); <span class="comment">// 如果没有找到 buf 就释放锁</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果找到了新 buf，那就释放之前找到的 buf 的 bucket 锁，并保留当前 bucket 的锁</span></span><br><span class="line">      flag = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (bidx != <span class="number">-1</span>) release(&amp;bcache.bucketlocks[bidx]);</span><br><span class="line">      bidx = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">    panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  b = tmp-&gt;next;</span><br><span class="line">  tmp-&gt;next = b-&gt;next;</span><br><span class="line">  release(&amp;bcache.bucketlocks[bidx]); <span class="comment">// 进行 evict 后再释放锁</span></span><br><span class="line">  </span><br><span class="line">  acquire(&amp;bcache.bucketlocks[key]);</span><br><span class="line">  b-&gt;next = bcache.buckets[key].next;</span><br><span class="line">  bcache.buckets[key].next = b;</span><br><span class="line">  b-&gt;dev = dev;</span><br><span class="line">  b-&gt;blockno = blockno;</span><br><span class="line">  b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">  b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">  release(&amp;bcache.bucketlocks[key]);</span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">  acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3a5f446f27d4dd1ac4690c109f64f29~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>多线程场景下的问题真的很难搞，感觉在业务场景下，用一些常见的模式还没有那么难。到系统编程的场景下，这些问题都要自己考虑，解决一个问题之后可能又产生另一个问题，我自己对于这方面的能力还是太弱了。</p><p>引用一下<a href="https://github.com/Miigon">Miigon</a>大佬的总结：</p><blockquote><p>锁竞争优化一般有几个思路：</p><ul><li>只在必须共享的时候共享（对应为将资源从 CPU 共享拆分为每个 CPU 独立）</li><li>必须共享时，尽量减少在关键区中停留的时间（对应“大锁化小锁”，降低锁的粒度）</li></ul></blockquote><p>第一种思路就是本次 lab 的第一部分，只有当前 CPU 的 freelist 已经为空时，才去和其它的 CPU 共享 freelist，其它情况下都是并行执行的。</p><p>第二种思路就是本次 lab 的第二部分，bcache 是没有办法单独划分给每个 CPU 的，属于必须共享，所以只能通过缩小临界区，缩小锁的粒度来实现。</p><p>后续这方面还是得多多加强。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab7: Multithreading</title>
      <link href="/post/9662ca7f.html"/>
      <url>/post/9662ca7f.html</url>
      
        <content type="html"><![CDATA[<p>本次实验要实现用户级线程之间的切换，使用多线程来加速程序，并实现屏障。</p><p>在听课的时候感觉这次实验是要实现内核级线程，让一个进程中的多个线程可以同时运行在多个 CPU 上面，感觉有点害怕。不过看实验说明书的时候才知道是实现的用户级线程，其实应该叫做协程，而且很多代码都已经给出来了，做之前要读一遍 user&#x2F;uthread.c。每个用户线程对应一个内核线程是 Optional chanllenge 部分的任务了，有时间再做吧。这样一来本次的实验还是很简单的。</p><h2 id="Uthread-switching-between-moderate"><a href="#Uthread-switching-between-moderate" class="headerlink" title="Uthread: switching between (moderate)"></a>Uthread: switching between (moderate)</h2><p>这部分是实现用户级线程的切换。在课上教授已经讲过了内核级线程是如何切换的了。大部分内容都可以借鉴。</p><p>在切换线程时，要把当前运行线程的 callee registers 保存下来。</p><p>thread_switch needs to save&#x2F;restore only the callee-save registers.</p><p>我对这里的理解是，用户级线程的切换一定是手动调用 thread_schedule 然后调用 thread_switch 进行切换的。所以对用户级线程来说，恢复现场就是在之前调用 thread_switch 函数后调用 ret 返回到 thread_schedule 函数中，那么由于 C 编译器会在调用函数的时候把 caller registers 保存在线程的栈上，所以我们只需要记下 ra 来定位返回的位置，还有 sp 指出线程栈的位置，并且把所有的 callee register 保存即可（跟内核级线程的切换 Context 是一样的）。</p><p>这部分要做得任务只有两个，在 thread_create 函数中添加代码。要做到线程的切换，我们必须初始化它的 ra 和 sp，这样才可以使得其它线程调用 thread_switch 通过 ret 返回跳到 ra 所在位置执行。在创建的时候设置 ra 和 sp 相当于伪造一个执行现场，返回到那里。</p><p>我选择是直接把寄存器存在 thread 结构体中，这样可以直接把 swtch.S 里的内容复制过来就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">    uint64     ra;</span><br><span class="line">    uint64     sp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// callee saved</span></span><br><span class="line">    uint64     s0;</span><br><span class="line">    uint64     s1;</span><br><span class="line">    uint64     s2;</span><br><span class="line">    uint64     s3;</span><br><span class="line">    uint64     s4;</span><br><span class="line">    uint64     s5;</span><br><span class="line">    uint64     s6;</span><br><span class="line">    uint64     s7;</span><br><span class="line">    uint64     s8;</span><br><span class="line">    uint64     s9;</span><br><span class="line">    uint64     s10;</span><br><span class="line">    uint64     s11;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>       <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/* the thread&#x27;s stack */</span></span><br><span class="line">    <span class="type">int</span>        state;             <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将线程的 ra 初始化为 func 的起始地址，并且设置线程栈。注意栈是从高地址扩展到低地址的，所以初始化的时候应该将指针指向栈的最高地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">thread_create</span><span class="params">(<span class="type">void</span> (*func)())</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  t-&gt;ra = (uint64)func;</span><br><span class="line">  t-&gt;sp = (uint64)t-&gt;<span class="built_in">stack</span> + STACK_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 thread_schedule 调用 thread_switch 就可以了。注意 t 才是当前线程，而 current 是要被调度的线程。</p><h2 id="Using-threads-moderate"><a href="#Using-threads-moderate" class="headerlink" title="Using threads (moderate)"></a>Using threads (moderate)</h2><p>这部分跟 xv6 无关了，就是用 pthread + lock 来控制并发访问一个 hash table。</p><p>先看一下 hash table 的实现。本质上是一个 entry 类型的数组，里面有 NBUCKET 个链表，key 通过摸 NBUCKET 来决定插入到哪个链表的表头。</p><p>所以回答第一个问题：</p><p>Why are there missing keys with 2 threads, but not with 1 thread? Identify a sequence of events with 2 threads that can lead to a key being missing.</p><p>当两个线程同时调用 insert 函数的时候，两个线程看到的链表头都是同一个，那么在插入的时候，后插入的会把先插入的给覆盖掉。</p><p>然后是实现并发控制，其实就是给每个 bucket 都分配一把锁，这样不同的线程在访问不同的 bucket 的时候就可以并发执行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> bucketlocks[NBUCKET]; <span class="comment">// 声明锁</span></span><br></pre></td></tr></table></figure><p>在 main 函数中调用 pthread_mutex_init 进行初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; i++) &#123;</span><br><span class="line">    pthread_mutex_init(&amp;bucketlocks[i], <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 put 中上锁即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = key % NBUCKET;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// is the key already present?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(e)&#123;</span><br><span class="line">    <span class="comment">// update the existing key.</span></span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// the new is new.</span></span><br><span class="line">    pthread_mutex_lock(&amp;bucketlocks[i]);</span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">    pthread_mutex_unlock(&amp;bucketlocks[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Barrier-moderate"><a href="#Barrier-moderate" class="headerlink" title="Barrier (moderate)"></a>Barrier (moderate)</h2><p>这部分要通过 pthread_cond 来实现一个 barrier。关于 barrier 和 waitgroup 的区别：</p><p>屏障是一种同步原语，它会阻止多个线程或 goroutine 的运行，直到它们都到达某个点，在该点它们都被同时释放。 屏障可用于确保仅在所有线程完成其<strong>计算的特定阶段</strong>后才执行某些操作。</p><p>另一方面，WaitGroup 是一种同步原语，用于等待一组 goroutine 完成它们的执行，然后再继续。 WaitGroup 用一个计数初始化，每个 goroutine 在开始工作之前递增计数，并在完成时递减计数。 主线程（或另一个 goroutine）在 WaitGroup 上等待，直到计数达到零，这表明所有 goroutine 都已完成。 这允许主线程与并行任务的完成同步。</p><p>直接实现 barrier 函数即可。需要注意的是 barrier 函数也可能出现竞态。比如说线程 1 进入 barrier，将 bstate.nthread 加 1，然后比较一下还没有达到 nthread，正打算休眠，结果线程 2 进入 barrier，将 bstate.nthread 加 1，比较一下发现已经达到了 nthread，于是执行了一次唤醒操作，接着线程 1 又休眠了，那么线程 1 无法被唤醒，下一轮也就永远无法到达 nthread 了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">barrier</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">  <span class="comment">// then increment bstate.round.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">  bstate.nthread++;</span><br><span class="line">  <span class="keyword">if</span> (bstate.nthread &lt; nthread) &#123;</span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    bstate.nthread = <span class="number">0</span>;</span><br><span class="line">    bstate.round++;</span><br><span class="line">    pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以通过上锁将增加 bstate.nthread++、比较、休眠或唤醒合成一个原子操作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次 lab 由于跟 xv6 相关的部分只有一个，并且跟教授上课讲得内核级线程的切换几乎一样，只是省去了先切换到调度线程这一步，所以实现起来很简单。后续有时间可以回来实现一下内核级线程。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab6: Copy-on-Write Fork for xv6</title>
      <link href="/post/b1b06482.html"/>
      <url>/post/b1b06482.html</url>
      
        <content type="html"><![CDATA[<p>lab6 是实现 COW fork，在 fork 子进程的时候不直接将父进程的物理内存复制给子进程，而是只复制页表，并且把双方 PTE 设置为只读的。在进程需要进行写操作的适合，会触发 page fault，处理 page fault 的时候再复制一份内存，映射给进程，然后把 PTE 重新映射并且修改为可读写。</p><p>COW 能够节约复制的时间，只复制要修改的 page，并且可以很大程度上避免复制完后调用 exec 的浪费。</p><h2 id="Implement-copy-on-write-hard"><a href="#Implement-copy-on-write-hard" class="headerlink" title="Implement copy-on write (hard)"></a>Implement copy-on write (hard)</h2><p>Your task is to implement copy-on-write fork in the xv6 kernel. You are done if your modified kernel executes both the cowtest and usertests programs successfully.</p><p>首先来实现 reasonable plans 中的第三点，修改 kernel&#x2F;kalloc.c。因为实现 COW 之后，就会存在多个进程引用同一个 page 的情况，所以当进程退出，要释放内存的时候不能直接释放，而是要看还有没有别的进程在引用该 page。</p><p>我们需要用一个计数器来记录每个 page 的引用数量，只有当引用数为 0 的时候才能释放。当调用 kernel&#x2F;kalloc.c#kalloc 函数的时候，将这个新分配的 page 的引用计数设置为 1。当调用 kernel&#x2F;kalloc.c#kfree 函数的时候，将需要释放的 page 的引用计数减 1，引用计数为 0 的时候释放物理内存。当执行 fork 系统调用的时候，在复制 page 的映射时，将 page 的引用计数加 1。</p><p>添加以下全局变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... kalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">pincountlock</span>;</span> <span class="comment">// 锁住计数器，防止发生竞态，记得在 kinit 中初始化锁</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pincounts[<span class="number">32768</span>]; <span class="comment">// 每个页的引用计数器</span></span><br></pre></td></tr></table></figure><p>再实现以下函数，用以操作 page 的引用计数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pa 转化成计数器的下标</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pa2pincount</span><span class="params">(uint64 pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (pa - KERNBASE) / PGSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对应 page 的引用计数加 1</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pin</span><span class="params">(uint64 pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  pa = PGROUNDUP(pa);</span><br><span class="line">  acquire(&amp;pincountlock);</span><br><span class="line">  <span class="keyword">if</span> (pincounts[pa2pincount(pa)] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    pincounts[pa2pincount(pa)]++; </span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;pincountlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对应 page 的引用计数减 1</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">unpin</span><span class="params">(uint64 pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  pa = PGROUNDUP(pa);</span><br><span class="line">  acquire(&amp;pincountlock);</span><br><span class="line">  <span class="keyword">if</span> (pincounts[pa2pincount(pa)] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    pincounts[pa2pincount(pa)]--;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;pincountlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 kalloc 和 kfree 函数，加上对引用计数的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  unpin((uint64)pa);</span><br><span class="line">  acquire(&amp;pincountlock);</span><br><span class="line">  <span class="keyword">if</span> (pincounts[pa2pincount((uint64)pa)] != <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;pincountlock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;pincountlock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">    uint64 pa = (uint64) r;</span><br><span class="line">    pincounts[pa2pincount(pa)] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 kernel&#x2F;vm.c#uvmcopy() 函数，让它不实际复制内存，而是复制一下页表，并且把父子进程的 W 位置为 0。并且我们需要在 PTE 中的 flags 中选择一位用作 COW 标识。我这里选择的是 RSW 的低位。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/811e09570d6b4b35a6a5dfaf99d8a508~tplv-k3u1fbpfcp-zoom-1.image"></p><p>我在 riscv.h 中定义了一个宏来方便计算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_COW (1L &lt;&lt; 8)</span></span><br></pre></td></tr></table></figure><p>我直接将 lab3 写过的复制页表的函数复制过来，稍微做了一些修改，然后在原本复制内存的函数中调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> uvmcopypg(old, new, sz, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopypg</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">pagetable_t</span> npagetable, uint64 sz, uint64 start)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = PGROUNDUP(start); i &lt; sz; i+=PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopypg: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopypg: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    *pte &amp;= ~PTE_W; <span class="comment">// 将 W 位置为 0</span></span><br><span class="line">    *pte |= PTE_COW; <span class="comment">// 将 COW 位置为 1</span></span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="keyword">if</span>(mappages(npagetable, i, PGSIZE, pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    pin(pa); <span class="comment">// 映射成功，将这一页的引用计数加 1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  err:</span><br><span class="line">  uvmunmap(npagetable, PGROUNDUP(start), (i - PGROUNDUP(start)) / PGSIZE, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来实现一个 page fault handler 来处理 COW fork page fault，在这个函数中进行一些判断看能否处理这个 page fault，如果不行就返回 -1，否则返回 1，用于在 usertrap 中杀死进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">cowhandler</span><span class="params">(uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint flags; </span><br><span class="line">  va = PGROUNDDOWN(va);</span><br><span class="line">  <span class="keyword">if</span> (va &gt;= MAXVA) &#123; <span class="comment">// 测试 copyout 的时候 walk 中爆了 panic，va 存在大于 MAXVA 的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pte = walk(p-&gt;pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// va 必须在 heap 中，并且对应的 pte 必须存在且有效，同时 COW 位应该是 1</span></span><br><span class="line">  <span class="keyword">if</span> (va &gt;= p-&gt;sz || ((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) == <span class="number">0</span>) || (*pte &amp; PTE_COW) == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  uint64 pa = PTE2PA(*pte); <span class="comment">// 将旧 page 的地址取出用于复制</span></span><br><span class="line">  uint64 ka = (uint64) kalloc();   <span class="comment">// 分配新的 page</span></span><br><span class="line">  <span class="keyword">if</span> (ka == <span class="number">0</span>) &#123; <span class="comment">// hints 中说如果没有内存可以分配了就杀死进程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  memmove((<span class="type">void</span> *)ka, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">  <span class="comment">// 将标识设置为可写，并去掉 COW 标识</span></span><br><span class="line">  flags = PTE_FLAGS(*pte);</span><br><span class="line">  flags &amp;= ~PTE_COW;</span><br><span class="line">  flags |= PTE_W;</span><br><span class="line">  uvmunmap(p-&gt;pagetable, va, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 在取消映射时会调用 kfree，这里不用调用 unpin</span></span><br><span class="line">  <span class="keyword">if</span> (mappages(p-&gt;pagetable, va, PGSIZE, ka, flags)) &#123;</span><br><span class="line">    kfree((<span class="type">void</span> *) ka);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟 lazy allocation 一样，需要在 usertrap 中调用 page fault handler 来处理 page fault。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ... usertrap</span></span><br><span class="line">  intr_on();</span><br><span class="line"></span><br><span class="line">  syscall();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) &#123;</span><br><span class="line">  uint64 va = r_stval();</span><br><span class="line">  <span class="keyword">if</span> (cowhandler(va) == <span class="number">-1</span>) &#123; <span class="comment">// 调用 cowhandler 返回值为 -1 就杀死进程</span></span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">  p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后只需要在 copyout 中调用 cowhandler 函数来处理 dstva 指向的是 on-demand page 的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    cowhandler(dstva);</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>lab6 只有一个部分，任务指导书也讲得非常清楚，实现起来不是很难。我在做得时候由于一开始没有对 pincount 上锁，导致发生竞态卡了不少时间。</p><p>到这个 lab 应该就是虚拟内存系列 lab 的最后一个了，感觉还是 lab3 是最为困难的，在写完 lab3 之后对整个 xv6 就会有一定的理解了，对操作虚拟内存也会更加熟悉，做后面这几个就没有那么困难了。</p><p>对于 page table、traps、page fault 有了较为深入的理解，收获很大。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab5: xv6 lazy page allocation</title>
      <link href="/post/32a9d8d3.html"/>
      <url>/post/32a9d8d3.html</url>
      
        <content type="html"><![CDATA[<p>xv6 中 sbrk 的实现默认是 eager allocation，也就是一旦用户进程申请了内存，那么内核马上就会分配。但实际上，用户进程难以估量自己需要多少内存，所以往往会额外申请，导致内存消耗增加，并且有部分内存永远不会被用到。</p><p>所以可以用 lazy page allocation 来解决这个问题，sbrk 只用来记住分配了哪些用户地址（即更新 sz），而不先分配内存，直到产生了 page fault 再分配内存。</p><h2 id="Lazytests-and-Usertests"><a href="#Lazytests-and-Usertests" class="headerlink" title="Lazytests and Usertests"></a>Lazytests and Usertests</h2><p>partⅠ和 partⅡ 的话，Frans 教授在课上讲过了，这里就不重复了。partⅢ 就是实现 Frans 教授说的要对 xv6 做进一步的修改，这些修改都已经写在 Hints 中了：</p><ol><li>处理 sbrk 的参数为负数的情况；</li><li>如果发生 page fault 的地址比 sbrk 分配的地址还大的时候，杀死进程；</li><li>处理用户进程通过系统调用传递了一个正确的地址，但是这个地址还没有被分配内存的情况（即修改copyin 和 copyout 等函数）。</li><li>如果发生 page fault 后没有可用内存了，杀死进程；</li><li>如果发生 page fault 的地址访问到了 guard page，杀死进程。</li></ol><p>第一个要修改的地方在 kernel&#x2F;sysproc.c#sys_sbrk 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    myproc()-&gt;sz = myproc()-&gt;sz + n; <span class="comment">// just add sz, but not allocate memory.</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    myproc()-&gt;sz = uvmdealloc(myproc()-&gt;pagetable, myproc()-&gt;sz, myproc()-&gt;sz + n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前两个部分中，我们在 kernel&#x2F;trap.c#usertrap 中添加了代码，那么对它进行进一步的修改，添加了一个 pgfhandler 函数，用来处理指定虚拟地址发生的 page fault：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="comment">// ok</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">15</span> || r_scause() == <span class="number">13</span>) &#123;</span><br><span class="line">  <span class="comment">// load page fault or store page fault</span></span><br><span class="line">  uint64 va = r_stval(); <span class="comment">// va is the address that cause the page fault</span></span><br><span class="line">  <span class="keyword">if</span> (pgfhandler(va) == <span class="number">-1</span>) &#123; <span class="comment">// if can&#x27;t handle the page fault, kill the process</span></span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">  p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中，我们判断是否能够进行 page fault handle，如果不行就杀死这个进程。做了以下判断：</p><ol><li>该虚拟地址是否在堆中；</li><li>该虚拟地址是否访问到了 guard page；</li><li>是否还有物理内存可以分配；</li><li>新分配的页是否已经映射了，防止报 remap。</li></ol><p>如果可以处理，那么就进行处理，否则返回 0，在 usertrap 中将 p-&gt;killed 标识为 1（如果在这里面标识为 1 的话会杀死初始进程）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pgfhandler</span><span class="params">(uint64 va)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span> (va &gt;= p-&gt;sz || PGROUNDUP(va) == p-&gt;kstack) &#123;</span><br><span class="line">    <span class="comment">// if va is a invalid address, kill the process.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    uint64 ka = (uint64) kalloc();</span><br><span class="line">    <span class="keyword">if</span> (ka == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// if there is no memory can use, kill the process.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">memset</span>((<span class="type">void</span> *) ka, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      va = PGROUNDDOWN(va);</span><br><span class="line">      <span class="type">pte_t</span> * pte;</span><br><span class="line">      <span class="comment">// avoid remap panic.</span></span><br><span class="line">      <span class="keyword">if</span> ((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) != <span class="number">0</span> &amp;&amp; (*pte &amp; PTE_V) != <span class="number">0</span>) &#123;</span><br><span class="line">        kfree((<span class="type">void</span> *) ka);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// map new page above.</span></span><br><span class="line">      <span class="keyword">if</span>(mappages(p-&gt;pagetable, va, PGSIZE, ka, PTE_W|PTE_U|PTE_R) != <span class="number">0</span>) &#123;</span><br><span class="line">        kfree((<span class="type">void</span> *) ka);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意要把 kernel&#x2F;vm.c#uvmunmap 和 kernel&#x2F;vm.c&#x2F;uvmcopy 函数中的 panic 去掉，直接 continue 即可，因为使用了 lazy allocation 之后，在 unmap 的时候会出现 walk 不出来或者本来就没有 map 的情况，不能 panic，在 uvmcopy 的时候也会出现 walk 不出来，或者复制到了一个无效的 pte。代码就不贴出来了。</p><p>最后一步，修改 kernel&#x2F;vm.c#copyin, kernel&#x2F;vm.c#copyinstr, kernel&#x2F;vm.c#copyout，将需要访问的用户空间地址做一个预处理，也就是调用 pgfhandler 先进行一波缺页处理，否则这些函数可能访问到没有分配的内存。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次 lab 相对简单，尤其是 Frans 教授上课已经把前两部分讲了，也很详细的讲了 page fault 是如何处理的。就是有一些细节要注意，我最开始就没想到要处理 copyin 和 copyout。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab4: Traps</title>
      <link href="/post/282c8539.html"/>
      <url>/post/282c8539.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>This lab explores how system calls are implemented using traps. You will first do a warm-up exercises with stacks and then you will implement an example of user-level trap handling.</p></blockquote><p>lab4 相对 lab3 要简单很多，需要写的代码行数不多，并且给的 hints 也很直接。只要听了 lecture 5 和 lecture 6 都能够明白其中的原理。这两次课分别讲了 xv6 的栈结构跟 trap 的一些细节。</p><h2 id="RISC-V-assembly-easy"><a href="#RISC-V-assembly-easy" class="headerlink" title="RISC-V assembly (easy)"></a>RISC-V assembly (easy)</h2><p>就是去看 user&#x2F;call.c 和 user&#x2F;call.asm 中的函数 g, f, main，然后回答一些问题。我没有看 RISC-V 的手册，太长了有点不好搜索。有不懂的指令去 Google 一下反而还方便一点。这边就直接贴出答案了，第三题的答案可能会不一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Q: Which registers contain arguments to functions? For example, which register holds 13  in main&#x27;s call to printf?</span><br><span class="line">A: a0-a7. a2.</span><br><span class="line"></span><br><span class="line">Q: Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)</span><br><span class="line">A: Function f and g are inlined by the compiler.</span><br><span class="line"></span><br><span class="line">Q: At what address is the function printf located?</span><br><span class="line">A: 0x630.</span><br><span class="line"></span><br><span class="line">Q: What value is in the register ra just after the jalr to printf in main?</span><br><span class="line">A: 0x38.</span><br><span class="line"></span><br><span class="line">Q: ...</span><br><span class="line">A: Set i to 0x726c6400. Do not need to modify 57616, because it&#x27;s decimal value is just  110. Little- or big-endian is no matter with values.</span><br><span class="line"></span><br><span class="line">Q: ...</span><br><span class="line">A: It will read the value set in register a2 by the previous function.</span><br></pre></td></tr></table></figure><h2 id="Backtrace-moderate"><a href="#Backtrace-moderate" class="headerlink" title="Backtrace (moderate)"></a>Backtrace (moderate)</h2><p>这部分是实现一个类似于 gdb 的 backtrace，打印函数调用栈帧中的返回地址。在 kernel&#x2F;printf.c 中添加一个 backtrace() 函数，然后在 sys_sleep 中调用 进行测试。</p><p>要实现 backtrace 首先要理解 xv6 的函数栈帧结构，根据老师上课的 ppt：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a608d22b3c5e44a19680ade600fcf85d~tplv-k3u1fbpfcp-zoom-1.image"></p><p>可以看到，函数栈帧之间其实就像一个链表，被 fp 指针给连接到一起，所以我们只需要拿到当前函数的 fp，就可以一直遍历整个函数调用链。当前的 fp 被存放在 s0 寄存器中。在 kernel&#x2F;risv.h 中添加以下函数来取出 s0 中的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_fp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在栈中，函数的返回地址固定在 fp - 8 的位置，调用该函数的函数的 fp 在 fp - 16 的位置。我们一直遍历到这一页结束就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 fp, ra, last;</span><br><span class="line">  fp = r_fp();</span><br><span class="line">  last = PGROUNDUP(fp);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    ra = fp<span class="number">-8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *((uint64 *)(ra)));</span><br><span class="line">    fp = *((uint64 *)(fp<span class="number">-16</span>));</span><br><span class="line">    <span class="keyword">if</span> (fp == last) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Alarm-hard"><a href="#Alarm-hard" class="headerlink" title="Alarm (hard)"></a>Alarm (hard)</h2><p>这部分就是有难度的地方了。要实现一个用户级的中断，用户程序通过调用 sigalarm(interval, handler) 系统调用来设置一个计时器，每隔 interval 个 tick，就调用 handler 函数进行处理。并且在 handler 函数返回之后，会调用 sigreturn() 函数，被中断的用户程序要正常恢复执行，也就是说对于被中断的用户程序来说 alarm handler是透明的。</p><p>每次在收到 timer 硬件发出的中断时，就是一个 tick，它不是一个确定的时间单位。而 timer interrupt 会触发 trap，所以可以知道 alarm handler 是要在 trap 中触发的，类似于在 trap 中又套了一层 trap。</p><p>我们需要在 struct proc 结构体中添加一些新的属性来保存触发 handler 的间隔，handler 函数指针，距离上次调用 handler 过去了几个 tick，当前是否有 handler 在执行，以及一个 struct trapframe 用来保存被打断的程序的寄存器值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... struct proc</span></span><br><span class="line"><span class="type">int</span> ticks;                   <span class="comment">// Alarm ticks</span></span><br><span class="line"><span class="type">void</span> (*handler)();           <span class="comment">// Alarm handler</span></span><br><span class="line"><span class="type">int</span> passedticks;             <span class="comment">// Record how many ticks passed</span></span><br><span class="line"><span class="type">int</span> isrunninghandler;        <span class="comment">// Avoid re-entrant calls to a handler</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">savedtf</span>;</span>   <span class="comment">// Save trapframe when call handler</span></span><br></pre></td></tr></table></figure><p>ticks、handler、passedticks 在 sigalarm 系统调用中设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="type">int</span> ticks;</span><br><span class="line">  uint64 handler;</span><br><span class="line">  <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;ticks) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">1</span>, &amp;handler) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  p-&gt;ticks = ticks;</span><br><span class="line">  p-&gt;handler = (<span class="type">void</span> (*)()) handler;</span><br><span class="line">  p-&gt;passedticks = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在 kernel&#x2F;trap.c#usertrap 中处理 timer interrupt。当 which_dev &#x3D; 2 的时候，表明是 timer interrupt。</p><p>由于执行完 handler 之后，需要回到被中断的程序继续执行，所以在这里要将这个程序的状态保存下来，在 sigreturn 系统调用中恢复。我这里图方便就直接将所有的寄存器和状态都保存下来了。保存完状态后，<strong>将 p-&gt;trapframe-&gt;epc 的值设置为 handler 的地址</strong>。usertrap 会调用 usertrapret，usertrapret 会将 p-&gt;trapframe-&gt;epc 设置到 spec 寄存器中，userret 在返回时调用 sret 指令会将 sepc 寄存器中的值设置到 pc 中，所以用户程序就会跳到 handler 中去执行了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// ok</span><br><span class="line">if (which_dev == 2 &amp;&amp; p-&gt;ticks != 0) &#123;</span><br><span class="line">  p-&gt;passedticks++;</span><br><span class="line">  // if there is no handler running and it&#x27;s time to call handler</span><br><span class="line">  if (p-&gt;passedticks == p-&gt;ticks &amp;&amp; p-&gt;isrunninghandler == 0) &#123;</span><br><span class="line">    p-&gt;isrunninghandler = 1;</span><br><span class="line">    // save trapframe</span><br><span class="line">    memmove(p-&gt;savedtf, p-&gt;trapframe, sizeof(struct trapframe));</span><br><span class="line">    p-&gt;trapframe-&gt;epc = (uint64) p-&gt;handler;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 handler 程序执行完后，在测试中就是 periodic 函数，其中会调用 sigreturn，在这里面回复原来的函数的执行。</p><p>首先将 passedticks 重置，以便下一轮触发，然后将 isrunninghandler 置 0，表示没有在执行的 handler，然后将保存在 savedfp 中的寄存器值都重新写入 trapframe 中，接着调用 usertrapret 将寄存器的值都恢复，就像从 trap 中恢复出来一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  p-&gt;passedticks = <span class="number">0</span>;</span><br><span class="line">  p-&gt;isrunninghandler = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// Restore trapframe</span></span><br><span class="line">  memmove(p-&gt;trapframe, p-&gt;savedtf, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">  <span class="comment">// Restore registers when usertrapret calls userret, and userret calls sret to back to the interrupted code.</span></span><br><span class="line">  usertrapret();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次的 lab 其实就像老师喂饼一样，看过 lecture5&#x2F;6 之后，再把 xv6 book Chapter4 看完，其中的原理肯定会明白，然后就是一些小细节可能会为难一点（C 语言不太好的甚至会被语法为难😭），其它难点不多，但是确实对 trap 有深入的理解。Robert 我的神！</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab3: Page Table</title>
      <link href="/post/b51235b3.html"/>
      <url>/post/b51235b3.html</url>
      
        <content type="html"><![CDATA[<p>lab3 属实是重量级，折磨了我好长时间。做 lab3 之前一定一定一定要先仔细的看 <a href="https://pdos.csail.mit.edu/6.S081/2020/xv6/book-riscv-rev1.pdf">xv6 book</a> 和<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/pgtbl.html">任务指导书</a>，不然就是无头苍蝇乱碰了。</p><p>同时还有 kernel&#x2F;memlayout.h、kernel&#x2F;vm.c、kernel&#x2F;kalloc.c 都需要认真看看相关代码。</p><p>Lab3 就是要给每一个进程都添加一个自己的内核页表，并且把用户页表中的映射给复制进去，在进程进入内核态之后，可以使用进程中的内核页表，通过硬件来进行寻址。在实现这个 lab 之前，xv6 只能从用户态传入一个地址，但是这个地址在内核中是无法使用的，因为内核页表中没有这个映射，所以只能通过软件模拟 MMU 来进行寻址，效率不高。</p><h2 id="Print-a-page-table-easy"><a href="#Print-a-page-table-easy" class="headerlink" title="Print a page table (easy)"></a>Print a page table (easy)</h2><p>任务书上说是可以帮助后面的 debug，但是我没有用到。不过可以做到对于 xv6 的页表有一个初步的认识。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33074b82b5b04df996bdf0c4f9f0aed6~tplv-k3u1fbpfcp-zoom-1.image"></p><p>xv6 的页表如上图所示。在 CPU 的 satp 寄存器中存储了第二层页表的物理地址，它里面存储了 512 条 PTE（page table entry），每条 PTE 的高 44 位 PPN 用于计算出下一层页表的物理地址或者拼接出存储数据的物理地址。一条虚拟地址被分成了 L2、L1、L0 各 9 bit，对应着三层页表，分别指出三层页表中的 PTE。还有 offset，占 12 bit，用于和第 0 层的 PPN 拼接得到数据的物理地址。</p><p>所以要打印这个页表，我们就要从第二层开始，逐层遍历 PTE 并打印，然后取出下一层的页表开始遍历打印，直到最低层。</p><p>pagetable_t 其实就是一个 uint64 类型的指针，其实也就是一个数组，数组中有 512 个元素对应 512 条 PTE，进行遍历的过程中要判断 PTE 是否有效，无效就不打印，还要判断 PTE 是否指向下一层的页表，如果是就将 PTE 转化成下一层页表的物理地址，递归到下一层进行打印，否则就直接打印。根据任务指导书，具体如何判断 PTE 参考 kernel&#x2F;vm.c#freewalk 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_vmprint(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level) &#123;</span><br><span class="line">  <span class="keyword">if</span> (level == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> (pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="keyword">if</span> (level != <span class="number">0</span> &amp;&amp; !((pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="number">0</span>)) <span class="keyword">continue</span>;</span><br><span class="line">      uint64 pa = PTE2PA(pte);</span><br><span class="line">      <span class="type">int</span> j;</span><br><span class="line">      <span class="keyword">for</span> (j = level; j &lt;= <span class="number">2</span>; j++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">2</span>) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;.. &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, pa);</span><br><span class="line">      _vmprint((<span class="type">pagetable_t</span>) pa, level<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  _vmprint(pagetable, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="A-kernel-pagetable-per-process-hard"><a href="#A-kernel-pagetable-per-process-hard" class="headerlink" title="A kernel pagetable per process (hard)"></a>A kernel pagetable per process (hard)</h2><p>xv6 中，每个进程都有一个自己的用户空间页表，这个页表只包含该进程的用户地址空间的映射。在内核中有一个单独的内核页表，所有的进程进入内核态后，都是用的是这个内核页表。<strong>所以用户地址在内核中是无法使用的，因为内核页表中没有对该地址的映射</strong>，<strong>只能通过 walk 来模拟 MMU 将用户虚拟地址再转化为物理地址使用。</strong></p><p>所以部分的任务就是给每个进程都弄一个自己的内核页表，并且在下个部分将用户空间页表中的映射复制到自己的内核页表中，这样在进入内核态的时候就可以直接使用这些映射了。</p><p>首先，我们在 strcut proc 中添加一个 kpagetable 变量来存储内核页表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pagetable_t</span> kpagetable;      <span class="comment">// Process&#x27;s kernel pagetable</span></span><br></pre></td></tr></table></figure><p>我们需要在创建进程的时候给他复制一份内核页表，内核页表是通过 kernel&#x2F;vm.c#kvminit 初始化，在其中使用 kernel&#x2F;vm.c#kvmmap 进行一些映射，我们需要修改版的 kvminit 函数和 kvmmap 函数来对进程的内核页表进行修改。因为这两个函数只是针对全局的 kernel_pagetable，没办法传参数。照着写就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ukvmmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;ukvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_kpagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line">  pagetable = uvmcreate();</span><br><span class="line">  <span class="keyword">if</span> (pagetable == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  ukvmmap(pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  ukvmmap(pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CLINT</span></span><br><span class="line">  ukvmmap(pagetable, CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  ukvmmap(pagetable, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  ukvmmap(pagetable, KERNBASE, KERNBASE, (uint64) etext - KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  ukvmmap(pagetable, (uint64) etext, (uint64) etext, PHYSTOP - (uint64) etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  ukvmmap(pagetable, TRAMPOLINE, (uint64) trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在 kernel&#x2F;proc.c#allocproc 中调用上述函数来初始化进程的内核页表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... kernel/proc.c#allocproc</span></span><br><span class="line">p-&gt;kpagetable = proc_kpagetable(p);</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;kpagetable == <span class="number">0</span>) &#123;</span><br><span class="line">  freeproc(p);</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照任务说明书，我们需要将进程的内核栈映射到内核页表中，原本内核栈的初始化是在 kernel&#x2F;proc.c#procinit 中，现在我们将内核栈放在 allocproc 中来分配，就跟在内核页表初始化之后。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... kernel/proc.c#allocproc</span></span><br><span class="line"><span class="type">char</span> *pa = kalloc();</span><br><span class="line"><span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">  panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">uint64 va = KSTACK((<span class="type">int</span>) (p - proc));</span><br><span class="line">ukvmmap(p-&gt;kpagetable, va, (uint64) pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">p-&gt;kstack = va;</span><br></pre></td></tr></table></figure><p>到这里内核页表就初始化完成了。接下来修改 kernel&#x2F;proc.c#scheduler 函数，因为当前每个进程有了自己的内核页表，那么在进入内核态之后就要使用自己的页表，也就是将第二层页表的物理地址放入 satp 寄存器中，<strong>在进程执行完之后一定要把全局的内核页表再设置回去</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... kernel/proc.c#scheduler</span></span><br><span class="line">p-&gt;state = RUNNING;</span><br><span class="line">c-&gt;proc = p;</span><br><span class="line">w_satp(MAKE_SATP(p-&gt;kpagetable));</span><br><span class="line">sfence_vma(); <span class="comment">// 使用 vma 指令清除 TLB 缓存，否则可能访问到其他进程的数据！</span></span><br><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line">kvminithart(); <span class="comment">// 在切换完毕之后使用 kvminithart 将全局内核页表设置会 satp</span></span><br></pre></td></tr></table></figure><p>接下来就是释放页表空间了，这一部分也卡了我很久。在 kernel&#x2F;proc.c#freeproc 中是释放进程的逻辑，我们要在这里面添加释放进程的内核页表的逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;kpagetable)</span><br><span class="line">  proc_freekpagetable(p, p-&gt;sz);</span><br><span class="line">p-&gt;kpagetable = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>proc_freekpagetable 函数的实现主要干了两件事，第一是释放掉进程的内核栈，第二是取消了进程的内核页表中的映射，但是<strong>一定不能释放映射指向的物理地址</strong>！因为进程的内核页表仅仅只是复制了映射。我们只释放页表本身的空间。</p><p>仿照 freewalk 实现了 proc_freekpagetable 函数，只释放掉页表页，而不释放最低层 PTE 指向的物理内存，具体做法是判断 PTE 是否还是指向下一层页表，如果是才进到下一层释放，这样就不会进到数据页中去释放内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freekpagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> ((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>) &#123; <span class="comment">// 判断是否还有下一层</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      freekpagetable((<span class="type">pagetable_t</span>) child);</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*) pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里 usertests 测试就可以通过了。</p><h2 id="Simplify-copyin-x2F-copyinstr-hard"><a href="#Simplify-copyin-x2F-copyinstr-hard" class="headerlink" title="Simplify copyin&#x2F;copyinstr (hard)"></a>Simplify copyin&#x2F;copyinstr (hard)</h2><p>这部分就是在刚刚给进程添加的内核页表中添加用户地址空间的映射。那么在内核中就可以直接使用用户空间地址，使用硬件 MMU 进行寻址，相比于用软件模拟 MMU 寻址效率更高。目标就是将 kernel&#x2F;vm.c#copyin 和 kernel&#x2F;vm.c#copyinstr 分别替换成 kernel&#x2F;vmcopyin.c#copyin_new 和 kernel&#x2F;vmcopyin.c#copyinstr_new。所以我们要在修改用户页表的每一处也对进程的内核页表都进行同步才能做到这一点。</p><p>首先仿照 kernel&#x2F;vm.c#uvmcopy 实现 kernel&#x2F;vm.c#uvmcopypg 用以拷贝页表，因为 uvmcopy 是在 fork 的时候把父进程的内存拷贝给子进程，所以它新分配了物理内存给子进程，所以我们不能直接用，因为<strong>内核页表仅仅只是拷贝映射</strong>，而拷贝映射的空间在 allocproc 时就已经分配了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopypg</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">pagetable_t</span> kpagetable, uint64 sz, uint64 start)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = PGROUNDUP(start); i &lt; sz; i+=PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopypg: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopypg: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte) &amp; ~PTE_U; <span class="comment">// 一定要设置 U 标识符，否则内核无法访问这个 PTE</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mappages(kpagetable, i, PGSIZE, pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  err:</span><br><span class="line">  uvmunmap(kpagetable, PGROUNDUP(start), (i - PGROUNDUP(start)) / PGSIZE, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来按照提示，分别在 kernel&#x2F;proc.c#userinit、kernel&#x2F;proc.c#fork、kernel&#x2F;exec.c#exec、kernel&#x2F;proc.c#growproc 中添加同步内核页表的代码。</p><p><strong>userinit</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 在进程页表初始化完成之后拷贝页表</span></span><br><span class="line"><span class="comment">// copy pagetable&#x27;s mappings to kpagetable, but don&#x27;t copy pa.</span></span><br><span class="line"><span class="keyword">if</span> (uvmcopypg(p-&gt;pagetable, p-&gt;kpagetable, p-&gt;sz, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  panic(<span class="string">&quot;uvmcopypg: fail to copy pagetable to kpagetable!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fork</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 在子进程拷贝完父进程的用户页表后，再将子进程的用户页表拷贝给内核页表</span></span><br><span class="line"><span class="keyword">if</span>(uvmcopypg(np-&gt;pagetable, np-&gt;kpagetable, p-&gt;sz, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  freeproc(np);</span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exec</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在成功生成 user image 后，先清除原本的内核页表，再将新的用户页表拷贝到内核页表</span></span><br><span class="line">uvmunmap(p-&gt;kpagetable, <span class="number">0</span>, PGROUNDUP(oldsz) / PGSIZE, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (uvmcopypg(pagetable, p-&gt;kpagetable, sz, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">goto</span> bad;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Commit to the user image.</span></span><br><span class="line">oldpagetable = p-&gt;pagetable;</span><br><span class="line">p-&gt;pagetable = pagetable;</span><br></pre></td></tr></table></figure><p><strong>growproc</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在进程空间扩容并且进程用户页表扩容之后，将扩容的那部分数据拷贝到内核页表</span></span><br><span class="line">    <span class="keyword">if</span> (uvmcopypg(p-&gt;pagetable, p-&gt;kpagetable, sz, sz-n)&lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果拷贝失败了，那么进程就要缩回到原本的容量</span></span><br><span class="line">      sz = uvmdealloc(p-&gt;pagetable, sz, sz-n);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">    <span class="comment">// 在进程空间缩小后并且进程页表页表也缩小之后，将缩小的那部分映射给去掉</span></span><br><span class="line">    <span class="type">int</span> npages = (PGROUNDUP(sz-n) - PGROUNDUP(sz)) / PGSIZE;</span><br><span class="line">    uvmunmap(p-&gt;kpagetable, PGROUNDUP(sz), npages, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于操作系统最低的虚拟地址在 0xC000000，也就是 PLIC 寄存器的地址，如果用户地址空间范围到了 0xC000000 之上，那么就会覆盖掉内核的数据。我们要限制用户地址空间不能超过这个地址。所以我们在 growproc 中判断，如果新的 sz 大于等于 PLIC 了，那么就直接返回 -1 而不执行扩容。</p><p>最后就是一个很大的坑，也就是上述全部实现之后会报 remap 的错误，返回去看 xv6 book 之后才发现，在 PLIC 之下还有一段数据是 CLINT，所以如果映射到了这一段，而这里是我们在初始化内核页表的时候就进行映射了的，所以会报 remap 错误。</p><p>查看 start.c 后发现 CLINT 仅在内核启动的时候需要，也就是说用户进程在内核中并不需要使用到这一段，所以干脆直接在初始化内核页表的时候不进行这部分的映射了。</p><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/170f9ee70f9e4ff59711e06f0c10a916~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个 lab3 确实难度不低，首先要对 xv6 的页表机制有一个比较深入的理解，然后 DEBUG 也比较难，我除了用 gdb 调试之外，还用了很多 panic 来尽早的发现是在哪里错了。如果不仔细读 xv6 book 把他理解清除的话大抵是做不出来了吧。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab2: System Calls</title>
      <link href="/post/ef0d189.html"/>
      <url>/post/ef0d189.html</url>
      
        <content type="html"><![CDATA[<p>这个 lab 是让我们在 xv6 中添加两个新的系统调用，来熟悉系统调用是怎么工作的，还有阅读内核代码，后续的 lab 中会添加更多的系统调用。</p><h2 id="System-call-tracing-moderate"><a href="#System-call-tracing-moderate" class="headerlink" title="System call tracing (moderate)"></a>System call tracing (moderate)</h2><p>trace 系统调用用于追踪程序执行的过程中的系统调用。trace 的使用方法是 trace + mask + 用户程序及参数，比如：</p><p>控制台输入 trace 32 grep hello README，就会出现以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ trace 32 grep hello README</span><br><span class="line">3: syscall read -&gt; 1023</span><br><span class="line">3: syscall read -&gt; 966</span><br><span class="line">3: syscall read -&gt; 70</span><br><span class="line">3: syscall read -&gt; 0</span><br></pre></td></tr></table></figure><p>为什么只 trace 了 read 呢？是因为参数 mask 为 32，二进制为 100000，从 0 开始第 5 位为 1，对应着read 系统调用号 5，所以 mask 用 bitmap 的方式来标识要追踪哪些系统调用。</p><p>根据任务提示，在 user&#x2F;user.h 中添加系统调用的 prototype，在 user&#x2F;usys.pl 中添加 stub，在 kernel&#x2F;syscall.h 中添加新的 syscall number，仿照原有的系统调用来写即可。</p><p>接下来是 trace 的实现逻辑，其实就是在进程的数据结构 struct proc 中添加一个新的成员变量 trace_mask 来记录要对哪些系统调用进行 trace。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="type">int</span> trace_mask;              <span class="comment">// To remember trace mask</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统调用的入口处在 kernel&#x2F;syscall.c#syscall 函数中，在这里根据寄存器 a7 中存储的系统调用号，从 syscalls 数组中取出对应的系统调用进行执行，所以我们要在上面的声明中加入我们在 sysproc.c 中新实现的 sys_trace 函数。其实它干的事情就仅仅是在进程中设置 trace_mask 而已。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    myproc()-&gt;trace_mask = mask;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 syscalls 取出一个系统调用函数并执行完毕后，我们就可以通过存储在 proc 中的 trace_mask 来判断这个系统调用是否需要进行 trace 了，也就是判断 trace_mask 中这个系统调用号这一位是不是 1。如果是的话就按照 lab 的格式需要打印 trace 信息。我们需要一个数组来存储系统调用号和系统调用名的对应关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="type">int</span> pid = p-&gt;pid;</span><br><span class="line">    <span class="type">int</span> trace_mask = p-&gt;trace_mask;</span><br><span class="line">    <span class="keyword">if</span> (trace_mask != <span class="number">0</span> &amp;&amp; ((trace_mask &gt;&gt; (num)) &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %s -&gt; %d\n&quot;</span>, pid, syscall_name[num<span class="number">-1</span>],p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要 trace 的系统调用使用了 fork 创建了子进程，我们也需要能够 trace 子进程进行的系统调用，所以要在 kernel&#x2F;proc.c#fork 中将 trace_mask 复制给子进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np-&gt;trace_mask = p-&gt;trace_mask;</span><br></pre></td></tr></table></figure><p>trace 的用户程序，xv6 中已经给出，接下来只要将 $U&#x2F;_trace 添加到 Makefile 中就可以运行了。</p><h2 id="Sysinfo-moderate"><a href="#Sysinfo-moderate" class="headerlink" title="Sysinfo (moderate)"></a>Sysinfo (moderate)</h2><p>sysinfo 系统调用用于打印剩余的内存还有多少和打印当前有多少进程处于运行状态，它接受一个 struct sysinfo 结构体参数，然后内核会将信息填入到这个参数中。</p><p>添加 prototype、stub、syscall number、系统调用声明这里就省略了，和上面的操作是一样的。重点说一下 kernel&#x2F;sysproc.c#sys_sysinfo 函数的实现。</p><p>想要获得有多少空余的内存，需要在 kernel&#x2F;kalloc.c 中添加函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">free_mem_size</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    r = kmem.freelist;</span><br><span class="line">    <span class="type">int</span> page_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r) &#123;</span><br><span class="line">        page_num++;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">    <span class="keyword">return</span> page_num * PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 kmem 结构体中存储了一个 freelist 来记录空闲的页数，freelist 中每一个节点都是一个 run 结构体的指针，所以遍历 freelist 并统计剩余的空闲页数即可。</p><p>想要获取有多少进程正在运行，需要在 kernel&#x2F;proc.c 中添加函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">used_proc_num</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">    uint64 proc_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p -&gt; state != UNUSED) &#123;</span><br><span class="line">            proc_num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程都被保存在 proc 数组中，遍历这个数组并判断进程状态再统计数量即可。</p><p>然后我们在 kernel&#x2F;sysproc.c#sys_sysinfo 中调用这两个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    uint64 fm = free_mem_size();</span><br><span class="line">    uint64 np = used_proc_num();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span> =</span> &#123;</span><br><span class="line">        fm,np</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    uint64 addr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;info, <span class="keyword">sizeof</span>(info)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据提示，参考 kernel&#x2F;sysfile.c#sys_fstat 和 kernel&#x2F;file.c#filestat 是如何使用 copyout 来讲数据拷贝回用户空间的。</p><p>最后把 $U&#x2F;_sysinfotest 加入到 Makefile 的 UPROGS 中即可运行。</p><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a739fc6c9d6e4c8d9ceb9f4ee3e922ad~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个 lab 乍一看比较难，但是把整个相关的源码看过一遍之后就还好了，第一个 trace 系统调用，将在进程中保存 trace_mask 和系统调用入口是怎么调用系统调用的关联起来其实就知道怎么实现了。第二个也是阅读 kalloc.c 和 proc.c 的相关代码，就知道怎么操作 kmem 和 proc 了。</p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.s081 Lab1: Xv6 and Unix utilities</title>
      <link href="/post/f71bd04b.html"/>
      <url>/post/f71bd04b.html</url>
      
        <content type="html"><![CDATA[<p>这个 lab 是用来熟悉 xv6 和它的系统调用的，就是用它的系统调用来实现一些小工具。在实现之后要将程序加入 Makefile 里的 UPROGS 中才能执行。</p><h2 id="sleep-eazy"><a href="#sleep-eazy" class="headerlink" title="sleep (eazy)"></a>sleep (eazy)</h2><p>就是调用已经实现的系统调用 sleep （具体实现在 sysproc.c#sys_sleep 中 ） 来实现即可，非常简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有指定参数提示错误信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;must enter a sleep time!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> time = atoi(argv[<span class="number">0</span>]); <span class="comment">// 使用工具函数 atoi 将字符串转化成数字</span></span><br><span class="line">  sleep(time); <span class="comment">// 调用系统调用</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pingpong-eazy"><a href="#pingpong-eazy" class="headerlink" title="pingpong (eazy)"></a>pingpong (eazy)</h2><p>使用 pipe 系统调用创建管道，用 fork 系统调用创建子进程，然后两个进程使用这个管道进行通信，使用 read&#x2F;write 系统调用对 pipe 进行读写即可；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 创建两个管道</span></span><br><span class="line">  <span class="type">int</span> send[<span class="number">2</span>], recv[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">if</span> (pipe(send) &lt; <span class="number">0</span> || pipe(recv) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;there is a problem when create a pipe!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">    <span class="comment">// pid 为 0，即是子进程  </span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    read(send[<span class="number">0</span>], &amp;c, <span class="number">1</span>); <span class="comment">// 阻塞在这里直到父进程向管道中写入</span></span><br><span class="line">    <span class="type">int</span> pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, pid);</span><br><span class="line">    write(recv[<span class="number">1</span>], <span class="string">&quot;a&quot;</span>, <span class="number">1</span>); <span class="comment">// 向父进程发送消息，阻塞直到父进程读取消息</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    write(send[<span class="number">1</span>], <span class="string">&quot;a&quot;</span>, <span class="number">1</span>); <span class="comment">// 向子进程发送消息</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    read(recv[<span class="number">0</span>], &amp;c, <span class="number">1</span>); <span class="comment">// 阻塞，直到收到子进程的消息</span></span><br><span class="line">    <span class="type">int</span> pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, pid);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="primes-moderate-x2F-hard"><a href="#primes-moderate-x2F-hard" class="headerlink" title="primes (moderate&#x2F;hard)"></a>primes (moderate&#x2F;hard)</h2><p>这个是利用 fork 和 pipe 来实现并发的处理质数（除了 1 和 它本身，不能被整除的数）。一开始我还没有懂什么意思，看了这张图之后还是没有搞懂：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e359d7633b124b3c87f734b3d57d2e5b~tplv-k3u1fbpfcp-zoom-1.image"></p><p>后来看到一个 golang 版本的实现才明白是什么意思，也就是 root 父进程向一个通道中发送 2-35，并且 fork 出一个子进程，将这个通道传递给子进程，子进程从管道中读取出一个数，比如当前情况下这个数就是 2，它是一个质数（<strong>通道中的第一个数一定是质数，因为它没有被任何比它小的数给过滤掉</strong>），那么就打印。</p><p>接着这个子进程，再创建一个通道并 fork 一个子进程，然后将父进程通道中剩下的 3-35 都对刚刚取出来的质数 2 取模，如果不等于 0，表示起码不能被 2 整除，就将它放到新创建的通道中给它的子进程处理（看看它能不能被剩下的数整除）。</p><p>循环往复直到有一个子进程在通道里读不出东西了，这个时候表示 2-35 的所有质数都被找到了，就返回。要注意的是，每个进程都要等待它的子进程退出之后才能退出，所以要调用 wait 等待子进程退出。并且<strong>对于不再使用的通道要及时将其关闭</strong>，否则程序算不到 35 就会使 xv6 资源不足。关闭通道分关闭读端和写端，父进程对自己创建的通道只需要写而不需要读，所以它可以将读端先关闭，写完之后再将写端关闭，而子进程对于收到的通道只需要读不需要写，所以在收到之后，它可以先关闭写端，读完后再关闭读端。<strong>父进程不能再创建完后就关闭，而要在 fork 之后再关闭</strong>，因为如果先关闭了，那么子进程再持有到这个通道的文件描述符后，会发现通道的读端是关闭，无法读取数据，会被阻塞（卡了我好久）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">processor</span><span class="params">(<span class="type">int</span> *pipeline)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    close(pipeline[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> prime;</span><br><span class="line">    <span class="type">int</span> read_len = read(pipeline[<span class="number">0</span>], &amp;prime, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (read_len == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipeline[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line">    <span class="type">int</span> out[<span class="number">2</span>];</span><br><span class="line">    pipe(out);</span><br><span class="line">    <span class="keyword">if</span> (!fork())</span><br><span class="line">    &#123;</span><br><span class="line">        processor(out);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(out[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="keyword">while</span> (read(pipeline[<span class="number">0</span>], &amp;num, <span class="keyword">sizeof</span>(<span class="type">int</span>)) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % prime != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                write(out[<span class="number">1</span>], &amp;num, <span class="keyword">sizeof</span>(num));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(out[<span class="number">1</span>]);</span><br><span class="line">        close(pipeline[<span class="number">0</span>]);</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> pipeline[<span class="number">2</span>];</span><br><span class="line">    pipe(pipeline);</span><br><span class="line">    <span class="keyword">if</span> (!fork())</span><br><span class="line">    &#123;</span><br><span class="line">        processor(pipeline);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(pipeline[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> num = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            write(pipeline[<span class="number">1</span>], &amp;num, <span class="keyword">sizeof</span>(num));</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">35</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                close(pipeline[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="find-moderate"><a href="#find-moderate" class="headerlink" title="find (moderate)"></a>find (moderate)</h2><p>find 是用来找出在文件夹中所有的指定名称的文件。</p><p>可以参考 user&#x2F;ls.c 来看如何读取文件夹，并且使用递归来读取子文件夹（不用递归 “.” 和 “..” ，否则会爆栈）。使用 strcmp() 来比较字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件路径中将文件名解析出来，对 ls 中的版本做了修改，去掉了填充</span></span><br><span class="line"><span class="type">char</span> *</span><br><span class="line"><span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="keyword">for</span> (p = path + <span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">        ;</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *filename)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ls: path too long\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">    p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">    *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (de.inum == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        memmove(p, de.name, DIRSIZ);</span><br><span class="line">        p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (stat(buf, &amp;st) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ls: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// st.type 为 2 就是文件，使用 strcmp 作比较</span></span><br><span class="line">        <span class="keyword">if</span> (st.type == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(fmtname(buf), filename))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// st.type 为 1 就是文件夹，判断是否需要递归</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (st.type == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) || !<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            find(buf, filename);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将路径和文件名传入</span></span><br><span class="line">    find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="xargs-moderate"><a href="#xargs-moderate" class="headerlink" title="xargs (moderate)"></a>xargs (moderate)</h2><p>xargs 从标准输入中读取数据，将每一行当作参数添加到 xargs 后面的程序中当作参数，比如：</p><p>echo hello too | xargs echo bye -&gt; echo bye hello too.</p><p>| 符号表示通过管道将数据发送到程序中，所以我们读数据的时候只要使用 read 系统调用在标准输出中读取就可以了，标准输出的 fd 编号为 0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGS 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> buf_idx, read_len;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="type">char</span>* args[MAXARGS];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        args[i<span class="number">-1</span>] = argv[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比如 find . b | xargs grep hello 就有可能传入多行数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buf_idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从标准输出中读取数据到 buf 里，一次读取一个字符</span></span><br><span class="line">            read_len = read(<span class="number">0</span>, &amp;buf[buf_idx], <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">            <span class="comment">// 如果读到了 &#x27;\n&#x27; 或者已经没有数据了，就停止</span></span><br><span class="line">            <span class="keyword">if</span> (read_len &lt;= <span class="number">0</span> || buf[buf_idx] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buf_idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (read_len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加入字符串结束的标识</span></span><br><span class="line">        buf[buf_idx] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        args[argc<span class="number">-1</span>] = buf;</span><br><span class="line">        <span class="comment">// fork 出一条子进程来执行</span></span><br><span class="line">        <span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">            exec(args[<span class="number">0</span>], args);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43b467766b674fc0b1e77ebf0184b67d~tplv-k3u1fbpfcp-zoom-1.image"></p>]]></content>
      
      
      <categories>
          
          <category> MIT 6.s081 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> lab 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 2021 Fall Project4 Concureency Control</title>
      <link href="/post/12f55eb9.html"/>
      <url>/post/12f55eb9.html</url>
      
        <content type="html"><![CDATA[<p>项目 4 我们需要为 DBMS 实现一个<strong>锁管理器</strong>，并且利用锁管理器来实现并发的执行查询计划。锁管理器负责追踪事务涉及到的<strong>元组级的锁（行锁）</strong>，并且基于隔离级别来授予&#x2F;释放<strong>共享锁（Shared Lock）和排它锁（Exclusive Lock）</strong>。</p><p>任务如下：</p><ol><li>Task #1 - Lock Manager</li><li>Task #2 - DeadLock Prevention</li><li>Task #3 - Concurrent Query Execution</li></ol><p>本次项目的难度集中在 Task #1 和 Task #2，如果一些概念不清楚的话很容易到处出现问题，所以在写之前先把隔离级别、两段式锁还有 Wound-Wait 等概念理清楚再来动手写代码。并且一定一定听项目说明中说的先把 <code>transaction.h</code>和 <code>lock_manager.h</code> 中的 API 了解清楚。</p><p><a href="https://juejin.cn/post/7208793045479505980">https://juejin.cn/post/7208793045479505980</a></p><h2 id="TASK-1-LOCK-MANAGER-AND-TASK-2-DEADLOCK-PREVENTION"><a href="#TASK-1-LOCK-MANAGER-AND-TASK-2-DEADLOCK-PREVENTION" class="headerlink" title="TASK #1 - LOCK MANAGER AND TASK #2 - DEADLOCK PREVENTION"></a>TASK #1 - LOCK MANAGER AND TASK #2 - DEADLOCK PREVENTION</h2><p>任务 1 中我们要实现一个全局的锁管理器，每次有事务要访问&#x2F;修改某个元组时，我们就用锁管理器对这个元组上锁，并且锁管理器要根据事务的隔离级别来授予或者释放锁。任务 2 需要使用 <strong>WOUND-WAIT</strong> 算法实现死锁预防</p><p>在 2PL 下各个隔离级别的行为：</p><ul><li><strong>Read Uncommitted：</strong>读取不需要获取锁，但是<strong>写需要获取排他锁</strong>，用完直接释放，不需要等待提交。</li><li><strong>Read Committed：读取需要共享锁，写需要排他锁</strong>，用完直接释放，不需要等待提交。</li><li><strong>Repeatable Read：读取需要共享锁，写需要排他锁</strong>，不能直接释放，必须等到事务提交或者中止时才能释放。</li></ul><p>清楚了在 2PL 下各个隔离级别下的不同行为，再来实现 Lock Manager。</p><h3 id="NeedWait"><a href="#NeedWait" class="headerlink" title="NeedWait"></a>NeedWait</h3><p>我实现了一个 NeedWait 函数来判断事务是否需要阻塞等待，并且使用 <strong>WOUND-WAIT</strong> 来实现死锁预防，基本的使用方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(latch_)</span></span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">NeedWait</span>(txn, rid, LockMode::EXCLUSIVE)) &#123;</span><br><span class="line">lock_table_[rid].cv_.<span class="built_in">wait</span>(guard);</span><br><span class="line">    <span class="keyword">if</span> (txn-&gt;<span class="built_in">GetState</span>() == TransactionState::ABORTED) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NeedWait 函数传入事务想要获取的锁的类型，根据锁类型来判断是否需要阻塞等待：</p><ol><li>事务想要获取共享锁：如果等待队列中有已经授予的排他锁，那么事务阻塞等待。</li><li>事务想要获取排他锁：如果等待队列中有已经授予的锁，那么事务阻塞等待。</li></ol><p>初步判断过后，如果不需要阻塞等待，直接能拿到锁，就返回 false，没有必要再进行死锁预防了（现在并不会产生竞态）。但是如果需要阻塞等待，这时再进行死锁预防，进行死锁预防前将返回值置为 false。</p><p>Wound-Wait 概念如下：</p><ol><li><strong>Timestamp(T**<strong>n</strong></strong>) &lt; Timestamp(T<strong><strong>k</strong></strong>)<em>*, then Tn forces Tk to be killed − that is Tn “wounds” Tk. *T**k</em> <em>is restarted later with a random delay but with the same timestamp(k).</em></li><li><strong>Timestamp(T**<strong>n</strong></strong>) &gt; Timestamp(T<strong><strong>k</strong></strong>)**, then Tn is forced to “wait” until the resource is available.</li></ol><p>将返回值置为 false，遍历等待队列：</p><ul><li>当遇到一个事务的 id 比自己大（这个事务比自己年轻）并且这个事务与自己冲突时，就将其强制中止，接着跳过这轮循环；</li><li>当遇到一个事务的 id 比自己小并且这个事务与自己冲突时，就需要阻塞等待；</li><li>遍历结束后，如果发生了中止，就进行一次通知，唤醒那些被中止的事务返回；</li><li><strong>及时清理掉等待队列中被中止的事务</strong>，否则会出现一个 younger 在等待一个被中止的 older 释放锁。</li></ul><p>最后返回最终的判断结果。</p><h3 id="NeedWaitUpgrade"><a href="#NeedWaitUpgrade" class="headerlink" title="NeedWaitUpgrade"></a>NeedWaitUpgrade</h3><p>这个函数用作 LockUpgrade，<strong>由于 LockUpgrade 是在持有共享锁的情况下升级，所以不需要初步判断是否需要等待</strong>，直接进行死锁预防即可，并且需要获取的锁类型固定是排他锁。</p><p>同样将返回值置为 false，遍历等待队列：</p><ul><li>当遇到一个事务的 id 比自己大并且这个事务与自己冲突时，就将其强制中止，接着跳过这轮循环；</li><li><strong>否则是肯定要等待的</strong>，因为要获取的是排他锁。</li><li>遍历结束后，如果发生了中止，就进行一次通知，唤醒那些被中止的事务返回；</li><li><strong>及时清理掉等待队列中被中止的事务。</strong></li></ul><p>最后返回最终的判断结果。</p><h3 id="LockShared"><a href="#LockShared" class="headerlink" title="LockShared"></a>LockShared</h3><p>这个函数用于获取某个元组的共享锁，<strong>调用该函数的线程会阻塞到成功获取锁或者该事务中止</strong>。在尝试获取锁之前，先根据 2PL 和  事务的隔离级别，来提前做一些判断：</p><ol><li>如果该事务已经中断，直接返回 false。</li><li>如果该事务处于 Shrinking 阶段，就意味着不能再获取锁了，直接中止事务，并抛出异常。</li><li>如果该事务的隔离级别是 Read UnCommitted，就意味着该事务进行读的时候不需要获取锁，直接中止事务，并抛出异常。</li><li>如果事务已经获取了共享锁，那么就直接返回 true。</li></ol><p>然后新建一个 LockRequest，并将其插入到对应的等待队列中去，开始调用 <strong>NeedWait</strong> 进行判断，如果该事务在等待时中止了，就返回 false。当成功获取了共享锁时，把该线程在等待队列中的 LockRequest 的 granted 属性设置为 true，该事务进入 Growing 阶段，将获取到的共享锁放入事务的 <strong>SharedLockSet</strong> 中并返回 true。</p><h3 id="LockExclusive"><a href="#LockExclusive" class="headerlink" title="LockExclusive"></a>LockExclusive</h3><p>该函数的实现跟 LockShared 非常类似，需要注意的就是即使事务的隔离级别是 Read Uncommitted 它也是要获取排他锁来进行写操作的，这时候不能直接中止。</p><h3 id="LockUpgrade"><a href="#LockUpgrade" class="headerlink" title="LockUpgrade"></a>LockUpgrade</h3><p>之前对锁升级的概念存在误区，写成了先将共享锁释放掉，再去尝试获取排他锁，后来在一篇帖子中看到了这样一段话：</p><p>Upgrade: A S(A) can be upgraded to X(A) if Ti is the only transaction holding the S-lock on element A.</p><p><a href="https://www.geeksforgeeks.org/lock-based-concurrency-control-protocol-in-dbms">https://www.geeksforgeeks.org/lock-based-concurrency-control-protocol-in-dbms</a></p><p>即一个元组的共享锁在只有一个事务持有时，就可以将其升级成排他锁，<strong>所以锁升级是在该事务持有共享锁的情况下进行的，</strong>否则锁升级好像就没有什么意义了，就是直接获取排他锁。</p><p>同样，在等待升级锁之前，也可以先进行一系列判断：</p><ol><li>如果事务已经中断、事务没有持有该元组的共享锁或已经有事务（<code>lock_table_[rid].upgrading_ != INVALID_TXN_ID</code>）在等待升级时直接返回 false。</li><li>如果事务已经持有排他锁则直接返回 true。</li><li>如果事务处在 Shrinking 阶段，直接中断事务并抛出异常。</li></ol><p>接下来调用 NeedWaitUpgrade 去尝试升级锁。如果升级成功，把该线程在等待队列中的 LockRequest 的 lock_mode_ 属性设置为排他锁，并将该等待队列的 upgrading_ 设置为 INVALID_TXN_ID，然后把排他锁放进 ExclusiveLockSet 中，将之前的共享锁从 SharedLockSet 中移除，并返回 true。</p><h3 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock"></a>Unlock</h3><ol><li>先判断事务有没有占用该元组的锁，如果没有直接返回。</li><li>开始遍历等待队列，如果找到了自己，就将对应的 LockRequest 移除，并发起一次通知。</li><li>如果没有找到直接返回 false。</li><li>如果事务的隔离级别是 Repeatable Read，并且处于 Growing 阶段，那么事务此时进入 Shrinking 阶段。</li><li>将锁从事务的 LockSet 中移除。</li></ol><h2 id="TASK-3-CONCURRENT-QUERY-EXECUTION"><a href="#TASK-3-CONCURRENT-QUERY-EXECUTION" class="headerlink" title="TASK #3 - CONCURRENT QUERY EXECUTION"></a>TASK #3 - CONCURRENT QUERY EXECUTION</h2><p>任务 3 要将我们实现的锁管理器应用起来，去修改以下 Executor：</p><h3 id="SeqScanExecutor"><a href="#SeqScanExecutor" class="headerlink" title="SeqScanExecutor"></a>SeqScanExecutor</h3><p>在所确定访问的元组后，即遍历到了那个位置的时候（这个时候 rid 才能确定，函数参数是用作返回值的，遍历时还是空值）去获取共享锁。在将参数的值设置好后再将锁释放（<strong>Read Uncommitted、Read Committed</strong> 隔离级别下直接释放，如果是 <strong>Repeatable Read</strong> 则不需要自己编写代码）。</p><h3 id="InsertExecutor"><a href="#InsertExecutor" class="headerlink" title="InsertExecutor"></a>InsertExecutor</h3><p>在所确定访问的元组后获取排他锁（如果已有排他锁就不需要获取，如果已有共享锁就进行升级，否则再获取排他锁）。更新完索引还要往 <strong>index_write_set_</strong> 中插入一条记录，注意 tuple 字段填的是插入表的那个元组。最后释放锁。</p><h3 id="UpdateExecutor"><a href="#UpdateExecutor" class="headerlink" title="UpdateExecutor"></a>UpdateExecutor</h3><p>总体跟 InsertExecutor 类似，但是 UpdateExecutor 在将元组更新后，还需要插入一条记录到 <strong>table_write_set_</strong> 中，tuple 字段是更新前的元组。并且再往 <strong>index_write_set_</strong> 中插入记录时，还需要将记录的 old_tuple_ 字段也附上，即更新前的元组。最后释放锁。</p><h3 id="DeleteExecutor"><a href="#DeleteExecutor" class="headerlink" title="DeleteExecutor"></a>DeleteExecutor</h3><p>跟 InsertExecutor 几乎完全一致。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>四个项目终于都完成了，虽然 Project 4 实现起来没有 Project 2 这么困难，但是感觉理解的并没有那么清晰，还需要阅读更多的资料再结合项目代码好好读一遍，而且这次提交了连 leaderboard 都没有，还有很大的优化空间。 </p>]]></content>
      
      
      <categories>
          
          <category> CMU 15-445 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab 文档 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 2021 Fall Project3 Query Execution</title>
      <link href="/post/be781c2c.html"/>
      <url>/post/be781c2c.html</url>
      
        <content type="html"><![CDATA[<p>项目 3 我们需要实现一些 <strong>Executor</strong> 来执行 <strong>Query Plan</strong>：</p><ul><li><strong>Sequential Scan</strong></li><li><strong>Insert (Raw)</strong></li><li><strong>Insert (Select)</strong></li><li><strong>Update</strong></li><li><strong>Delete</strong></li><li><strong>Nested Loop Join</strong></li><li><strong>Hash Join</strong></li><li><strong>Aggregation</strong></li><li><strong>Limit</strong></li><li><strong>Distinct</strong></li></ul><p>我们会使用的 <strong>Iterator query processing model</strong> 来实现，即 <strong>Volcano</strong> 模型。在这个模型中每个 Executor 都实现了一个 Next 函数，每次执行 Next 函数时，Executor 要么返回一个元组要么返回一个表示没有更多元组的标志。</p><p>项目说明书：<a href="https://15445.courses.cs.cmu.edu/fall2021/project3/">https://15445.courses.cs.cmu.edu/fall2021/project3/</a></p><h2 id="TASK-1-EXECUTORS"><a href="#TASK-1-EXECUTORS" class="headerlink" title="TASK #1 - EXECUTORS"></a>TASK #1 - EXECUTORS</h2><p>这是本项目的唯一一个任务，实现项目说明中指出的 Executor 即可。项目 3 相比于项目 2 的难度系数下降很多，一开始可能会由于 API 不熟悉导致无从下手，但实际上思路都是很简单的，<strong>在写每一个 Executor 之前，先把对应的 Plan 的源码看一下</strong>，碰到不懂的地方可以从测试文件看起，看如何手写一个查询计划，思路就会清晰很多。下文中会将常用的 API 简单的给出。</p><p>而且本项目中有很多工具都是已经写好的，我们<strong>只需要实现 Next 函数和 Init 函数就可以了</strong>，所以通过 Autograder 后最好还是将整个代码全部都过一遍，可以理解的更加深入。</p><h3 id="Sequential-Scan"><a href="#Sequential-Scan" class="headerlink" title="Sequential Scan"></a>Sequential Scan</h3><p>根据 Hint，可以知道需要借助 <strong>TableIterator</strong> 来遍历一张表，查看源码可以发现 <strong>TableHeap</strong> 类中有 <strong>Begin</strong> 和 <strong>End</strong> 函数可以获取对应的<strong>迭代器</strong>，<strong>所以我们可以在初始化的时候将 Executor 中迭代器设置为 Begin 的位置</strong>，接着在执行 Next 函数的时候遍历整张表即可。跟表或索引有关的信息都在 <strong>ExecutorContext</strong> 中。</p><p>注意我们遍历时需要判断是否满足 Predicate 条件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (table_iterator_ != table_info_-&gt;table_-&gt;<span class="built_in">End</span>() &amp;&amp; plan_-&gt;<span class="built_in">GetPredicate</span>() != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">!plan_-&gt;<span class="built_in">GetPredicate</span>()-&gt;<span class="built_in">Evaluate</span>(&amp;(*table_iterator_), plan_-&gt;<span class="built_in">OutputSchema</span>()).<span class="built_in">GetAs</span>&lt;<span class="type">bool</span>&gt;()) &#123;</span><br><span class="line">    table_iterator_++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当满足条件的时候，要根据执行计划的 OutputSchema 来生成元组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Value&gt; values;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;column : plan_-&gt;<span class="built_in">OutputSchema</span>()-&gt;<span class="built_in">GetColumns</span>()) &#123;</span><br><span class="line">values.<span class="built_in">push_back</span>(column.<span class="built_in">GetExpr</span>()-&gt;<span class="built_in">Evaluate</span>(&amp;(*table_iterator_), &amp;table_info_-&gt;schema_));</span><br><span class="line">&#125;</span><br><span class="line">*tuple = <span class="built_in">Tuple</span>(values, plan_-&gt;<span class="built_in">OutputSchema</span>());</span><br></pre></td></tr></table></figure><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p>这里需要实现两种 Insert：</p><ol><li><strong>RawInsert</strong></li><li><strong>SelectInsert</strong></li></ol><p>在 Insert Plan 中有一个函数 IsRawInsert 用来判断是哪种 Insert，如果是 RawInsert 表明不需要执行 <strong>Chlid Executor</strong>，<strong>直接调用 TableHeap 的插入函数将查询计划中的数据插入到表中即可</strong>，而如果是 SelectInsert，那么就要<strong>先初始化</strong> <strong>Chlid Executor，再从 Chlid Exceutor 取出元组并插入。</strong></p><p>在表中成功插入元组后，还需要在索引中插入一个 Index Tuple：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> indexes = exec_ctx_-&gt;<span class="built_in">GetCatalog</span>()-&gt;<span class="built_in">GetTableIndexes</span>(table_info_-&gt;name_);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;index : indexes) &#123;</span><br><span class="line">Tuple index_tuple = tuple-&gt;<span class="built_in">KeyFromTuple</span>(table_info_-&gt;schema_, index-&gt;key_schema_, index-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>());</span><br><span class="line">index-&gt;index_-&gt;<span class="built_in">InsertEntry</span>(index_tuple, *rid, exec_ctx_-&gt;<span class="built_in">GetTransaction</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Insert 中有一个很大的坑，就是虽然测试文件中没有写Insert Executor 不能修改 result_set，而且测试文件中 insert_plan 中的 result_set 也是 nullptr，但是在 Autograder 中有几个测试的 insert_plan 中的 result_set 并不是 nullptr，这个时候就会出现错误。<strong>所以需要一次性将所有数据插入元组再直接返回一个 False 给 Exceutor Engine，避免将数据插入到 result_set 中。</strong></p><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><p><strong>Update Executor 必定会有 Chlid Executor</strong>，所以在初始化时也要将 <strong>Chlid Executor 初始化。</strong>每从 Chlid Executor 中拿出一个元组都调用 <strong>GenerateUpdatedTuple</strong> 函数来生成更新后的元组，再使用 TableHeap 的更新函数即可。<strong>如果更新成功，要将索引中更新前的元组删除，再插入更新后的元组，所以需要记录更新前的那个元组。</strong>Update Executor 同样也<strong>不能修改 result_set</strong>。</p><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>跟 Update Executor 非常类似，每从 Chlid Executor 中拿出一个元组都调用 TableHeap 的 <strong>MarkDelete</strong> 函数（真正的删除在事务提交时执行）。再将索引中对应的元组删除即可。</p><h3 id="Nested-Loop-Join"><a href="#Nested-Loop-Join" class="headerlink" title="Nested Loop Join"></a>Nested Loop Join</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/23042800/1665113369456-cdfb41ce-5da6-4fdd-8d23-a47593f584a8.png" alt="img"></p><p>嵌套两个循环将外表的每一个元组分别跟内表中的每一个元组进行比较，如果满足条件就将其返回（我选择用一个 List 来存储结果，再依次返回）。</p><p>判断是否满足 Join 条件的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plan_-&gt;<span class="built_in">Predicate</span>()-&gt;<span class="built_in">EvaluateJoin</span>(&amp;left_tuple, left_executor_-&gt;<span class="built_in">GetOutputSchema</span>(), right_tuple, right_executor_-&gt;<span class="built_in">GetOutputSchema</span>()).<span class="built_in">GetAs</span>&lt;<span class="type">bool</span>&gt;();</span><br></pre></td></tr></table></figure><p>如果满足条件，组合 Tuple 的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Value&gt; values;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;columns : plan_-&gt;<span class="built_in">OutputSchema</span>()-&gt;<span class="built_in">GetColumns</span>()) &#123;</span><br><span class="line">values.<span class="built_in">emplace_back</span>(columns.<span class="built_in">GetExpr</span>()-&gt;<span class="built_in">EvaluateJoin</span>(&amp;left_tuple, left_executor_-&gt;<span class="built_in">GetOutputSchema</span>(),&amp;right_tuple, right_executor_-&gt;<span class="built_in">GetOutputSchema</span>()));</span><br><span class="line">&#125;</span><br><span class="line">result_.<span class="built_in">emplace_back</span>(<span class="built_in">Tuple</span>(values, plan_-&gt;<span class="built_in">OutputSchema</span>()));</span><br></pre></td></tr></table></figure><h3 id="Hash-Join"><a href="#Hash-Join" class="headerlink" title="Hash Join"></a>Hash Join</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/23042800/1665113888897-2ea9728b-f9f2-4418-8d91-109eab0ca5db.png" alt="img"></p><p>Hint 中让仿照 <strong>SimpleAggregationHashTable</strong> 实现一个 Hash Table，但是感觉好像没有什么必要，我使用了项目中提供的 HashUtil 加上一个 unordered_map 来完成。我们可以在<strong>初始化阶段</strong>将 HashTable 建立好。</p><p>注意，Hint 中提到我们需要处理多个元组的 key 是一样的情况，所以 HashTable 的声明应该是：<code>std::unordered_map&lt;hash_t, std::vector&lt;Tuple&gt;&gt; hash_table_;</code>，将外表中所有 join key 相同的元组存储到一起，在 Probe 时将这些元组统一跟内表中对应的元组进行比较，如果满足条件则拼装起来放入 result 中，方法跟 nested loop join 一样。</p><p>获取 join key 的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> left_join_key = left_expression-&gt;<span class="built_in">Evaluate</span>(&amp;tuple, left_child_-&gt;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line"><span class="keyword">auto</span> hash_key = HashUtil::<span class="built_in">HashValue</span>(&amp;left_join_key);</span><br><span class="line">hash_table_[hash_key].<span class="built_in">emplace_back</span>(tuple);</span><br></pre></td></tr></table></figure><h3 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h3><p>聚合的实现需要的东西很多，但是项目都已经给出来了，在写之前先看一下 SimpleAggregationHashTable 这个类。对于每一个元组，我们只需要调用 MakeAggregateKey、MakeAggregateValue 函数，生成 aggregate_key 和 aggregate_value 然后调用 InsertCombine 函数即可，这样聚合的结果就已经计算好了，存放在 SimpleAggregationHashTable 中，可以用它的迭代器对其中每一条结果进行操作。</p><p>对于有 Having 语句的情况，使用类似的做法判断条件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plan_-&gt;<span class="built_in">GetHaving</span>()-&gt;<span class="built_in">EvaluateAggregate</span>(aht_iterator_.<span class="built_in">Key</span>().group_bys_, aht_iterator_.<span class="built_in">Val</span>().aggregates_).<span class="built_in">GetAs</span>&lt;<span class="type">bool</span>&gt;();</span><br></pre></td></tr></table></figure><p>同样，生成元组的方式也是类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Value&gt; values;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;column : plan_-&gt;<span class="built_in">OutputSchema</span>()-&gt;<span class="built_in">GetColumns</span>()) &#123;</span><br><span class="line">    values.<span class="built_in">emplace_back</span>(</span><br><span class="line">    column.<span class="built_in">GetExpr</span>()-&gt;<span class="built_in">EvaluateAggregate</span>(aht_iterator_.<span class="built_in">Key</span>().group_bys_, aht_iterator_.<span class="built_in">Val</span>().aggregates_));</span><br><span class="line">&#125;</span><br><span class="line">*tuple = <span class="built_in">Tuple</span>(values, plan_-&gt;<span class="built_in">OutputSchema</span>());</span><br></pre></td></tr></table></figure><h3 id="Limit"><a href="#Limit" class="headerlink" title="Limit"></a>Limit</h3><p>Limit 就非常简单了，限制一下调用 Chlid_Executor 的次数就可以了。</p><h3 id="Distinct"><a href="#Distinct" class="headerlink" title="Distinct"></a>Distinct</h3><p>跟 Hash Join 类似，这里也用到了 HashUtil 加上一个 unordered_map 来实现，但现在是为了去重，所以 HashTable 中存储的东西就跟刚刚不一样了，我们将 key 相同的元组的 values 存储在其中，方便进行比较：<code>std::unordered_map&lt;hash_t, std::vector&lt;std::vector&lt;Value&gt;&gt;&gt; distinct_map_&#123;&#125;;</code>。当从 Chlid Executor 中取出一个元组后，用 HashTable 进行去重即可，如果不是重复的就将其放入 result 中，最后依次返回。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>在开始写 Query Execution 之前本来觉得应该非常的费时费脑，但是项目中大部分东西都已经给出，大大降低了难度。但是在自己查看 API 的过程中，发现依旧对这一块内容的理解变深了不少。在降低难度的同时还能加深理解，感谢 Andy。最后 leaderboard 还是不意外的在 100 名开外。</p>]]></content>
      
      
      <categories>
          
          <category> CMU 15-445 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab 文档 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 2021 Fall Project2 Extendible Hash Index</title>
      <link href="/post/ae72c972.html"/>
      <url>/post/ae72c972.html</url>
      
        <content type="html"><![CDATA[<p>项目 2 是实现一个可拓展的哈希索引，它包含一个 directory_page，其中存储了指向 bucket_page 的指针，而数据就存储在 bucket_page 中。这些 page 都会存储在之前写的缓存池中。</p><p>该哈希索引要支持满&#x2F;空桶的拆分&#x2F;合并，并且也要支持目录的拓展和收缩（<strong>Extendible</strong>）。</p><p>本次项目有三个任务，分别是：</p><ul><li>Page Layouts</li><li>Extendible Hashing Implementation</li><li>Concurrency Control</li></ul><h2 id="Extendible-Hash-Index"><a href="#Extendible-Hash-Index" class="headerlink" title="Extendible Hash Index"></a>Extendible Hash Index</h2><p>要完成这个项目首先一定要把 Extendible Hash Index 的流程弄清楚，否则写起来会缺胳膊少腿。可以阅读这篇文章了解先算法流程：</p><p><a href="https://www.geeksforgeeks.org/extendible-hashing-dynamic-approach-to-dbms/">https://www.geeksforgeeks.org/extendible-hashing-dynamic-approach-to-dbms/</a></p><p>，后文的内容默认读者都是已经看过这篇教程，这篇图文教程写的非常清楚，但是并没有写如何收缩，剩下的细节在后面实现中提到。</p><h2 id="TASK-1-PAGE-LAYOUTS"><a href="#TASK-1-PAGE-LAYOUTS" class="headerlink" title="TASK #1 - PAGE LAYOUTS"></a>TASK #1 - PAGE LAYOUTS</h2><p>这个任务就是要实现 directory_page 和 bucket_page，分别来存储哈希表的目录和数据。</p><p>要通过 <strong>Task #1</strong> ，两种页都只需要实现部分方法即可：</p><ul><li><strong>Bucket Page:</strong> - Insert - Remove - IsOccupied - IsReadable - KeyAt - ValueAt</li><li><strong>Directory Page:</strong> - GetGlobalDepth - IncrGlobalDepth - SetLocalDepth - SetBucketPageId - GetBucketPageId</li></ul><p>但为了看起来更有整体性，所以在写的时候就将整个 Extendible Hash Index 所需要的东西全部写上了。</p><h3 id="HASH-TABLE-DIRECTORY-PAGE"><a href="#HASH-TABLE-DIRECTORY-PAGE" class="headerlink" title="HASH TABLE DIRECTORY PAGE"></a>HASH TABLE DIRECTORY PAGE</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>GlobalDepth：</strong></p><p>当 Extendible Hash Index 进行 GetValue、Insert、Remove 时，GlobalDepth 用于确定这个 key 对应的 directory_index 在哪，具体来说就是取这个 key 经过哈希之后的 <strong>低 GlobalDepth 位</strong>来确定 directory_index。比如当前要插入的 key 哈希之后得到的结果是 00110，GlobalDepth 是 3，那么取低 3 位也就是 110，那么 directory_index 就等于 6。但项目中给出的公式是：<code>DirectoryIndex = Hash(key) &amp; GLOBAL_DEPTH_MASK</code>， GLOBAL_DEPTH_MASK 得求出来，其实它就等于 GloablDepth 这么多个 1，所以 GetGlobalDepthMask 函数就很好实现了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; global_depth_) - <span class="number">1</span>; <span class="comment">// 得到 GlobalDepth 这么多个 1.</span></span><br></pre></td></tr></table></figure><p><strong>LocalDepth：</strong></p><p>LocalDepth 并不与 directory_index 相关，而是与 bucket 相关。我们会根据LocalDepth 和 GlobalDepth 的关系来决定当发生 bucket_page 溢出，或者 bucket_page 为空时需要干的事情（具体要到 Extendible Hash Table 的实现）。GetLocalDepthMask 的实现方式跟 GetGlobalDepthMask 一样。</p><p><strong>SplitImageIndex：</strong></p><p>这个指的是 bucket_page 分裂之后，它分裂出来的那个 bucket_page 的 directory_index，只要将当前 bucket的  directory_index 中 LocalDepth 对应的那个位取反即可。比如说 directory_index 是 001，LocalDepth 为 2，那么它的 split_image_index 就是 011，可以通过异或运算来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> bucket_idx ^ (<span class="number">1</span> &lt;&lt; (local_depth - <span class="number">1</span>));</span><br></pre></td></tr></table></figure><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>Mask 和 SplitImageIndex 如何求上面已经写了，还剩下就是 <strong>IncrGlobalDepth、DecrGlobalDepth、Size</strong>。</p><p><strong>IncrGlobalDepth：</strong>当 GlobalDepth 增加时，就是目录需要扩容了，<strong>GlobalDepth 增加 1，目录的容量就增加一倍</strong>，所以实现这个函数时，<strong>我们要把目录扩容前的 bucket 分布情况拷贝一份到扩容后的位置</strong>，也就是此时一个 bucket_page 是有多指针指向它的。注意此时数据还并未进行迁移，因为新的 bucket_page 还没插进来，只是先把目录拓展。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/23042800/1664702021939-5a3b9083-12ee-475a-a6f1-ed52fd9818fc.png" alt="img"></p><p><strong>DecrGlobalDepth：</strong>当 GlobalDepth 减少时，就是目录需要缩小了，<strong>GlobalDepth 减少 1，目录的容量就减少一倍</strong>，但注意只有当所有的 LocalDepth 都小于 GlobalDepth 时，才能减少 GlobalDepth，如果能够减少，<strong>我们只需要 global_depth_–</strong> <strong>即可</strong>，因为 GlobalDepth 减少了，后面的无用位置其实已经访问不到了。</p><p><strong>Size：</strong>返回当前目录的长度，<strong>GlobalDepth 有多少位，目录长度就是 2 的多少次方</strong>，即 1&lt;&lt;global_depth_。</p><h3 id="HASH-TABLE-BUCKET-PAGE"><a href="#HASH-TABLE-BUCKET-PAGE" class="headerlink" title="HASH TABLE BUCKET PAGE"></a>HASH TABLE BUCKET PAGE</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>实现 bucket_page 同样也需要用到很多位运算，因为  occupied_ 数组和  readable_ 数组都是 char 类型的数组，而一个 char 是一个字节，即 8 比特，所以可以标识 bucket_page 中八个位置的情况，我们要用 bucket_index 在 char 数组中找到那个对应的比特。</p><p>occupied_ 数组的含义：<strong>如果 array 的第 i 个索引曾经有被占用过，那 occupied_ 数组的第 i 个比特位就是1。注意：一旦设置为 1，那么这个位置之后就不会再变成 0 了，除非 bucket_page 内容被清空。</strong></p><p>readable_ 数组的含义：<strong>如果 array 的第 i 个索引当前存储了可读的值，那 readable_ 数组的第 i 个比特就是 1 。</strong></p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>首先要实现的是 <strong>IsOccupied、SetOccupied、IsReadable、SetReadable</strong> 函数。我选择的是用除法的方式来确定索引对应的比特位：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> [char_pos, bit_pos] = std::<span class="built_in">div</span>(bucket_idx, CHAR_BIT_SIZE);</span><br></pre></td></tr></table></figure><p>char_pos 即 char 数组中的第几个字符，bit_pos 则是该字符中的第几位是我们要找的位。假设 ch 为一个字符。</p><p>判断找出来的位是否为 1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((ch &gt;&gt; bit_pos) &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>将某一位设置为 1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch |= (<span class="number">1U</span> &lt;&lt; bit_pos);</span><br></pre></td></tr></table></figure><p>将某一位设置为 0：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &amp;= ~(<span class="number">1U</span> &lt;&lt; bit_pos);</span><br></pre></td></tr></table></figure><p>接下来就可以实现 GetValue、Insert、Remove 了：</p><p><strong>Insert：</strong></p><p>插入是可以插入 key 重复，<strong>但不能插入 key 和 value 同时重复的值的，所以不能找到一个空位就插进去，因为后面可能还有 KV 都重复的条目</strong>，要全都检查一遍。</p><p><strong>Remove：</strong></p><p>找到 KV 都符合的那个条目，将 readable_ 数组的这个位置设置为 0 即可。</p><p><strong>GetValue：</strong></p><p>将所有符合 key 的条目都放进 result 数组中，再返回 result 是否为空即可。</p><p><strong>Remove 和 GetValue 有个可以优化的点就是一旦到了一个位置的 occupied 为 0，那么就可以停止遍历了</strong>，因为后面已经没有数据。</p><h2 id="TASK-2-HASH-TABLE-IMPLEMENTATION"><a href="#TASK-2-HASH-TABLE-IMPLEMENTATION" class="headerlink" title="TASK #2 - HASH TABLE IMPLEMENTATION"></a>TASK #2 - HASH TABLE IMPLEMENTATION</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>现在开始可以着手实现可拓展哈希表了，我们要在刚刚之前实现的 bucket_page 和 directory_page 的基础上实现 GetValue、Insert、Remove。如果看了前文提到的博客，应该大致流程都已经了解了，本文再对具体的实现步骤和细节做一个总结。</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p><strong>构造函数：</strong></p><p>我在构造函数中新建了一个 directory_page 和两个 bucket_page，并将 GlobalDepth 设置为 1，再将这两个 bucket_page 的 id 放进目录中，再测试中将所有数据删除后就会恢复到现在的状态，GlobalDepth 和 LocalDepth 最小为 1。<strong>记得 pin 过的页一定要及时的 unpin。</strong></p><p>将 新创建的 Page 对象转成 directory_page 或 bucket_page 可以用下面这种方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> dir_page = <span class="built_in">reinterpret_cast</span>&lt;HashTableDirectoryPage *&gt;(buffer_pool_manager_-&gt;<span class="built_in">NewPage</span>(&amp;<span class="keyword">this</span>-&gt;directory_page_id_)-&gt;<span class="built_in">GetData</span>());</span><br></pre></td></tr></table></figure><p>在实现 FetchDirectoryPage 和 FetchBucketPage 时可以用同样的方法。</p><p><strong>GetValue：</strong></p><p>这个函数的实现没有什么好说，将 directory_page 和 key 所在的 bucket_page 拉出来调用查询方法即可。</p><p><strong>Insert：</strong></p><p>Insert 的实现细节很多，有非常多需要注意的地方，具体的实现步骤如下：</p><ol><li>将 directory_page 和 key 所在的 bucket_page 拉取出来。</li><li>尝试进行插入，若插入成功则直接返回 true，否则进行步骤 3 。</li><li>判断 bucket_page 是否已满，如果未满还是插入失败那么只能是已经重复，返回 false，否则进行步骤 4 。</li><li>如果 bucket_page 已满，<strong>但是这时候不能直接进行分裂</strong>，因为就算是满了的情况，也有可能已经重复，如果这时候分裂就会导致插入错误（我因为这个错误卡了很久），<strong>还要再检查一遍是否重复</strong>。</li><li>这个时候将刚刚用到的页 unpin，进入 split insert 阶段。</li><li>将需要分裂的 bucket_page 的 LocalDepth 加 1，判断 LocalDepth 是否大于 GlobalDepth，如果大于则将 directory 进行扩容，即调用之前实现的 IncrGlobalDepth 函数。</li><li>获取到需要分裂的 bucket_page 的 SplitImageIndex，并为这个兄弟 bucket 创建一个新的页（<strong>注意创建了页之后就不要再 Fetch 了</strong>），取出原 bucket_page 中的所有数据，<strong>再将数据重新散列到这两个页中。</strong></li><li>这里有一个需要注意的地方，一个 bucket 分裂之后，仍然有可能有多个指针指向它，如下图所示。当我们往第五个 bucket_page 里再插入一个数据时，它进行分裂后，它自身和分裂出来的那个页仍然各自都有两个指针指向它，<strong>所以我们不止要设置</strong> <strong>SplitImageIndex 那个位置的指向新分裂出来的页，和它同级的另一个指针也需要指向这个页，并且 LocalDepth 也要更新成一样的。</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/23042800/1664805475296-670e19f5-0a2c-4420-be46-eff1f8d87191.png" alt="img"></p><ol><li>最后再次尝试插入需要插入的那个值，<strong>这里要重新通过哈希和 mask 来获取应该插入的地方</strong>。</li><li>将使用到的页 unpin 并返回。</li></ol><p>Remove：</p><ol><li>将 directory_page 和 key 所在的 bucket_page 拉取出来。</li><li>尝试进行删除，如果删除失败则直接返回 false，否则将使用到的页 unpin 并进行步骤 3，调用 Merge 函数 。</li><li>再次拉取 directory_page 和 key 所在的 bucket_page，检查 bucket_page 是否为空，如果不为空则 unpin 并返回，否则进行步骤 4 。</li><li>如果该 bucket_page 的 LocalDepth 小于等于 1，或 它不等于它 <strong>SplitImage</strong> 的 LocalDepth，则 unpin 并返回，否则进行步骤 5 。</li><li><strong>将该 bucket_page 的 SplitImage 的 LocalDepth 减 1，并将 LocalDepth 减 1 后的所有同级 bucket 的 LocalDepth 和指向的 bucket_page 都设置为 SplitImage 。</strong>这一步跟 <strong>Insert 的步骤 8</strong> 类似。</li><li><strong>一定要先 unpin 该 bucket_page</strong> ，然后再将这个页删除。</li><li>将使用到的页 unpin 并返回。</li></ol><p>Extendible Hash Table 到这里就已经可以通过<strong>除了并发控制测试之外</strong>的所有测试了。</p><h2 id="TASK-3-CONCURRENCY-CONTROL"><a href="#TASK-3-CONCURRENCY-CONTROL" class="headerlink" title="TASK #3 - CONCURRENCY CONTROL"></a>TASK #3 - CONCURRENCY CONTROL</h2><p>最后我们要进行并发控制，给页上锁的方式项目说明中已经详细写到了，这里就不再多做说明，只说一下加锁的思路。</p><p><strong>GetValue：</strong></p><p>table_latch_ 和 bucket_page 的锁均上读锁即可。</p><p><strong>Insert：</strong></p><p>插入阶段，table_latch_ 只需要上读锁即可，但是对 bucket_page 要上写锁，因为此时只对一个 bucket_page 进行修改。</p><p><strong>SplitInsert：</strong></p><p>这个阶段因为目录也有可能被修改，所以两个都需要上写锁。</p><p><strong>Remove：</strong></p><p>跟 Insert 同理。</p><p><strong>Merge：</strong></p><p>跟 SplitInsert 同理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>项目二整体还是非常难的，首先一定要认真搞清楚 Extendible Hash Table 到底是什么再来动手，否则从一开始就会理解不了。然后用到了很多位运算，如果之前没什么经验的话也需要琢磨一下。现在这个版本等整个项目写完了再考虑优化一下吧，提交上去发现发现花了三十几秒。</p>]]></content>
      
      
      <categories>
          
          <category> CMU 15-445 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab 文档 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445 2021 Fall Project1 Buffer Pool</title>
      <link href="/post/bd7291a8.html"/>
      <url>/post/bd7291a8.html</url>
      
        <content type="html"><![CDATA[<p>CMU 15-445 的配套项目 BusTub 是一个面向磁盘的 DBMS，所以首先要做的事就是写一个缓存池来<strong>管理从磁盘上拉取的页</strong>，<strong>因为 DBMS 是不能直接在磁盘上的进行修改的</strong>，需要通过缓存池。</p><p>缓存池负责将磁盘上的页放入内存或反之。缓存池可以让 DBMS 感觉可用内存比实际的内存要大（有点像虚拟内存的概念）。</p><p>本次项目有三个任务，分别是：</p><ol><li>LRU Replacement Policy：实现 LRU 替换机制。</li><li>Buffer Pool Manager Instance：实现缓存池管理器的实例。</li><li>Parallel Buffer Pool Manager：实现并行的缓存池管理器。</li></ol><p>项目说明书链接：<a href="https://15445.courses.cs.cmu.edu/fall2021/project1/">https://15445.courses.cs.cmu.edu/fall2021/project1/</a></p><h2 id="TASK-1-LRU-REPLACEMENT-POLICY"><a href="#TASK-1-LRU-REPLACEMENT-POLICY" class="headerlink" title="TASK #1 - LRU REPLACEMENT POLICY"></a>TASK #1 - LRU REPLACEMENT POLICY</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>实现一个 <strong>LRUReplacer</strong> 来进行页的调度，需要实现以下方法：</p><ul><li><strong>Victim(frame_id_t*)：</strong>将最近最少使用的页的帧号从 Replacer 中移除并返回。</li><li><strong>Pin(frame_id_t)：</strong>将指定页的帧从 Replacer 中移除。</li><li><strong>Unpin(frame_id_t)：</strong>将指定页的帧添加到 Replacer 中，BufferPoolManager 在调用该方法时，<strong>页</strong>的 pin_count 必须是 0，即当前没有线程在使用这个页。</li><li><strong>Size()：</strong>返回 Replacer 的长度。</li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>首先要区分<strong>帧号和页号</strong>的概念，<strong>页号指的是磁盘中页存储位置，而帧号是该页的拷贝在缓存池中的位置。</strong>所以上述方法实际上操作的都是帧号，<strong>BufferPoolManagerInstance</strong> 在这些方法返回帧号后，再根据帧号，在缓存池的 pages_ 数组中将真正的页取出来。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/23042800/1664617275859-eabc6904-e4b0-4fb2-9187-db0d784d9525.png" alt="img"></p><p>然后就是 <strong>pin 和 unpin</strong> 的概念，pin 了某个帧指的是当前有线程在使用这个帧中的页，每有一个线程使用了该页，就会将其 pin_count 加 1，所以 Pin 函数的作用是将其从 Replacer 中移除，这样当有其他线程调用 Victim 函数时，这个被 Pin 的页就不会被替换算法踢出内存。unpin 就是相反的，当线程使用完了该页时，就会将 pin_count 减 1，当 pin_count 变成 0 时，就调用 Unpin 函数将其重新放进 Replacer 中，等待被替换出去。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>LRU 的实现有一个很常见的想法就是使用一个<strong>队列</strong>来实现，最近刚用过的帧会被插到队尾，那么队首就是最近最少使用的帧，所以 <strong>Victim 函数就直接将队首元素出队即可，Unpin 函数也只需要将 unpin 的那个帧插入队尾即可。</strong></p><p>但问题在于 Pin 函数，因为如果要将一个元素直接移除出队列的话，都需要遍历一遍整个队列，这样就造成了性能的损失。所以我们可以使用一个 <strong>unordered_map</strong> 来存储每个元素在队列中的位置，C++ 的话可以存储该元素的迭代器，那么就可以直接通过 erase 函数来将该元素移除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;<span class="type">frame_id_t</span>&gt; frame_id_list_;</span><br><span class="line">std::unordered_map&lt;<span class="type">frame_id_t</span>, std::list&lt;<span class="type">frame_id_t</span>&gt;::iterator&gt; location_map_;</span><br></pre></td></tr></table></figure><p>其他需要注意的点就是尽量使用 <strong>count 函数代替 find 函数</strong>，用 <strong>emplace_back 函数取代 push_back函数</strong>，可以提高性能。还有就是移除的时候需要判断一下 Replacer 是不是已经空了。</p><h2 id="Task-2-BUFFER-POOL-MANAGER-INSTANCE"><a href="#Task-2-BUFFER-POOL-MANAGER-INSTANCE" class="headerlink" title="Task #2 - BUFFER POOL MANAGER INSTANCE"></a>Task #2 - BUFFER POOL MANAGER INSTANCE</h2><h3 id="任务："><a href="#任务：" class="headerlink" title="任务："></a>任务：</h3><ul><li><strong>FetchPgImp(page_id)：</strong>根据 page_id 从磁盘中拉取页并放入缓存池中。</li><li><strong>UnpinPgImp(page_id, is_dirty)：</strong>将指定页的 pin_count 减 1，如果 pin_count 等于 0 了就调用 Unpin 函数将这个帧放入 Replacer 中。</li><li><strong>FlushPgImp(page_id)：</strong>将对应的页刷入磁盘中。</li><li><strong>NewPgImp(page_id)：</strong>创建一个新的页。</li><li><strong>DeletePgImp(page_id)：</strong>删除一个页。</li><li><strong>FlushAllPagesImpl()：</strong>将所有页刷入磁盘中。</li></ul><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>操作磁盘的 DiskManager 此次实验已经提供了，不需要自己实现。关于 Page 对象的介绍一定要仔细看项目说明里的内容。</p><p>系统中的所有内存页面都由 Page 对象表示。 <strong>BufferPoolManagerInstance 不需要了解这些页面的内容。</strong> 但是对于系统开发人员来说，重要的是要了解 Page 对象只是缓冲池中的<strong>内存容器</strong>，因此并<strong>不特定于唯一页面</strong>。 也就是说，每个 Page 对象都包含一块内存，DiskManager 只是使用它作为一个内存中的位置来复制它从磁盘读取的物理页面的内容。 <strong>BufferPoolManagerInstance 将重用相同的 Page 对象来存储数据</strong>，因为它来回移动到磁盘，即如果该 Page 写入了或重新拉取了都有可能是不同的内容。 <strong>这意味着在系统的整个生命周期中，同一个 Page 对象可能包含不同的物理页面。</strong> Page 对象的标识符 (page_id) 跟踪它包含的物理页面； 如果 Page 对象不包含物理页面，则其 page_id 必须设置为 INVALID_PAGE_ID。</p><p>每个 Page 对象还维护一个计数器，用于 “pinned” 该页面的线程数。BufferPoolManagerInstance 不允许释放pinned 的页面。 每个 Page 对象还跟踪它是否是 dirty 状态。如果一个页被修改了，那应该将其设置为 dirty 状态。 <strong>BufferPoolManagerInstance 必须将脏页的内容写回磁盘，然后才能重用该对象。</strong></p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>这几个函数实现起来还是相对简单的，基本上都给出了详细的步骤，并且可以结合头文件中的注释来写，这里只记录一下碰到的一些坑。</p><ol><li><p>在 <strong>FlushPgImp</strong> 函数中，<strong>不要去做多余的判断</strong>，因为文档注释中已经明确指出<strong>只有在页表中找不到该页的时候才返回 false，否则返回 true。</strong>并且不管这个页是否是脏页都将其写回磁盘，否则有些测试是无法通过的。</p></li><li><p>在 <strong>NewPgImp</strong> 函数和 <strong>FetchPgImp</strong> 函数中，需要判断缓存池是否已满和缓存池中的页是否都是 pinned 状态：If all the pages in the buffer pool are pinned, return nullptr。但很容易由于这句话而去循环遍历所有的页来判断，其实并不需要，我的做法是判断空闲列表是否为空且 <strong>Replacer</strong> 的长度是否为 0。如果空闲列表不为空，那肯定是可以拉取页的；如果空闲列表为空，但是 Replacer 的长度不为 0，就代表可以将 Replacer 中标记的页替换出去，仍旧可以拉取页。<code>if (free_list_.empty() &amp;&amp; replacer_-&gt;Size() == 0) &#123; return nullptr; &#125;</code></p></li><li><p>使用 <strong>NewPgImp</strong> 函数创建新页时，一定要先确定是可以创建时再调用 <strong>AllocatePage</strong> 函数。</p></li><li><p><strong>UnpinPgImp</strong> 函数中，不能直接将 is_dirty 参数设置到属性中，需要判断一下 is_dirty 是否为 true。如果参数是 false，而实际上该页是脏页，那么就可能会丢失数据。</p></li><li><p>使用<code>std::lock_guard&lt;std::mutex&gt; guard(latch_)</code>来给函数上锁，在 return 的时候会自动释放锁。</p></li></ol><h2 id="TASK-3-PARALLEL-BUFFER-POOL-MANAGER"><a href="#TASK-3-PARALLEL-BUFFER-POOL-MANAGER" class="headerlink" title="TASK #3 - PARALLEL BUFFER POOL MANAGER"></a>TASK #3 - PARALLEL BUFFER POOL MANAGER</h2><h3 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h3><ul><li><strong>ParallelBufferPoolManager(num_instances, pool_size, disk_manager, log_manager)</strong></li><li><strong>~ParallelBufferPoolManager()</strong></li><li><strong>GetPoolSize()</strong></li><li><strong>GetBufferPoolManager(page_id)：</strong>根据 page_id 获取对应的 <strong>BufferPoolManagerInstance</strong>。</li><li><strong>FetchPgImp(page_id)</strong></li><li><strong>UnpinPgImp(page_id, is_dirty)</strong></li><li><strong>FlushPgImp(page_id)</strong></li><li><strong>NewPgImp(page_id)</strong></li><li><strong>DeletePgImp(page_id)</strong></li><li><strong>FlushAllPagesImpl()</strong></li></ul><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>单个 <strong>BufferPoolManagerInstance</strong> 需要使用锁以保证线程安全，在线程多的情况下会造成大量的竞争，所以该任务的意图就是使用多个 <strong>BufferPoolManagerInstance</strong> 来解决大量竞争的问题。</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>Task 3 的实现就比较简单了，基本上方法就是两行代码，首先使用 <strong>GetBufferPoolManager</strong> 获取 <strong>BufferPoolManagerInstance</strong>，再调用对应方法即可。可以使用一个数组来存储这些 <strong>BufferPoolManagerInstance</strong>，在构造函数中对其进行初始化。参数中的 <strong>num_instances</strong> 是 <strong>BufferPoolManagerInstance</strong> 的数量，instance_index 是每个 <strong>BufferPoolManagerInstance</strong> 对应的索引，初始化的时候要注意一下不要写反。</p><p>唯一一个不是两行搞定的就是 NewPgImp 函数，该函数的时候使用 <strong>round robin</strong> 的方式从一个起始位置（一开始设置为 0 ）开始遍历，直到成功返回 page 或者索引又回到了起始位置返回 nullptr，遍历结束后将起始索引顺序移动一位（需要用模运算，因为相当于在一个环中移动）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Page *<span class="title">ParallelBufferPoolManager::NewPgImp</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(latch_)</span></span>; <span class="comment">// 只在该函数中加了锁</span></span><br><span class="line">  <span class="type">size_t</span> index = next_index_;</span><br><span class="line">  Page *page;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    page = buffer_pool_manager_instances_[index]-&gt;<span class="built_in">NewPage</span>(page_id);</span><br><span class="line">    <span class="keyword">if</span> (page != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index = (index + <span class="number">1</span>) % num_instances_;</span><br><span class="line">  &#125; <span class="keyword">while</span> (index != next_index_);</span><br><span class="line">  next_index_ = (next_index_ + <span class="number">1</span>) % num_instances_;</span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Project 1 虽然比较简单，但通过本次项目对缓存池有了一个更深的理解，代码提交之后 leaderboard 排到 80 多名，等再学一段时间 C++ 尝试优化一下，现在这门语言对我的心智负担太重了。往后有时间的话也可以看一下 <strong>DiskManager</strong> 具体是怎么实现的，</p>]]></content>
      
      
      <categories>
          
          <category> CMU 15-445 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab 文档 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Hi-there-👋"><a href="#Hi-there-👋" class="headerlink" title="Hi there 👋"></a>Hi there 👋</h2><p><img src="http://github-profile-summary-cards.vercel.app/api/cards/profile-details?username=bigboss2063&theme=github"></p><h3 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h3><p>My name is Bruce Chen, you can call me bigboss or bb.The reason I am called “bigboss” is that I am a big fan of the Metal Gear Solid games.</p><p>I am a second-year graduate student majoring in computer science. I am very interested in system programming and database kernel, and I hope to work in this field in the future.</p><p>Besides coding, my favorite thing in life is listening to music, especially r&amp;b. David Tao and Dean Ting are my favorite singers.</p><h3 id="Projects"><a href="#Projects" class="headerlink" title="Projects"></a>Projects</h3><p>I’m currently working on <a href="https://github.com/Kirov7/CouloyDB">CouloyDB</a> as a maintainer and I want to make this a production level project 🤨.</p><p>I’m also working on <a href="https://github.com/nutsdb/nutsdb">nutsdb</a> as a newly promoted maintainer. In the future, I will optimize nutsdb one step further, and add some paper practice to nutsdb.</p><p>In the future, I think I will participate more in some distributed or time series database projects, instead of limiting myself to only storage engines.</p><h3 id="Contact-Me"><a href="#Contact-Me" class="headerlink" title="Contact Me"></a>Contact Me</h3><p>If you want to get in touch, feel free to send me an email at <code>bigboss2063@outlook.com</code>.</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>search</title>
      <link href="/search/index.html"/>
      <url>/search/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
