<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="lab3 属实是重量级，折磨了我好长时间。做 lab3 之前一定一定一定要先仔细的看 xv6 book 和任务指导书，不然就是无头苍蝇乱碰了。 同时还有 kernel&#x2F;memlayout.h、kernel&#x2F;vm.c、kernel&#x2F;kalloc.c 都需要认真看看相关代码。 Lab3 就是要给每一个进程都添加一个自己的内核页表，并且把用户页表中的映射给复制进去，在进程进">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT 6.s081 Lab3: Page Table">
<meta property="og:url" content="https://bigboss2063.github.io/post/b51235b3.html">
<meta property="og:site_name" content="bigboss2063&#39;s blog">
<meta property="og:description" content="lab3 属实是重量级，折磨了我好长时间。做 lab3 之前一定一定一定要先仔细的看 xv6 book 和任务指导书，不然就是无头苍蝇乱碰了。 同时还有 kernel&#x2F;memlayout.h、kernel&#x2F;vm.c、kernel&#x2F;kalloc.c 都需要认真看看相关代码。 Lab3 就是要给每一个进程都添加一个自己的内核页表，并且把用户页表中的映射给复制进去，在进程进">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33074b82b5b04df996bdf0c4f9f0aed6~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/170f9ee70f9e4ff59711e06f0c10a916~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="article:published_time" content="2023-04-05T11:51:47.000Z">
<meta property="article:modified_time" content="2023-05-01T11:55:48.387Z">
<meta property="article:author" content="bigboss2063">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="lab 文档">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33074b82b5b04df996bdf0c4f9f0aed6~tplv-k3u1fbpfcp-zoom-1.image">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>MIT 6.s081 Lab3: Page Table</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/categories/">categories</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/bigboss2063">Projects</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/post/282c8539.html"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/post/ef0d189.html"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://bigboss2063.github.io/post/b51235b3.html"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://bigboss2063.github.io/post/b51235b3.html&text=MIT 6.s081 Lab3: Page Table"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://bigboss2063.github.io/post/b51235b3.html&title=MIT 6.s081 Lab3: Page Table"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bigboss2063.github.io/post/b51235b3.html&is_video=false&description=MIT 6.s081 Lab3: Page Table"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=MIT 6.s081 Lab3: Page Table&body=Check out this article: https://bigboss2063.github.io/post/b51235b3.html"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://bigboss2063.github.io/post/b51235b3.html&title=MIT 6.s081 Lab3: Page Table"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://bigboss2063.github.io/post/b51235b3.html&title=MIT 6.s081 Lab3: Page Table"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://bigboss2063.github.io/post/b51235b3.html&title=MIT 6.s081 Lab3: Page Table"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://bigboss2063.github.io/post/b51235b3.html&title=MIT 6.s081 Lab3: Page Table"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://bigboss2063.github.io/post/b51235b3.html&name=MIT 6.s081 Lab3: Page Table&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://bigboss2063.github.io/post/b51235b3.html&t=MIT 6.s081 Lab3: Page Table"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Print-a-page-table-easy"><span class="toc-number">1.</span> <span class="toc-text">Print a page table (easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-kernel-pagetable-per-process-hard"><span class="toc-number">2.</span> <span class="toc-text">A kernel pagetable per process (hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Simplify-copyin-x2F-copyinstr-hard"><span class="toc-number">3.</span> <span class="toc-text">Simplify copyin&#x2F;copyinstr (hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C"><span class="toc-number">4.</span> <span class="toc-text">测试结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        MIT 6.s081 Lab3: Page Table
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">bigboss2063</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-04-05T11:51:47.000Z" class="dt-published" itemprop="datePublished">2023-04-05</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/MIT-6-s081/">MIT 6.s081</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/lab-%E6%96%87%E6%A1%A3/" rel="tag">lab 文档</a>, <a class="p-category" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>lab3 属实是重量级，折磨了我好长时间。做 lab3 之前一定一定一定要先仔细的看 <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/xv6/book-riscv-rev1.pdf">xv6 book</a> 和<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/labs/pgtbl.html">任务指导书</a>，不然就是无头苍蝇乱碰了。</p>
<p>同时还有 kernel&#x2F;memlayout.h、kernel&#x2F;vm.c、kernel&#x2F;kalloc.c 都需要认真看看相关代码。</p>
<p>Lab3 就是要给每一个进程都添加一个自己的内核页表，并且把用户页表中的映射给复制进去，在进程进入内核态之后，可以使用进程中的内核页表，通过硬件来进行寻址。在实现这个 lab 之前，xv6 只能从用户态传入一个地址，但是这个地址在内核中是无法使用的，因为内核页表中没有这个映射，所以只能通过软件模拟 MMU 来进行寻址，效率不高。</p>
<h2 id="Print-a-page-table-easy"><a href="#Print-a-page-table-easy" class="headerlink" title="Print a page table (easy)"></a>Print a page table (easy)</h2><p>任务书上说是可以帮助后面的 debug，但是我没有用到。不过可以做到对于 xv6 的页表有一个初步的认识。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33074b82b5b04df996bdf0c4f9f0aed6~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>xv6 的页表如上图所示。在 CPU 的 satp 寄存器中存储了第二层页表的物理地址，它里面存储了 512 条 PTE（page table entry），每条 PTE 的高 44 位 PPN 用于计算出下一层页表的物理地址或者拼接出存储数据的物理地址。一条虚拟地址被分成了 L2、L1、L0 各 9 bit，对应着三层页表，分别指出三层页表中的 PTE。还有 offset，占 12 bit，用于和第 0 层的 PPN 拼接得到数据的物理地址。</p>
<p>所以要打印这个页表，我们就要从第二层开始，逐层遍历 PTE 并打印，然后取出下一层的页表开始遍历打印，直到最低层。</p>
<p>pagetable_t 其实就是一个 uint64 类型的指针，其实也就是一个数组，数组中有 512 个元素对应 512 条 PTE，进行遍历的过程中要判断 PTE 是否有效，无效就不打印，还要判断 PTE 是否指向下一层的页表，如果是就将 PTE 转化成下一层页表的物理地址，递归到下一层进行打印，否则就直接打印。根据任务指导书，具体如何判断 PTE 参考 kernel&#x2F;vm.c#freewalk 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_vmprint(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level) &#123;</span><br><span class="line">  <span class="keyword">if</span> (level == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> (pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="keyword">if</span> (level != <span class="number">0</span> &amp;&amp; !((pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="number">0</span>)) <span class="keyword">continue</span>;</span><br><span class="line">      uint64 pa = PTE2PA(pte);</span><br><span class="line">      <span class="type">int</span> j;</span><br><span class="line">      <span class="keyword">for</span> (j = level; j &lt;= <span class="number">2</span>; j++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">2</span>) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;.. &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, pa);</span><br><span class="line">      _vmprint((<span class="type">pagetable_t</span>) pa, level<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  _vmprint(pagetable, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-kernel-pagetable-per-process-hard"><a href="#A-kernel-pagetable-per-process-hard" class="headerlink" title="A kernel pagetable per process (hard)"></a>A kernel pagetable per process (hard)</h2><p>xv6 中，每个进程都有一个自己的用户空间页表，这个页表只包含该进程的用户地址空间的映射。在内核中有一个单独的内核页表，所有的进程进入内核态后，都是用的是这个内核页表。<strong>所以用户地址在内核中是无法使用的，因为内核页表中没有对该地址的映射</strong>，<strong>只能通过 walk 来模拟 MMU 将用户虚拟地址再转化为物理地址使用。</strong></p>
<p>所以部分的任务就是给每个进程都弄一个自己的内核页表，并且在下个部分将用户空间页表中的映射复制到自己的内核页表中，这样在进入内核态的时候就可以直接使用这些映射了。</p>
<p>首先，我们在 strcut proc 中添加一个 kpagetable 变量来存储内核页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pagetable_t</span> kpagetable;      <span class="comment">// Process&#x27;s kernel pagetable</span></span><br></pre></td></tr></table></figure>

<p>我们需要在创建进程的时候给他复制一份内核页表，内核页表是通过 kernel&#x2F;vm.c#kvminit 初始化，在其中使用 kernel&#x2F;vm.c#kvmmap 进行一些映射，我们需要修改版的 kvminit 函数和 kvmmap 函数来对进程的内核页表进行修改。因为这两个函数只是针对全局的 kernel_pagetable，没办法传参数。照着写就可以了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ukvmmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;ukvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_kpagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line">  pagetable = uvmcreate();</span><br><span class="line">  <span class="keyword">if</span> (pagetable == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  ukvmmap(pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  ukvmmap(pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CLINT</span></span><br><span class="line">  ukvmmap(pagetable, CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  ukvmmap(pagetable, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  ukvmmap(pagetable, KERNBASE, KERNBASE, (uint64) etext - KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  ukvmmap(pagetable, (uint64) etext, (uint64) etext, PHYSTOP - (uint64) etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  ukvmmap(pagetable, TRAMPOLINE, (uint64) trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着在 kernel&#x2F;proc.c#allocproc 中调用上述函数来初始化进程的内核页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... kernel/proc.c#allocproc</span></span><br><span class="line">p-&gt;kpagetable = proc_kpagetable(p);</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;kpagetable == <span class="number">0</span>) &#123;</span><br><span class="line">  freeproc(p);</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照任务说明书，我们需要将进程的内核栈映射到内核页表中，原本内核栈的初始化是在 kernel&#x2F;proc.c#procinit 中，现在我们将内核栈放在 allocproc 中来分配，就跟在内核页表初始化之后。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... kernel/proc.c#allocproc</span></span><br><span class="line"><span class="type">char</span> *pa = kalloc();</span><br><span class="line"><span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">  panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">uint64 va = KSTACK((<span class="type">int</span>) (p - proc));</span><br><span class="line">ukvmmap(p-&gt;kpagetable, va, (uint64) pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">p-&gt;kstack = va;</span><br></pre></td></tr></table></figure>

<p>到这里内核页表就初始化完成了。接下来修改 kernel&#x2F;proc.c#scheduler 函数，因为当前每个进程有了自己的内核页表，那么在进入内核态之后就要使用自己的页表，也就是将第二层页表的物理地址放入 satp 寄存器中，<strong>在进程执行完之后一定要把全局的内核页表再设置回去</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... kernel/proc.c#scheduler</span></span><br><span class="line">p-&gt;state = RUNNING;</span><br><span class="line">c-&gt;proc = p;</span><br><span class="line">w_satp(MAKE_SATP(p-&gt;kpagetable));</span><br><span class="line">sfence_vma(); <span class="comment">// 使用 vma 指令清除 TLB 缓存，否则可能访问到其他进程的数据！</span></span><br><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line">kvminithart(); <span class="comment">// 在切换完毕之后使用 kvminithart 将全局内核页表设置会 satp</span></span><br></pre></td></tr></table></figure>

<p>接下来就是释放页表空间了，这一部分也卡了我很久。在 kernel&#x2F;proc.c#freeproc 中是释放进程的逻辑，我们要在这里面添加释放进程的内核页表的逻辑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;kpagetable)</span><br><span class="line">  proc_freekpagetable(p, p-&gt;sz);</span><br><span class="line">p-&gt;kpagetable = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>proc_freekpagetable 函数的实现主要干了两件事，第一是释放掉进程的内核栈，第二是取消了进程的内核页表中的映射，但是<strong>一定不能释放映射指向的物理地址</strong>！因为进程的内核页表仅仅只是复制了映射。我们只释放页表本身的空间。</p>
<p>仿照 freewalk 实现了 proc_freekpagetable 函数，只释放掉页表页，而不释放最低层 PTE 指向的物理内存，具体做法是判断 PTE 是否还是指向下一层页表，如果是才进到下一层释放，这样就不会进到数据页中去释放内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freekpagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> ((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>) &#123; <span class="comment">// 判断是否还有下一层</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      freekpagetable((<span class="type">pagetable_t</span>) child);</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*) pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里 usertests 测试就可以通过了。</p>
<h2 id="Simplify-copyin-x2F-copyinstr-hard"><a href="#Simplify-copyin-x2F-copyinstr-hard" class="headerlink" title="Simplify copyin&#x2F;copyinstr (hard)"></a>Simplify copyin&#x2F;copyinstr (hard)</h2><p>这部分就是在刚刚给进程添加的内核页表中添加用户地址空间的映射。那么在内核中就可以直接使用用户空间地址，使用硬件 MMU 进行寻址，相比于用软件模拟 MMU 寻址效率更高。目标就是将 kernel&#x2F;vm.c#copyin 和 kernel&#x2F;vm.c#copyinstr 分别替换成 kernel&#x2F;vmcopyin.c#copyin_new 和 kernel&#x2F;vmcopyin.c#copyinstr_new。所以我们要在修改用户页表的每一处也对进程的内核页表都进行同步才能做到这一点。</p>
<p>首先仿照 kernel&#x2F;vm.c#uvmcopy 实现 kernel&#x2F;vm.c#uvmcopypg 用以拷贝页表，因为 uvmcopy 是在 fork 的时候把父进程的内存拷贝给子进程，所以它新分配了物理内存给子进程，所以我们不能直接用，因为<strong>内核页表仅仅只是拷贝映射</strong>，而拷贝映射的空间在 allocproc 时就已经分配了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopypg</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">pagetable_t</span> kpagetable, uint64 sz, uint64 start)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = PGROUNDUP(start); i &lt; sz; i+=PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopypg: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopypg: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte) &amp; ~PTE_U; <span class="comment">// 一定要设置 U 标识符，否则内核无法访问这个 PTE</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mappages(kpagetable, i, PGSIZE, pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  err:</span><br><span class="line">  uvmunmap(kpagetable, PGROUNDUP(start), (i - PGROUNDUP(start)) / PGSIZE, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来按照提示，分别在 kernel&#x2F;proc.c#userinit、kernel&#x2F;proc.c#fork、kernel&#x2F;exec.c#exec、kernel&#x2F;proc.c#growproc 中添加同步内核页表的代码。</p>
<p><strong>userinit</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 在进程页表初始化完成之后拷贝页表</span></span><br><span class="line"><span class="comment">// copy pagetable&#x27;s mappings to kpagetable, but don&#x27;t copy pa.</span></span><br><span class="line"><span class="keyword">if</span> (uvmcopypg(p-&gt;pagetable, p-&gt;kpagetable, p-&gt;sz, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  panic(<span class="string">&quot;uvmcopypg: fail to copy pagetable to kpagetable!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>fork</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 在子进程拷贝完父进程的用户页表后，再将子进程的用户页表拷贝给内核页表</span></span><br><span class="line"><span class="keyword">if</span>(uvmcopypg(np-&gt;pagetable, np-&gt;kpagetable, p-&gt;sz, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  freeproc(np);</span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>exec</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在成功生成 user image 后，先清除原本的内核页表，再将新的用户页表拷贝到内核页表</span></span><br><span class="line">uvmunmap(p-&gt;kpagetable, <span class="number">0</span>, PGROUNDUP(oldsz) / PGSIZE, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (uvmcopypg(pagetable, p-&gt;kpagetable, sz, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">goto</span> bad;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Commit to the user image.</span></span><br><span class="line">oldpagetable = p-&gt;pagetable;</span><br><span class="line">p-&gt;pagetable = pagetable;</span><br></pre></td></tr></table></figure>

<p><strong>growproc</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在进程空间扩容并且进程用户页表扩容之后，将扩容的那部分数据拷贝到内核页表</span></span><br><span class="line">    <span class="keyword">if</span> (uvmcopypg(p-&gt;pagetable, p-&gt;kpagetable, sz, sz-n)&lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果拷贝失败了，那么进程就要缩回到原本的容量</span></span><br><span class="line">      sz = uvmdealloc(p-&gt;pagetable, sz, sz-n);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">    <span class="comment">// 在进程空间缩小后并且进程页表页表也缩小之后，将缩小的那部分映射给去掉</span></span><br><span class="line">    <span class="type">int</span> npages = (PGROUNDUP(sz-n) - PGROUNDUP(sz)) / PGSIZE;</span><br><span class="line">    uvmunmap(p-&gt;kpagetable, PGROUNDUP(sz), npages, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于操作系统最低的虚拟地址在 0xC000000，也就是 PLIC 寄存器的地址，如果用户地址空间范围到了 0xC000000 之上，那么就会覆盖掉内核的数据。我们要限制用户地址空间不能超过这个地址。所以我们在 growproc 中判断，如果新的 sz 大于等于 PLIC 了，那么就直接返回 -1 而不执行扩容。</p>
<p>最后就是一个很大的坑，也就是上述全部实现之后会报 remap 的错误，返回去看 xv6 book 之后才发现，在 PLIC 之下还有一段数据是 CLINT，所以如果映射到了这一段，而这里是我们在初始化内核页表的时候就进行映射了的，所以会报 remap 错误。</p>
<p>查看 start.c 后发现 CLINT 仅在内核启动的时候需要，也就是说用户进程在内核中并不需要使用到这一段，所以干脆直接在初始化内核页表的时候不进行这部分的映射了。</p>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/170f9ee70f9e4ff59711e06f0c10a916~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个 lab3 确实难度不低，首先要对 xv6 的页表机制有一个比较深入的理解，然后 DEBUG 也比较难，我除了用 gdb 调试之外，还用了很多 panic 来尽早的发现是在哪里错了。如果不仔细读 xv6 book 把他理解清除的话大抵是做不出来了吧。</p>

  </div>
</article>


    <div class="blog-post-comments">
        <div id="utterances_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>


        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/categories/">categories</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/bigboss2063">Projects</a></li>
        
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Print-a-page-table-easy"><span class="toc-number">1.</span> <span class="toc-text">Print a page table (easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-kernel-pagetable-per-process-hard"><span class="toc-number">2.</span> <span class="toc-text">A kernel pagetable per process (hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Simplify-copyin-x2F-copyinstr-hard"><span class="toc-number">3.</span> <span class="toc-text">Simplify copyin&#x2F;copyinstr (hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C"><span class="toc-number">4.</span> <span class="toc-text">测试结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://bigboss2063.github.io/post/b51235b3.html"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://bigboss2063.github.io/post/b51235b3.html&text=MIT 6.s081 Lab3: Page Table"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://bigboss2063.github.io/post/b51235b3.html&title=MIT 6.s081 Lab3: Page Table"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bigboss2063.github.io/post/b51235b3.html&is_video=false&description=MIT 6.s081 Lab3: Page Table"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=MIT 6.s081 Lab3: Page Table&body=Check out this article: https://bigboss2063.github.io/post/b51235b3.html"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://bigboss2063.github.io/post/b51235b3.html&title=MIT 6.s081 Lab3: Page Table"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://bigboss2063.github.io/post/b51235b3.html&title=MIT 6.s081 Lab3: Page Table"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://bigboss2063.github.io/post/b51235b3.html&title=MIT 6.s081 Lab3: Page Table"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://bigboss2063.github.io/post/b51235b3.html&title=MIT 6.s081 Lab3: Page Table"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://bigboss2063.github.io/post/b51235b3.html&name=MIT 6.s081 Lab3: Page Table&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://bigboss2063.github.io/post/b51235b3.html&t=MIT 6.s081 Lab3: Page Table"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2023
    bigboss2063
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/categories/">categories</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/bigboss2063">Projects</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

    <script type="text/javascript">
      var utterances_repo = 'bigboss2063/blog-comments';
      var utterances_issue_term = 'title';
      var utterances_label = 'Comment';
      var utterances_theme = 'github-dark';

      (function(){
          var script = document.createElement('script');

          script.src = 'https://utteranc.es/client.js';
          script.setAttribute('repo', utterances_repo);
          script.setAttribute('issue-term', 'pathname');
          script.setAttribute('label', utterances_label);
          script.setAttribute('theme', utterances_theme);
          script.setAttribute('crossorigin', 'anonymous');
          script.async = true;
          (document.getElementById('utterances_thread')).appendChild(script);
      }());
  </script>

</body>
</html>
